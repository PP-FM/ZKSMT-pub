unsat
(! (res true true+ (let ((.cse15 (ControlFlow 0 2))) (let ((.cse10 (= .cse15 (- 4)))) (let ((.cse0 (=> .cse10 true))) (res .cse0 (=>+ 1 .cse0) (let ((.cse16 (= (ControlFlow 0 5) 2))) (let ((.cse1 (=> .cse16 .cse0))) (res .cse1 (=>+ 1 .cse1) (let ((.cse17 (= (ControlFlow 0 0) 5))) (let ((.cse2 (=> .cse17 .cse1))) (res .cse2 (=>+ 1 .cse2) (let ((.cse11 (- 0 4))) (let ((.cse9 (= .cse15 .cse11))) (let ((.cse8 (=> .cse9 true))) (let ((.cse7 (=> .cse16 .cse8))) (let ((.cse3 (=> .cse17 .cse7))) (let ((.cse5 (not .cse3))) (res .cse3 (let ((.cse4 (not .cse2))) (res .cse4 (res .cse5 (not+ .cse5) (let ((.cse6 (= .cse5 .cse4))) (res .cse6 (res (= .cse3 .cse2) (res (= .cse7 .cse1) (res (= .cse8 .cse0) (res (= true true) (refl true) (res (= .cse9 .cse10) (res (= .cse11 (- 4)) (let ((.cse12 (* (- 1) 4))) (res (= .cse12 (- 4)) (poly* .cse12 (- 4)) (res (= 0 0) (refl 0) (let ((.cse13 (+ 0 .cse12)) (.cse14 (+ 0 (- 4)))) (res (= .cse13 .cse14) (cong (+ 0 .cse12) (+ 0 (- 4))) (res (= .cse11 .cse13) (-def 0 4) (res (= .cse14 (- 4)) (poly+ .cse14 (- 4)) (trans .cse11 .cse13 .cse14 (- 4))))))))) (res (= .cse15 .cse15) (refl .cse15) (cong (= .cse15 .cse11) (= .cse15 (- 4))))) (cong (=> .cse9 true) (=> .cse10 true)))) (res (= .cse16 .cse16) (refl .cse16) (cong (=> .cse16 .cse8) (=> .cse16 .cse0)))) (res (= .cse17 .cse17) (refl .cse17) (cong (=> .cse17 .cse7) (=> .cse17 .cse1)))) (cong (not .cse3) (not .cse2))) (=-2 .cse6)))) (not- .cse4))) (res .cse5 (assume .cse5) (not- .cse5)))))))))))))))))))) :proves () :input)

