unsat
(! (res true true+ (let ((.cse19 (ControlFlow 0 2))) (let ((.cse20 (=> a0@0 true)) (.cse14 (= .cse19 (- 1)))) (let ((.cse12 (and .cse20 .cse14))) (let ((.cse10 (and .cse12 a0@0))) (let ((.cse0 (=> .cse10 true))) (res .cse0 (=>+ 1 .cse0) (let ((.cse21 (= (ControlFlow 0 3) 2))) (let ((.cse1 (=> .cse21 .cse0))) (res .cse1 (=>+ 1 .cse1) (let ((.cse22 (= (ControlFlow 0 0) 3))) (let ((.cse2 (=> .cse22 .cse1))) (res .cse2 (=>+ 1 .cse2) (let ((.cse15 (- 0 1))) (let ((.cse13 (= .cse19 .cse15))) (let ((.cse11 (and .cse20 .cse13))) (let ((.cse9 (and .cse11 a0@0))) (let ((.cse8 (=> .cse9 true))) (let ((.cse7 (=> .cse21 .cse8))) (let ((.cse3 (=> .cse22 .cse7))) (let ((.cse5 (not .cse3))) (res .cse3 (let ((.cse4 (not .cse2))) (res .cse4 (res .cse5 (not+ .cse5) (let ((.cse6 (= .cse5 .cse4))) (res .cse6 (res (= .cse3 .cse2) (res (= .cse7 .cse1) (res (= .cse8 .cse0) (res (= true true) (refl true) (res (= .cse9 .cse10) (res (= a0@0 a0@0) (refl a0@0) (res (= .cse11 .cse12) (res (= .cse13 .cse14) (res (= .cse15 (- 1)) (let ((.cse16 (* (- 1) 1))) (res (= .cse16 (- 1)) (poly* .cse16 (- 1)) (res (= 0 0) (refl 0) (let ((.cse17 (+ 0 .cse16)) (.cse18 (+ 0 (- 1)))) (res (= .cse17 .cse18) (cong (+ 0 .cse16) (+ 0 (- 1))) (res (= .cse15 .cse17) (-def 0 1) (res (= .cse18 (- 1)) (poly+ .cse18 (- 1)) (trans .cse15 .cse17 .cse18 (- 1))))))))) (res (= .cse19 .cse19) (refl .cse19) (cong (= .cse19 .cse15) (= .cse19 (- 1))))) (res (= .cse20 .cse20) (refl .cse20) (cong (and .cse20 .cse13) (and .cse20 .cse14)))) (cong (and .cse11 a0@0) (and .cse12 a0@0)))) (cong (=> .cse9 true) (=> .cse10 true)))) (res (= .cse21 .cse21) (refl .cse21) (cong (=> .cse21 .cse8) (=> .cse21 .cse0)))) (res (= .cse22 .cse22) (refl .cse22) (cong (=> .cse22 .cse7) (=> .cse22 .cse1)))) (cong (not .cse3) (not .cse2))) (=-2 .cse6)))) (not- .cse4))) (res .cse5 (assume .cse5) (not- .cse5)))))))))))))))))))))))) :proves () :input)

