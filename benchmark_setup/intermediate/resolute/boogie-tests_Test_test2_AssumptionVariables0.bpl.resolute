success
success
success
unsupported
unsupported
unsupported
unsupported
unsupported
unsat
(! (res true true+ (let ((.cse15 (ControlFlow 0 2))) (let ((.cse10 (= .cse15 (- 1)))) (let ((.cse0 (=> .cse10 true))) (res .cse0 (=>+ 1 .cse0) (let ((.cse16 (= (ControlFlow 0 3) 2))) (let ((.cse1 (=> .cse16 .cse0))) (res .cse1 (=>+ 1 .cse1) (let ((.cse17 (= (ControlFlow 0 0) 3))) (let ((.cse2 (=> .cse17 .cse1))) (res .cse2 (=>+ 1 .cse2) (let ((.cse11 (- 0 1))) (let ((.cse9 (= .cse15 .cse11))) (let ((.cse8 (=> .cse9 true))) (let ((.cse7 (=> .cse16 .cse8))) (let ((.cse3 (=> .cse17 .cse7))) (let ((.cse5 (not .cse3))) (res .cse3 (let ((.cse4 (not .cse2))) (res .cse4 (res .cse5 (not+ .cse5) (let ((.cse6 (= .cse5 .cse4))) (res .cse6 (res (= .cse3 .cse2) (res (= .cse7 .cse1) (res (= .cse8 .cse0) (res (= true true) (refl true) (res (= .cse9 .cse10) (res (= .cse11 (- 1)) (let ((.cse12 (* (- 1) 1))) (res (= .cse12 (- 1)) (poly* .cse12 (- 1)) (res (= 0 0) (refl 0) (let ((.cse13 (+ 0 .cse12)) (.cse14 (+ 0 (- 1)))) (res (= .cse13 .cse14) (cong (+ 0 .cse12) (+ 0 (- 1))) (res (= .cse11 .cse13) (-def 0 1) (res (= .cse14 (- 1)) (poly+ .cse14 (- 1)) (trans .cse11 .cse13 .cse14 (- 1))))))))) (res (= .cse15 .cse15) (refl .cse15) (cong (= .cse15 .cse11) (= .cse15 (- 1))))) (cong (=> .cse9 true) (=> .cse10 true)))) (res (= .cse16 .cse16) (refl .cse16) (cong (=> .cse16 .cse8) (=> .cse16 .cse0)))) (res (= .cse17 .cse17) (refl .cse17) (cong (=> .cse17 .cse7) (=> .cse17 .cse1)))) (cong (not .cse3) (not .cse2))) (=-2 .cse6)))) (not- .cse4))) (res .cse5 (assume .cse5) (not- .cse5)))))))))))))))))))) :proves () :input)
unsupported
success
success
success
success
unsupported
unsupported
unsupported
unsupported
unsupported
sat
(error "intermediate/mod_smt2/boogie-tests_Test_test2_AssumptionVariables0.bpl.mod.smt2:60:10: Logical context not inconsistent!")
unsat
(! (let ((.cse20 (ControlFlow 0 2))) (let ((.cse1 (= .cse20 (- 1))) (.cse0 (= (- 1) .cse20))) (let ((.cse34 (= .cse1 .cse0))) (let-proof ((.cse35 (res .cse0 (res .cse1 (=+1 .cse34) (symm (- 1) .cse20)) (res .cse1 (symm .cse20 (- 1)) (=+2 .cse34))))) (res .cse0 (! (res .cse1 (let ((.cse30 (* (- 1) n))) (let ((.cse26 (<= .cse30 0))) (let ((.cse25 (xor a0@0 .cse26))) (let ((.cse22 (not .cse25))) (let ((.cse2 (and .cse22 .cse1))) (res .cse2 (let ((.cse3 (=> .cse2 a0@0))) (res .cse3 (=>+ 0 .cse3) (let ((.cse32 (= (ControlFlow 0 3) 2))) (let ((.cse4 (=> .cse32 .cse3))) (res .cse4 (=>+ 1 .cse4) (let ((.cse33 (= (ControlFlow 0 0) 3))) (let ((.cse5 (=> .cse33 .cse4))) (res .cse5 (=>+ 1 .cse5) (let ((.cse16 (- 0 1)) (.cse28 (<= 0 n))) (let ((.cse21 (= a0@0 .cse28)) (.cse15 (= .cse20 .cse16))) (let ((.cse14 (and .cse21 .cse15))) (let ((.cse11 (=> .cse14 a0@0))) (let ((.cse10 (=> .cse32 .cse11))) (let ((.cse6 (=> .cse33 .cse10))) (let ((.cse8 (not .cse6))) (res .cse6 (let ((.cse7 (not .cse5))) (res .cse7 (res .cse8 (not+ .cse8) (let ((.cse9 (= .cse8 .cse7))) (res .cse9 (res (= .cse6 .cse5) (res (= .cse10 .cse4) (res (= .cse11 .cse3) (let ((.cse12 (= a0@0 a0@0))) (let-proof ((.cse13 (refl a0@0))) (res .cse12 .cse13 (res (= .cse14 .cse2) (res (= .cse15 .cse1) (res (= .cse16 (- 1)) (let ((.cse17 (* (- 1) 1))) (res (= .cse17 (- 1)) (poly* .cse17 (- 1)) (res (= 0 0) (refl 0) (let ((.cse18 (+ 0 .cse17)) (.cse19 (+ 0 (- 1)))) (res (= .cse18 .cse19) (cong (+ 0 .cse17) (+ 0 (- 1))) (res (= .cse16 .cse18) (-def 0 1) (res (= .cse19 (- 1)) (poly+ .cse19 (- 1)) (trans .cse16 .cse18 .cse19 (- 1))))))))) (res (= .cse20 .cse20) (refl .cse20) (cong (= .cse20 .cse16) (= .cse20 (- 1))))) (res (= .cse21 .cse22) (let ((.cse24 (= a0@0 .cse26))) (let ((.cse23 (= .cse24 .cse22))) (res .cse23 (res .cse24 (res .cse25 (res a0@0 (res .cse26 (=+1 .cse24) (xor+ (a0@0 .cse26) (a0@0) (.cse26))) (res .cse26 (xor+ (a0@0 .cse26) (.cse26) (a0@0)) (=+2 .cse24))) (res .cse22 (=+1 .cse23) (not- .cse22))) (res .cse25 (res .cse22 (not+ .cse22) (=+2 .cse23)) (res a0@0 (res .cse26 (xor+ (a0@0) (.cse26) (a0@0 .cse26)) (=-1 .cse24)) (res .cse26 (=-2 .cse24) (xor- (a0@0) (.cse26) (a0@0 .cse26)))))) (res (= .cse21 .cse24) (let ((.cse27 (= .cse28 .cse26))) (res .cse27 (res .cse26 (res .cse28 (=+1 .cse27) (let ((.cse29 (< 0 .cse30))) (res .cse29 (total .cse30 0) (farkas 1 .cse28 1 .cse29)))) (res .cse28 (let ((.cse31 (< n 0))) (res .cse31 (total 0 n) (farkas 1 .cse31 1 .cse26))) (=+2 .cse27))) (res .cse12 .cse13 (cong (= a0@0 .cse28) (= a0@0 .cse26))))) (trans .cse21 .cse24 .cse22))))) (cong (and .cse21 .cse15) (and .cse22 .cse1)))) (cong (=> .cse14 a0@0) (=> .cse2 a0@0)))))) (res (= .cse32 .cse32) (refl .cse32) (cong (=> .cse32 .cse11) (=> .cse32 .cse3)))) (res (= .cse33 .cse33) (refl .cse33) (cong (=> .cse33 .cse10) (=> .cse33 .cse4)))) (cong (not .cse6) (not .cse5))) (=-2 .cse9)))) (not- .cse7))) (res .cse8 (assume .cse8) (not- .cse8)))))))))))))))))) (and- 1 .cse2))))))) (res .cse34 .cse35 (=-2 .cse34))) :proves (+ .cse0) :input) (! (let ((.cse37 (not .cse1))) (res .cse1 (let ((.cse36 (not .cse0))) (res .cse36 (res .cse37 (not+ .cse37) (let ((.cse38 (= .cse37 .cse36))) (res .cse38 (res .cse34 .cse35 (cong (not .cse1) (not .cse0))) (=-2 .cse38)))) (not- .cse36))) (res .cse37 (assume .cse37) (not- .cse37)))) :proves (- .cse0) :input)))))) :proves () :rup)
unsupported
success
success
success
success
unsupported
unsupported
unsupported
unsupported
unsupported
sat
(error "intermediate/mod_smt2/boogie-tests_Test_test2_AssumptionVariables0.bpl.mod.smt2:96:10: Logical context not inconsistent!")
unsat
(! (let ((.cse18 (ControlFlow 0 2))) (let ((.cse1 (= .cse18 (- 1))) (.cse0 (= (- 1) .cse18))) (let ((.cse22 (= .cse1 .cse0))) (let-proof ((.cse23 (res .cse0 (res .cse1 (=+1 .cse22) (symm (- 1) .cse18)) (res .cse1 (symm .cse18 (- 1)) (=+2 .cse22))))) (res .cse0 (! (res .cse1 (let ((.cse19 (=> a0@0 true))) (let ((.cse2 (and .cse19 .cse1))) (res .cse2 (let ((.cse3 (=> .cse2 a0@0))) (res .cse3 (=>+ 0 .cse3) (let ((.cse20 (= (ControlFlow 0 3) 2))) (let ((.cse4 (=> .cse20 .cse3))) (res .cse4 (=>+ 1 .cse4) (let ((.cse21 (= (ControlFlow 0 0) 3))) (let ((.cse5 (=> .cse21 .cse4))) (res .cse5 (=>+ 1 .cse5) (let ((.cse14 (- 0 1))) (let ((.cse13 (= .cse18 .cse14))) (let ((.cse12 (and .cse19 .cse13))) (let ((.cse11 (=> .cse12 a0@0))) (let ((.cse10 (=> .cse20 .cse11))) (let ((.cse6 (=> .cse21 .cse10))) (let ((.cse8 (not .cse6))) (res .cse6 (let ((.cse7 (not .cse5))) (res .cse7 (res .cse8 (not+ .cse8) (let ((.cse9 (= .cse8 .cse7))) (res .cse9 (res (= .cse6 .cse5) (res (= .cse10 .cse4) (res (= .cse11 .cse3) (res (= a0@0 a0@0) (refl a0@0) (res (= .cse12 .cse2) (res (= .cse13 .cse1) (res (= .cse14 (- 1)) (let ((.cse15 (* (- 1) 1))) (res (= .cse15 (- 1)) (poly* .cse15 (- 1)) (res (= 0 0) (refl 0) (let ((.cse16 (+ 0 .cse15)) (.cse17 (+ 0 (- 1)))) (res (= .cse16 .cse17) (cong (+ 0 .cse15) (+ 0 (- 1))) (res (= .cse14 .cse16) (-def 0 1) (res (= .cse17 (- 1)) (poly+ .cse17 (- 1)) (trans .cse14 .cse16 .cse17 (- 1))))))))) (res (= .cse18 .cse18) (refl .cse18) (cong (= .cse18 .cse14) (= .cse18 (- 1))))) (res (= .cse19 .cse19) (refl .cse19) (cong (and .cse19 .cse13) (and .cse19 .cse1)))) (cong (=> .cse12 a0@0) (=> .cse2 a0@0)))) (res (= .cse20 .cse20) (refl .cse20) (cong (=> .cse20 .cse11) (=> .cse20 .cse3)))) (res (= .cse21 .cse21) (refl .cse21) (cong (=> .cse21 .cse10) (=> .cse21 .cse4)))) (cong (not .cse6) (not .cse5))) (=-2 .cse9)))) (not- .cse7))) (res .cse8 (assume .cse8) (not- .cse8)))))))))))))))))) (and- 1 .cse2)))) (res .cse22 .cse23 (=-2 .cse22))) :proves (+ .cse0) :input) (! (let ((.cse25 (not .cse1))) (res .cse1 (let ((.cse24 (not .cse0))) (res .cse24 (res .cse25 (not+ .cse25) (let ((.cse26 (= .cse25 .cse24))) (res .cse26 (res .cse22 .cse23 (cong (not .cse1) (not .cse0))) (=-2 .cse26)))) (not- .cse24))) (res .cse25 (assume .cse25) (not- .cse25)))) :proves (- .cse0) :input)))))) :proves () :rup)
unsupported
success
success
success
success
unsupported
unsupported
unsupported
unsupported
unsupported
sat
(error "intermediate/mod_smt2/boogie-tests_Test_test2_AssumptionVariables0.bpl.mod.smt2:133:10: Logical context not inconsistent!")
unsat
(! (let ((.cse18 (ControlFlow 0 2))) (let ((.cse1 (= .cse18 (- 1))) (.cse0 (= (- 1) .cse18))) (let ((.cse26 (= .cse1 .cse0))) (let-proof ((.cse27 (res .cse0 (res .cse1 (=+1 .cse26) (symm (- 1) .cse18)) (res .cse1 (symm .cse18 (- 1)) (=+2 .cse26))))) (res .cse0 (! (res .cse1 (let ((.cse22 (and ga0 true))) (let ((.cse21 (xor ga0@0 .cse22))) (let ((.cse23 (not .cse21))) (let ((.cse2 (and .cse23 .cse1))) (res .cse2 (let ((.cse3 (=> .cse2 ga0@0))) (res .cse3 (=>+ 0 .cse3) (let ((.cse24 (= (ControlFlow 0 3) 2))) (let ((.cse4 (=> .cse24 .cse3))) (res .cse4 (=>+ 1 .cse4) (let ((.cse25 (= (ControlFlow 0 0) 3))) (let ((.cse5 (=> .cse25 .cse4))) (res .cse5 (=>+ 1 .cse5) (let ((.cse14 (- 0 1))) (let ((.cse20 (= ga0@0 .cse22)) (.cse13 (= .cse18 .cse14))) (let ((.cse12 (and .cse20 .cse13))) (let ((.cse11 (=> .cse12 ga0@0))) (let ((.cse10 (=> .cse24 .cse11))) (let ((.cse6 (=> .cse25 .cse10))) (let ((.cse8 (not .cse6))) (res .cse6 (let ((.cse7 (not .cse5))) (res .cse7 (res .cse8 (not+ .cse8) (let ((.cse9 (= .cse8 .cse7))) (res .cse9 (res (= .cse6 .cse5) (res (= .cse10 .cse4) (res (= .cse11 .cse3) (res (= ga0@0 ga0@0) (refl ga0@0) (res (= .cse12 .cse2) (res (= .cse13 .cse1) (res (= .cse14 (- 1)) (let ((.cse15 (* (- 1) 1))) (res (= .cse15 (- 1)) (poly* .cse15 (- 1)) (res (= 0 0) (refl 0) (let ((.cse16 (+ 0 .cse15)) (.cse17 (+ 0 (- 1)))) (res (= .cse16 .cse17) (cong (+ 0 .cse15) (+ 0 (- 1))) (res (= .cse14 .cse16) (-def 0 1) (res (= .cse17 (- 1)) (poly+ .cse17 (- 1)) (trans .cse14 .cse16 .cse17 (- 1))))))))) (res (= .cse18 .cse18) (refl .cse18) (cong (= .cse18 .cse14) (= .cse18 (- 1))))) (let ((.cse19 (= .cse20 .cse23))) (res .cse19 (res .cse20 (res .cse21 (res ga0@0 (res .cse22 (=+1 .cse20) (xor+ (ga0@0 .cse22) (ga0@0) (.cse22))) (res .cse22 (xor+ (ga0@0 .cse22) (.cse22) (ga0@0)) (=+2 .cse20))) (res .cse23 (=+1 .cse19) (not- .cse23))) (res .cse21 (res .cse23 (not+ .cse23) (=+2 .cse19)) (res ga0@0 (res .cse22 (xor+ (ga0@0) (.cse22) (ga0@0 .cse22)) (=-1 .cse20)) (res .cse22 (=-2 .cse20) (xor- (ga0@0) (.cse22) (ga0@0 .cse22)))))) (cong (and .cse20 .cse13) (and .cse23 .cse1))))) (cong (=> .cse12 ga0@0) (=> .cse2 ga0@0)))) (res (= .cse24 .cse24) (refl .cse24) (cong (=> .cse24 .cse11) (=> .cse24 .cse3)))) (res (= .cse25 .cse25) (refl .cse25) (cong (=> .cse25 .cse10) (=> .cse25 .cse4)))) (cong (not .cse6) (not .cse5))) (=-2 .cse9)))) (not- .cse7))) (res .cse8 (assume .cse8) (not- .cse8)))))))))))))))))) (and- 1 .cse2)))))) (res .cse26 .cse27 (=-2 .cse26))) :proves (+ .cse0) :input) (! (let ((.cse29 (not .cse1))) (res .cse1 (let ((.cse28 (not .cse0))) (res .cse28 (res .cse29 (not+ .cse29) (let ((.cse30 (= .cse29 .cse28))) (res .cse30 (res .cse26 .cse27 (cong (not .cse1) (not .cse0))) (=-2 .cse30)))) (not- .cse28))) (res .cse29 (assume .cse29) (not- .cse29)))) :proves (- .cse0) :input)))))) :proves () :rup)
unsupported
success
success
success
success
unsupported
unsupported
unsupported
unsupported
unsupported
unsat
(! (res true true+ (let ((.cse19 (ControlFlow 0 2))) (let ((.cse20 (=> a0@0 true)) (.cse14 (= .cse19 (- 1)))) (let ((.cse12 (and .cse20 .cse14))) (let ((.cse10 (and .cse12 a0@0))) (let ((.cse0 (=> .cse10 true))) (res .cse0 (=>+ 1 .cse0) (let ((.cse21 (= (ControlFlow 0 3) 2))) (let ((.cse1 (=> .cse21 .cse0))) (res .cse1 (=>+ 1 .cse1) (let ((.cse22 (= (ControlFlow 0 0) 3))) (let ((.cse2 (=> .cse22 .cse1))) (res .cse2 (=>+ 1 .cse2) (let ((.cse15 (- 0 1))) (let ((.cse13 (= .cse19 .cse15))) (let ((.cse11 (and .cse20 .cse13))) (let ((.cse9 (and .cse11 a0@0))) (let ((.cse8 (=> .cse9 true))) (let ((.cse7 (=> .cse21 .cse8))) (let ((.cse3 (=> .cse22 .cse7))) (let ((.cse5 (not .cse3))) (res .cse3 (let ((.cse4 (not .cse2))) (res .cse4 (res .cse5 (not+ .cse5) (let ((.cse6 (= .cse5 .cse4))) (res .cse6 (res (= .cse3 .cse2) (res (= .cse7 .cse1) (res (= .cse8 .cse0) (res (= true true) (refl true) (res (= .cse9 .cse10) (res (= a0@0 a0@0) (refl a0@0) (res (= .cse11 .cse12) (res (= .cse13 .cse14) (res (= .cse15 (- 1)) (let ((.cse16 (* (- 1) 1))) (res (= .cse16 (- 1)) (poly* .cse16 (- 1)) (res (= 0 0) (refl 0) (let ((.cse17 (+ 0 .cse16)) (.cse18 (+ 0 (- 1)))) (res (= .cse17 .cse18) (cong (+ 0 .cse16) (+ 0 (- 1))) (res (= .cse15 .cse17) (-def 0 1) (res (= .cse18 (- 1)) (poly+ .cse18 (- 1)) (trans .cse15 .cse17 .cse18 (- 1))))))))) (res (= .cse19 .cse19) (refl .cse19) (cong (= .cse19 .cse15) (= .cse19 (- 1))))) (res (= .cse20 .cse20) (refl .cse20) (cong (and .cse20 .cse13) (and .cse20 .cse14)))) (cong (and .cse11 a0@0) (and .cse12 a0@0)))) (cong (=> .cse9 true) (=> .cse10 true)))) (res (= .cse21 .cse21) (refl .cse21) (cong (=> .cse21 .cse8) (=> .cse21 .cse0)))) (res (= .cse22 .cse22) (refl .cse22) (cong (=> .cse22 .cse7) (=> .cse22 .cse1)))) (cong (not .cse3) (not .cse2))) (=-2 .cse6)))) (not- .cse4))) (res .cse5 (assume .cse5) (not- .cse5)))))))))))))))))))))))) :proves () :input)
unsupported
success
success
success
success
unsupported
unsupported
unsupported
unsupported
unsupported
unsat
(! (let ((.cse36 (ControlFlow 0 2))) (let ((.cse3 (=> a0@2 a0@1)) (.cse27 (= .cse36 (- 1)))) (let ((.cse0 (and .cse3 .cse27))) (let ((.cse1 (and .cse0 a0@2))) (let ((.cse4 (=> .cse1 a0@1))) (let-proof ((.cse5 (! (let ((.cse8 (=> a0@1 a0@0))) (let ((.cse6 (=> .cse8 .cse4))) (res .cse6 (! (=>+ 1 .cse6) :proves (+ .cse6 - .cse4) :input) (! (let ((.cse49 (xor a0@0 A)) (.cse41 (= .cse36 (- 3)))) (let ((.cse7 (=> .cse41 .cse8)) (.cse50 (not .cse49))) (let ((.cse9 (and .cse50 .cse8)) (.cse12 (and .cse7 .cse6))) (let ((.cse10 (=> .cse9 .cse12))) (let-proof ((.cse11 (let ((.cse51 (= (ControlFlow 0 4) 2))) (let ((.cse13 (=> .cse51 .cse10))) (res .cse13 (=>+ 1 .cse13) (let ((.cse52 (= (ControlFlow 0 0) 4))) (let ((.cse14 (=> .cse52 .cse13))) (res .cse14 (=>+ 1 .cse14) (let ((.cse28 (- 0 1))) (let ((.cse26 (= .cse36 .cse28))) (let ((.cse25 (and .cse3 .cse26))) (let ((.cse42 (- 0 3)) (.cse24 (and .cse25 a0@2))) (let ((.cse23 (=> .cse24 a0@1)) (.cse40 (= .cse36 .cse42))) (let ((.cse39 (=> .cse40 .cse8)) (.cse22 (=> .cse8 .cse23)) (.cse48 (= a0@0 A))) (let ((.cse46 (and .cse48 .cse8)) (.cse21 (and .cse39 .cse22))) (let ((.cse20 (=> .cse46 .cse21))) (let ((.cse19 (=> .cse51 .cse20))) (let ((.cse15 (=> .cse52 .cse19))) (let ((.cse17 (not .cse15))) (res .cse15 (let ((.cse16 (not .cse14))) (res .cse16 (res .cse17 (not+ .cse17) (let ((.cse18 (= .cse17 .cse16))) (res .cse18 (res (= .cse15 .cse14) (res (= .cse19 .cse13) (res (= .cse20 .cse10) (let ((.cse37 (= .cse8 .cse8))) (let-proof ((.cse38 (refl .cse8))) (res (= .cse21 .cse12) (let ((.cse30 (= 0 0)) (.cse34 (= .cse36 .cse36))) (let-proof ((.cse31 (refl 0)) (.cse35 (refl .cse36))) (res (= .cse22 .cse6) (res (= .cse23 .cse4) (res (= a0@1 a0@1) (refl a0@1) (res (= .cse24 .cse1) (res (= a0@2 a0@2) (refl a0@2) (res (= .cse25 .cse0) (res (= .cse26 .cse27) (res (= .cse28 (- 1)) (let ((.cse29 (* (- 1) 1))) (res (= .cse29 (- 1)) (poly* .cse29 (- 1)) (res .cse30 .cse31 (let ((.cse32 (+ 0 .cse29)) (.cse33 (+ 0 (- 1)))) (res (= .cse32 .cse33) (cong (+ 0 .cse29) (+ 0 (- 1))) (res (= .cse28 .cse32) (-def 0 1) (res (= .cse33 (- 1)) (poly+ .cse33 (- 1)) (trans .cse28 .cse32 .cse33 (- 1))))))))) (res .cse34 .cse35 (cong (= .cse36 .cse28) (= .cse36 (- 1))))) (res (= .cse3 .cse3) (refl .cse3) (cong (and .cse3 .cse26) (and .cse3 .cse27)))) (cong (and .cse25 a0@2) (and .cse0 a0@2)))) (cong (=> .cse24 a0@1) (=> .cse1 a0@1)))) (res .cse37 .cse38 (cong (=> .cse8 .cse23) (=> .cse8 .cse4)))) (res (= .cse39 .cse7) (res .cse37 .cse38 (res (= .cse40 .cse41) (res (= .cse42 (- 3)) (let ((.cse43 (* (- 1) 3))) (res (= .cse43 (- 3)) (poly* .cse43 (- 3)) (res .cse30 .cse31 (let ((.cse44 (+ 0 .cse43)) (.cse45 (+ 0 (- 3)))) (res (= .cse44 .cse45) (cong (+ 0 .cse43) (+ 0 (- 3))) (res (= .cse42 .cse44) (-def 0 3) (res (= .cse45 (- 3)) (poly+ .cse45 (- 3)) (trans .cse42 .cse44 .cse45 (- 3))))))))) (res .cse34 .cse35 (cong (= .cse36 .cse42) (= .cse36 (- 3))))) (cong (=> .cse40 .cse8) (=> .cse41 .cse8)))) (cong (and .cse39 .cse22) (and .cse7 .cse6)))))) (res (= .cse46 .cse9) (res .cse37 .cse38 (let ((.cse47 (= .cse48 .cse50))) (res .cse47 (res .cse48 (res .cse49 (res a0@0 (res A (=+1 .cse48) (xor+ (a0@0 A) (a0@0) (A))) (res A (xor+ (a0@0 A) (A) (a0@0)) (=+2 .cse48))) (res .cse50 (=+1 .cse47) (not- .cse50))) (res .cse49 (res .cse50 (not+ .cse50) (=+2 .cse47)) (res a0@0 (res A (xor+ (a0@0) (A) (a0@0 A)) (=-1 .cse48)) (res A (=-2 .cse48) (xor- (a0@0) (A) (a0@0 A)))))) (cong (and .cse48 .cse8) (and .cse50 .cse8))))) (cong (=> .cse46 .cse21) (=> .cse9 .cse12)))))) (res (= .cse51 .cse51) (refl .cse51) (cong (=> .cse51 .cse20) (=> .cse51 .cse10)))) (res (= .cse52 .cse52) (refl .cse52) (cong (=> .cse52 .cse19) (=> .cse52 .cse13)))) (cong (not .cse15) (not .cse14))) (=-2 .cse18)))) (not- .cse16))) (res .cse17 (assume .cse17) (not- .cse17)))))))))))))))))))))) (res .cse7 (! (res .cse8 (! (res .cse9 (res .cse10 (=>+ 0 .cse10) .cse11) (and- 1 .cse9)) :proves (+ .cse8) :input) (! (=>+ 1 .cse7) :proves (+ .cse7 - .cse8) :input)) :proves (+ .cse7) :rup) (! (res .cse12 (and+ .cse12) (res .cse10 (=>+ 1 .cse10) .cse11)) :proves (- .cse7 - .cse6) :input))))))) :proves (- .cse6) :rup)))) :proves (- .cse4) :rup))) (res a0@1 (let-proof ((.cse2 (! (res .cse4 (! (=>+ 0 .cse4) :proves (+ .cse4 + .cse1) :input) .cse5) :proves (+ .cse1) :rup))) (res .cse0 (! (res .cse1 .cse2 (! (and- 0 .cse1) :proves (- .cse1 + .cse0) :input)) :proves (+ .cse0) :rup) (res a0@2 (! (res .cse1 .cse2 (! (and- 1 .cse1) :proves (- .cse1 + a0@2) :input)) :proves (+ a0@2) :rup) (! (res .cse3 (and- 0 .cse0) (=>- .cse3)) :proves (- .cse0 - a0@2 + a0@1) :input)))) (! (res .cse4 (! (=>+ 1 .cse4) :proves (+ .cse4 - a0@1) :input) .cse5) :proves (- a0@1) :rup)))))))) :proves () :rup)
unsupported
