(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun x@1 () Int)
(declare-fun x@0 () Int)
(set-info :boogie-vc-id bar)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 7) (let ((anon0$2_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= x@1 5))))
(let ((inline$foo$1$anon0_correct  (=> (and (= x@1 (+ x@0 1)) (= (ControlFlow 0 3) 2)) anon0$2_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 4) (- 0 5)) (= x@0 4)) (=> (= x@0 4) (=> (= (ControlFlow 0 4) 3) inline$foo$1$anon0_correct)))))
(let ((inline$foo$0$anon0_correct  (=> (and (= x@0 (+ 3 1)) (= (ControlFlow 0 6) 4)) anon0$1_correct)))
(let ((anon0_correct  (=> (= (ControlFlow 0 7) 6) inline$foo$0$anon0_correct)))
anon0_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-sort |T@[Int]Int| 0)
(declare-fun |Select__T@[Int]Int_| (|T@[Int]Int| Int) Int)
(declare-fun Mem@2 () |T@[Int]Int|)
(declare-fun |Store__T@[Int]Int_| (|T@[Int]Int| Int Int) |T@[Int]Int|)
(assert (forall ( ( ?x0 |T@[Int]Int|) ( ?x1 Int) ( ?x2 Int)) (! (= (|Select__T@[Int]Int_| (|Store__T@[Int]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[Int]Int|) ( ?x1 Int) ( ?y1 Int) ( ?x2 Int)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[Int]Int_| (|Store__T@[Int]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[Int]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun Mem@1 () |T@[Int]Int|)
(declare-fun Mem@0 () |T@[Int]Int|)
(declare-fun Mem () |T@[Int]Int|)
(set-info :boogie-vc-id mainA)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((anon0$2_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= (|Select__T@[Int]Int_| Mem@2 1) 0))))
(let ((inline$P$1$anon0_correct  (=> (and (= Mem@2 (|Store__T@[Int]Int_| Mem@1 1 1)) (= (ControlFlow 0 3) 2)) anon0$2_correct)))
(let ((inline$P$0$anon0_correct  (=> (and (= Mem@1 (|Store__T@[Int]Int_| Mem@0 0 1)) (= (ControlFlow 0 4) 3)) inline$P$1$anon0_correct)))
(let ((anon0_correct  (=> (and (= Mem@0 (|Store__T@[Int]Int_| Mem 1 0)) (= (ControlFlow 0 5) 4)) inline$P$0$anon0_correct)))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 6) 5) anon0_correct)))
PreconditionGeneratedEntry_correct))))))
))
(check-sat)
(get-info :reason-unknown)
(assert (not (= (ControlFlow 0 2) (- 1))))
(check-sat)
(pop 1)
; Invalid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Invalid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-sort |T@[Int]Int| 0)
(declare-fun |Select__T@[Int]Int_| (|T@[Int]Int| Int) Int)
(declare-fun Mem@2 () |T@[Int]Int|)
(declare-fun |Store__T@[Int]Int_| (|T@[Int]Int| Int Int) |T@[Int]Int|)
(assert (forall ( ( ?x0 |T@[Int]Int|) ( ?x1 Int) ( ?x2 Int)) (! (= (|Select__T@[Int]Int_| (|Store__T@[Int]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[Int]Int|) ( ?x1 Int) ( ?y1 Int) ( ?x2 Int)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[Int]Int_| (|Store__T@[Int]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[Int]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun Mem@1 () |T@[Int]Int|)
(declare-fun Mem@0 () |T@[Int]Int|)
(declare-fun Mem () |T@[Int]Int|)
(set-info :boogie-vc-id mainB)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((anon0$2_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= (|Select__T@[Int]Int_| Mem@2 1) 1))))
(let ((inline$P$1$anon0_correct  (=> (and (= Mem@2 (|Store__T@[Int]Int_| Mem@1 1 1)) (= (ControlFlow 0 3) 2)) anon0$2_correct)))
(let ((inline$P$0$anon0_correct  (=> (and (= Mem@1 (|Store__T@[Int]Int_| Mem@0 0 1)) (= (ControlFlow 0 4) 3)) inline$P$1$anon0_correct)))
(let ((anon0_correct  (=> (and (= Mem@0 (|Store__T@[Int]Int_| Mem 1 0)) (= (ControlFlow 0 5) 4)) inline$P$0$anon0_correct)))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 6) 5) anon0_correct)))
PreconditionGeneratedEntry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-sort |T@[Int]Int| 0)
(declare-fun |Select__T@[Int]Int_| (|T@[Int]Int| Int) Int)
(declare-fun Mem@2 () |T@[Int]Int|)
(declare-fun |Store__T@[Int]Int_| (|T@[Int]Int| Int Int) |T@[Int]Int|)
(assert (forall ( ( ?x0 |T@[Int]Int|) ( ?x1 Int) ( ?x2 Int)) (! (= (|Select__T@[Int]Int_| (|Store__T@[Int]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[Int]Int|) ( ?x1 Int) ( ?y1 Int) ( ?x2 Int)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[Int]Int_| (|Store__T@[Int]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[Int]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun Mem@1 () |T@[Int]Int|)
(declare-fun Mem@0 () |T@[Int]Int|)
(declare-fun Mem () |T@[Int]Int|)
(set-info :boogie-vc-id mainC)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((anon0$2_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= (|Select__T@[Int]Int_| Mem@2 1) 1))))
(let ((inline$P$1$anon0_correct  (=> (and (= Mem@2 (|Store__T@[Int]Int_| Mem@1 1 1)) (= (ControlFlow 0 3) 2)) anon0$2_correct)))
(let ((inline$P$0$anon0_correct  (=> (and (= Mem@1 (|Store__T@[Int]Int_| Mem@0 0 1)) (= (ControlFlow 0 4) 3)) inline$P$1$anon0_correct)))
(let ((anon0_correct  (=> (and (= Mem@0 (|Store__T@[Int]Int_| Mem 1 0)) (= (ControlFlow 0 5) 4)) inline$P$0$anon0_correct)))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 6) 5) anon0_correct)))
PreconditionGeneratedEntry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-sort T@ref 0)
(declare-fun xyz () T@ref)
(declare-fun xyz@0 () T@ref)
(set-info :boogie-vc-id xyzMain)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$xyzB$0$anon0_correct true))
(let ((anon0_correct  (=> (= xyz xyz@0) (and (=> (= (ControlFlow 0 2) (- 0 3)) (= xyz xyz@0)) (=> (= xyz xyz@0) (=> (= (ControlFlow 0 2) 1) inline$xyzB$0$anon0_correct))))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 4) 2) anon0_correct)))
PreconditionGeneratedEntry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
