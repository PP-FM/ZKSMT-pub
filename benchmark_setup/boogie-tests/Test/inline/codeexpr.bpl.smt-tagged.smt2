(set-logic LIA)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(set-info :boogie-vc-id A1)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 20) (let ((anon0_correct  (and (=> (= (ControlFlow 0 7) (- 0 19)) (forall ((l Bool) (bar$0$l Bool) (bar$0$l@0 Bool) )  (=> (tickleBool bar$0$l@0) (=> (tickleBool bar$0$l) (=> (tickleBool l) (let ((A$1_correct true))
(let ((bar$0$Return_correct A$1_correct))
(let ((bar$0$anon0_correct bar$0$Return_correct))
(let ((bar$0$Entry_correct bar$0$anon0_correct))
(let ((A_correct bar$0$Entry_correct))
A_correct)))))))))) (=> (not (forall ((l@@0 Bool) (bar$0$l@@0 Bool) (bar$0$l@0@@0 Bool) )  (=> (tickleBool bar$0$l@0@@0) (=> (tickleBool bar$0$l@@0) (=> (tickleBool l@@0) (let ((A$1_correct@@0  (not true)))
(let ((bar$0$Return_correct@@0 A$1_correct@@0))
(let ((bar$0$anon0_correct@@0 bar$0$Return_correct@@0))
(let ((bar$0$Entry_correct@@0 bar$0$anon0_correct@@0))
(let ((A_correct@@0 bar$0$Entry_correct@@0))
A_correct@@0)))))))))) (and (=> (= (ControlFlow 0 7) (- 0 13)) (exists ((p Bool) ) (! (forall ((l@@1 Bool) (bar$1$l Bool) (bar$1$l@0 Bool) )  (=> (tickleBool bar$1$l@0) (=> (tickleBool bar$1$l) (=> (tickleBool l@@1) (let ((A$1_correct@@1 true))
(let ((bar$1$Return_correct A$1_correct@@1))
(let ((bar$1$anon0_correct bar$1$Return_correct))
(let ((bar$1$Entry_correct bar$1$anon0_correct))
(let ((A_correct@@1 bar$1$Entry_correct))
A_correct@@1)))))))))
 :qid |codeexprbpl.20:20|
 :skolemid |0|
))) (=> (exists ((p@@0 Bool) ) (!  (not (forall ((l@@2 Bool) (bar$1$l@@0 Bool) (bar$1$l@0@@0 Bool) )  (=> (tickleBool bar$1$l@0@@0) (=> (tickleBool bar$1$l@@0) (=> (tickleBool l@@2) (let ((A$1_correct@@2  (not true)))
(let ((bar$1$Return_correct@@0 A$1_correct@@2))
(let ((bar$1$anon0_correct@@0 bar$1$Return_correct@@0))
(let ((bar$1$Entry_correct@@0 bar$1$anon0_correct@@0))
(let ((A_correct@@2 bar$1$Entry_correct@@0))
A_correct@@2))))))))))
 :qid |codeexprbpl.20:20|
 :skolemid |0|
)) (=> (= (ControlFlow 0 7) (- 0 6)) (forall ((p@@1 Bool) ) (! (forall ((l@@3 Bool) (bar$2$l Bool) (bar$2$l@0 Bool) )  (=> (tickleBool bar$2$l@0) (=> (tickleBool bar$2$l) (=> (tickleBool l@@3) (let ((A$1_correct@@3 true))
(let ((bar$2$Return_correct A$1_correct@@3))
(let ((bar$2$anon0_correct bar$2$Return_correct))
(let ((bar$2$Entry_correct bar$2$anon0_correct))
(let ((A_correct@@3 bar$2$Entry_correct))
A_correct@@3)))))))))
 :qid |codeexprbpl.21:20|
 :skolemid |1|
)))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 20) 7) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun g () Bool)
(set-info :boogie-vc-id A2)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 26) (let ((anon0_correct  (and (=> (= (ControlFlow 0 7) (- 0 25)) (forall ((l Bool) (bar$0$l Bool) (bar$0$l@0 Bool) )  (=> (tickleBool bar$0$l@0) (=> (tickleBool bar$0$l) (=> (tickleBool l) (let ((A$1_correct g))
(let ((bar$0$Return_correct A$1_correct))
(let ((bar$0$anon0_correct bar$0$Return_correct))
(let ((bar$0$Entry_correct bar$0$anon0_correct))
(let ((A_correct  (=> g bar$0$Entry_correct)))
A_correct)))))))))) (=> (not (forall ((l@@0 Bool) (bar$0$l@@0 Bool) (bar$0$l@0@@0 Bool) )  (=> (tickleBool bar$0$l@0@@0) (=> (tickleBool bar$0$l@@0) (=> (tickleBool l@@0) (let ((A$1_correct@@0  (not g)))
(let ((bar$0$Return_correct@@0 A$1_correct@@0))
(let ((bar$0$anon0_correct@@0 bar$0$Return_correct@@0))
(let ((bar$0$Entry_correct@@0 bar$0$anon0_correct@@0))
(let ((A_correct@@0  (=> g bar$0$Entry_correct@@0)))
A_correct@@0)))))))))) (and (=> (= (ControlFlow 0 7) (- 0 19)) (=> g (forall ((l@@1 Bool) (bar$1$l Bool) (bar$1$l@0 Bool) )  (=> (tickleBool bar$1$l@0) (=> (tickleBool bar$1$l) (=> (tickleBool l@@1) (let ((A$1_correct@@1 g))
(let ((bar$1$Return_correct A$1_correct@@1))
(let ((bar$1$anon0_correct bar$1$Return_correct))
(let ((bar$1$Entry_correct bar$1$anon0_correct))
(let ((A_correct@@1 bar$1$Entry_correct))
A_correct@@1))))))))))) (=> (=> g (not (forall ((l@@2 Bool) (bar$1$l@@0 Bool) (bar$1$l@0@@0 Bool) )  (=> (tickleBool bar$1$l@0@@0) (=> (tickleBool bar$1$l@@0) (=> (tickleBool l@@2) (let ((A$1_correct@@2  (not g)))
(let ((bar$1$Return_correct@@0 A$1_correct@@2))
(let ((bar$1$anon0_correct@@0 bar$1$Return_correct@@0))
(let ((bar$1$Entry_correct@@0 bar$1$anon0_correct@@0))
(let ((A_correct@@2 bar$1$Entry_correct@@0))
A_correct@@2))))))))))) (and (=> (= (ControlFlow 0 7) (- 0 13)) (exists ((p Bool) ) (!  (=> g (forall ((l@@3 Bool) (bar$2$l Bool) (bar$2$l@0 Bool) )  (=> (tickleBool bar$2$l@0) (=> (tickleBool bar$2$l) (=> (tickleBool l@@3) (let ((A$1_correct@@3 g))
(let ((bar$2$Return_correct A$1_correct@@3))
(let ((bar$2$anon0_correct bar$2$Return_correct))
(let ((bar$2$Entry_correct bar$2$anon0_correct))
(let ((A_correct@@3 bar$2$Entry_correct))
A_correct@@3))))))))))
 :qid |codeexprbpl.28:20|
 :skolemid |2|
))) (=> (exists ((p@@0 Bool) ) (!  (=> g (not (forall ((l@@4 Bool) (bar$2$l@@0 Bool) (bar$2$l@0@@0 Bool) )  (=> (tickleBool bar$2$l@0@@0) (=> (tickleBool bar$2$l@@0) (=> (tickleBool l@@4) (let ((A$1_correct@@4  (not g)))
(let ((bar$2$Return_correct@@0 A$1_correct@@4))
(let ((bar$2$anon0_correct@@0 bar$2$Return_correct@@0))
(let ((bar$2$Entry_correct@@0 bar$2$anon0_correct@@0))
(let ((A_correct@@4 bar$2$Entry_correct@@0))
A_correct@@4)))))))))))
 :qid |codeexprbpl.28:20|
 :skolemid |2|
)) (=> (= (ControlFlow 0 7) (- 0 6)) (forall ((p@@1 Bool) ) (!  (=> g (forall ((l@@5 Bool) (bar$3$l Bool) (bar$3$l@0 Bool) )  (=> (tickleBool bar$3$l@0) (=> (tickleBool bar$3$l) (=> (tickleBool l@@5) (let ((A$1_correct@@5 g))
(let ((bar$3$Return_correct A$1_correct@@5))
(let ((bar$3$anon0_correct bar$3$Return_correct))
(let ((bar$3$Entry_correct bar$3$anon0_correct))
(let ((A_correct@@5 bar$3$Entry_correct))
A_correct@@5))))))))))
 :qid |codeexprbpl.29:20|
 :skolemid |3|
)))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 26) 7) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun g () Bool)
(set-info :boogie-vc-id A3)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 13) (let ((anon0_correct  (=> (and (not (forall ((l Bool) (bar$0$l Bool) (bar$0$l@0 Bool) )  (=> (tickleBool bar$0$l@0) (=> (tickleBool bar$0$l) (=> (tickleBool l) (let ((A$1_correct  (not g)))
(let ((bar$0$Return_correct A$1_correct))
(let ((bar$0$anon0_correct bar$0$Return_correct))
(let ((bar$0$Entry_correct bar$0$anon0_correct))
(let ((A_correct bar$0$Entry_correct))
A_correct)))))))))) (= (ControlFlow 0 7) (- 0 6))) (forall ((l@@0 Bool) (bar$1$l Bool) (bar$1$l@0 Bool) )  (=> (tickleBool bar$1$l@0) (=> (tickleBool bar$1$l) (=> (tickleBool l@@0) (let ((A$1_correct@@0 g))
(let ((bar$1$Return_correct A$1_correct@@0))
(let ((bar$1$anon0_correct bar$1$Return_correct))
(let ((bar$1$Entry_correct bar$1$anon0_correct))
(let ((A_correct@@0 bar$1$Entry_correct))
A_correct@@0))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 13) 7) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(set-info :boogie-vc-id A4)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 8) (let ((anon0_correct  (=> (= (ControlFlow 0 7) (- 0 6)) (forall ((l Bool) (bar$0$l Bool) (bar$0$l@0 Bool) )  (=> (tickleBool bar$0$l@0) (=> (tickleBool bar$0$l) (=> (tickleBool l) (let ((A$1_correct  (not true)))
(let ((bar$0$Return_correct A$1_correct))
(let ((bar$0$anon0_correct bar$0$Return_correct))
(let ((bar$0$Entry_correct bar$0$anon0_correct))
(let ((A_correct bar$0$Entry_correct))
A_correct))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 8) 7) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(assert (not (= (ControlFlow 0 7) (- 6))))
(check-sat)
(pop 1)
; Invalid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Invalid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun m@0 () Bool)
(set-info :boogie-vc-id A5)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 8) (let ((anon0_correct  (=> (and (= m@0  (not (forall ((l Bool) (bar$0$l Bool) (bar$0$l@0 Bool) )  (=> (tickleBool bar$0$l@0) (=> (tickleBool bar$0$l) (=> (tickleBool l) (let ((A$1_correct  (not true)))
(let ((bar$0$Return_correct A$1_correct))
(let ((bar$0$anon0_correct bar$0$Return_correct))
(let ((bar$0$Entry_correct bar$0$anon0_correct))
(let ((A_correct bar$0$Entry_correct))
A_correct))))))))))) (= (ControlFlow 0 2) (- 0 1))) m@0)))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 8) 2) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(set-info :boogie-vc-id A6)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 32) (let ((anon0_correct  (and (=> (= (ControlFlow 0 11) (- 0 31)) (forall ((l Bool) (baz$0$l Bool) (bar$0$l Bool) (baz$0$l@0 Bool) (bar$0$l@0 Bool) )  (=> (tickleBool bar$0$l@0) (=> (tickleBool baz$0$l@0) (=> (tickleBool bar$0$l) (=> (tickleBool baz$0$l) (=> (tickleBool l) (let ((A$1_correct true))
(let ((baz$0$Return_correct A$1_correct))
(let ((baz$0$anon0$1_correct baz$0$Return_correct))
(let ((bar$0$Return_correct baz$0$anon0$1_correct))
(let ((bar$0$anon0_correct bar$0$Return_correct))
(let ((bar$0$Entry_correct bar$0$anon0_correct))
(let ((baz$0$anon0_correct bar$0$Entry_correct))
(let ((baz$0$Entry_correct baz$0$anon0_correct))
(let ((A_correct baz$0$Entry_correct))
A_correct)))))))))))))))) (=> (not (forall ((l@@0 Bool) (baz$0$l@@0 Bool) (bar$0$l@@0 Bool) (baz$0$l@0@@0 Bool) (bar$0$l@0@@0 Bool) )  (=> (tickleBool bar$0$l@0@@0) (=> (tickleBool baz$0$l@0@@0) (=> (tickleBool bar$0$l@@0) (=> (tickleBool baz$0$l@@0) (=> (tickleBool l@@0) (let ((A$1_correct@@0  (not true)))
(let ((baz$0$Return_correct@@0 A$1_correct@@0))
(let ((baz$0$anon0$1_correct@@0 baz$0$Return_correct@@0))
(let ((bar$0$Return_correct@@0 baz$0$anon0$1_correct@@0))
(let ((bar$0$anon0_correct@@0 bar$0$Return_correct@@0))
(let ((bar$0$Entry_correct@@0 bar$0$anon0_correct@@0))
(let ((baz$0$anon0_correct@@0 bar$0$Entry_correct@@0))
(let ((baz$0$Entry_correct@@0 baz$0$anon0_correct@@0))
(let ((A_correct@@0 baz$0$Entry_correct@@0))
A_correct@@0)))))))))))))))) (and (=> (= (ControlFlow 0 11) (- 0 21)) (exists ((p Bool) ) (! (forall ((l@@1 Bool) (baz$1$l Bool) (bar$1$l Bool) (baz$1$l@0 Bool) (bar$1$l@0 Bool) )  (=> (tickleBool bar$1$l@0) (=> (tickleBool baz$1$l@0) (=> (tickleBool bar$1$l) (=> (tickleBool baz$1$l) (=> (tickleBool l@@1) (let ((A$1_correct@@1 true))
(let ((baz$1$Return_correct A$1_correct@@1))
(let ((baz$1$anon0$1_correct baz$1$Return_correct))
(let ((bar$1$Return_correct baz$1$anon0$1_correct))
(let ((bar$1$anon0_correct bar$1$Return_correct))
(let ((bar$1$Entry_correct bar$1$anon0_correct))
(let ((baz$1$anon0_correct bar$1$Entry_correct))
(let ((baz$1$Entry_correct baz$1$anon0_correct))
(let ((A_correct@@1 baz$1$Entry_correct))
A_correct@@1)))))))))))))))
 :qid |codeexprbpl.60:20|
 :skolemid |4|
))) (=> (exists ((p@@0 Bool) ) (!  (not (forall ((l@@2 Bool) (baz$1$l@@0 Bool) (bar$1$l@@0 Bool) (baz$1$l@0@@0 Bool) (bar$1$l@0@@0 Bool) )  (=> (tickleBool bar$1$l@0@@0) (=> (tickleBool baz$1$l@0@@0) (=> (tickleBool bar$1$l@@0) (=> (tickleBool baz$1$l@@0) (=> (tickleBool l@@2) (let ((A$1_correct@@2  (not true)))
(let ((baz$1$Return_correct@@0 A$1_correct@@2))
(let ((baz$1$anon0$1_correct@@0 baz$1$Return_correct@@0))
(let ((bar$1$Return_correct@@0 baz$1$anon0$1_correct@@0))
(let ((bar$1$anon0_correct@@0 bar$1$Return_correct@@0))
(let ((bar$1$Entry_correct@@0 bar$1$anon0_correct@@0))
(let ((baz$1$anon0_correct@@0 bar$1$Entry_correct@@0))
(let ((baz$1$Entry_correct@@0 baz$1$anon0_correct@@0))
(let ((A_correct@@2 baz$1$Entry_correct@@0))
A_correct@@2))))))))))))))))
 :qid |codeexprbpl.60:20|
 :skolemid |4|
)) (=> (= (ControlFlow 0 11) (- 0 10)) (forall ((p@@1 Bool) ) (! (forall ((l@@3 Bool) (baz$2$l Bool) (bar$2$l Bool) (baz$2$l@0 Bool) (bar$2$l@0 Bool) )  (=> (tickleBool bar$2$l@0) (=> (tickleBool baz$2$l@0) (=> (tickleBool bar$2$l) (=> (tickleBool baz$2$l) (=> (tickleBool l@@3) (let ((A$1_correct@@3 true))
(let ((baz$2$Return_correct A$1_correct@@3))
(let ((baz$2$anon0$1_correct baz$2$Return_correct))
(let ((bar$2$Return_correct baz$2$anon0$1_correct))
(let ((bar$2$anon0_correct bar$2$Return_correct))
(let ((bar$2$Entry_correct bar$2$anon0_correct))
(let ((baz$2$anon0_correct bar$2$Entry_correct))
(let ((baz$2$Entry_correct baz$2$anon0_correct))
(let ((A_correct@@3 baz$2$Entry_correct))
A_correct@@3)))))))))))))))
 :qid |codeexprbpl.61:20|
 :skolemid |5|
)))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 32) 11) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
