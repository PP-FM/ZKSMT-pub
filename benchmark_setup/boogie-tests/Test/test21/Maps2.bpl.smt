(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@name 0)
(declare-sort |T@[Int]Int| 0)
(declare-sort |T@[name][Int]Int| 0)
(declare-fun Unified (|T@[name][Int]Int|) |T@[Int]Int|)
(declare-fun |Store__T@[name][Int]Int_| (|T@[name][Int]Int| T@name |T@[Int]Int|) |T@[name][Int]Int|)
(declare-fun |Select__T@[name][Int]Int_| (|T@[name][Int]Int| T@name) |T@[Int]Int|)
(assert (forall ( ( ?x0 |T@[name][Int]Int|) ( ?x1 T@name) ( ?x2 |T@[Int]Int|)) (! (= (|Select__T@[name][Int]Int_| (|Store__T@[name][Int]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[name][Int]Int|) ( ?x1 T@name) ( ?y1 T@name) ( ?x2 |T@[Int]Int|)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[name][Int]Int_| (|Store__T@[name][Int]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[name][Int]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun Field (Int) T@name)
(declare-fun |Store__T@[Int]Int_| (|T@[Int]Int| Int Int) |T@[Int]Int|)
(declare-fun |Select__T@[Int]Int_| (|T@[Int]Int| Int) Int)
(assert (forall ( ( ?x0 |T@[Int]Int|) ( ?x1 Int) ( ?x2 Int)) (! (= (|Select__T@[Int]Int_| (|Store__T@[Int]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[Int]Int|) ( ?x1 Int) ( ?y1 Int) ( ?x2 Int)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[Int]Int_| (|Store__T@[Int]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[Int]Int_| ?x0 ?y1))) :weight 0)))
(declare-sort T@T 0)
(declare-sort |T@[T][Int]Int| 0)
(declare-fun f (|T@[T][Int]Int|) Int)
(declare-fun |Select__T@[T][Int]Int_| (|T@[T][Int]Int| T@T) |T@[Int]Int|)
(assert (forall ((M |T@[name][Int]Int|) (x Int) (y Int) ) (! (= (Unified (|Store__T@[name][Int]Int_| M (Field x) (|Store__T@[Int]Int_| (|Select__T@[name][Int]Int_| M (Field x)) x y))) (|Store__T@[Int]Int_| (Unified M) x y))
 :qid |Maps2bpl.28:14|
 :skolemid |2|
 :pattern ( (Unified (|Store__T@[name][Int]Int_| M (Field x) (|Store__T@[Int]Int_| (|Select__T@[name][Int]Int_| M (Field x)) x y))))
)))
(assert (forall ((x@@0 |T@[T][Int]Int|) ) (!  (=> (exists ((t T@T) ) (! (= (|Select__T@[Int]Int_| (|Select__T@[T][Int]Int_| x@@0 t) 13) 42)
 :qid |Maps2bpl.12:24|
 :skolemid |0|
)) (= (f x@@0) 5))
 :qid |Maps2bpl.11:15|
 :skolemid |1|
 :pattern ( (f x@@0))
)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun x@0 () |T@[T][Int]Int|)
(declare-fun |Store__T@[T][Int]Int_| (|T@[T][Int]Int| T@T |T@[Int]Int|) |T@[T][Int]Int|)
(assert (forall ( ( ?x0 |T@[T][Int]Int|) ( ?x1 T@T) ( ?x2 |T@[Int]Int|)) (! (= (|Select__T@[T][Int]Int_| (|Store__T@[T][Int]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[T][Int]Int|) ( ?x1 T@T) ( ?y1 T@T) ( ?x2 |T@[Int]Int|)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[T][Int]Int_| (|Store__T@[T][Int]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[T][Int]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun x@@1 () |T@[T][Int]Int|)
(declare-fun t@@0 () T@T)
(set-info :boogie-vc-id P)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((anon0_correct  (=> (and (= x@0 (|Store__T@[T][Int]Int_| x@@1 t@@0 (|Store__T@[Int]Int_| (|Select__T@[T][Int]Int_| x@@1 t@@0) 13 42))) (= (ControlFlow 0 2) (- 0 1))) (= (f x@0) 5))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 3) 2) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
