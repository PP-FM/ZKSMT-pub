(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Factorial (Int) Int)
(declare-fun Factorial_Aux (Int) Int)
(assert (= (Factorial 0) 1))
(assert (forall ((n Int) ) (!  (=> (<= 1 n) (= (Factorial n) (* n (Factorial_Aux (- n 1)))))
 :qid |TuringFactorialbpl.33:15|
 :skolemid |0|
 :pattern ( (Factorial n))
)))
(assert (forall ((n@@0 Int) ) (! (= (Factorial n@@0) (Factorial_Aux n@@0))
 :qid |TuringFactorialbpl.36:15|
 :skolemid |1|
 :pattern ( (Factorial n@@0))
)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun u@3 () Int)
(declare-fun n@@1 () Int)
(declare-fun r@0 () Int)
(declare-fun u@0 () Int)
(declare-fun s@2 () Int)
(declare-fun r@1 () Int)
(declare-fun u@2 () Int)
(declare-fun s@1 () Int)
(declare-fun u@1 () Int)
(set-info :boogie-vc-id ComputeFactorial)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 21) (let ((GeneratedUnifiedExit_correct  (=> (= (ControlFlow 0 14) (- 0 13)) (= u@3 (Factorial n@@1)))))
(let ((anon5_Then_correct  (=> (<= n@@1 r@0) (=> (and (= u@3 u@0) (= (ControlFlow 0 15) 14)) GeneratedUnifiedExit_correct))))
(let ((anon6_Else_correct  (=> (and (< r@0 s@2) (= r@1 (+ r@0 1))) (and (=> (= (ControlFlow 0 5) (- 0 7)) (and (<= 1 r@1) (<= r@1 n@@1))) (=> (and (<= 1 r@1) (<= r@1 n@@1)) (and (=> (= (ControlFlow 0 5) (- 0 6)) (<= 1 u@2)) (=> (<= 1 u@2) (=> (= (ControlFlow 0 5) (- 0 4)) (= u@2 (Factorial r@1))))))))))
(let ((anon6_Then_correct  (=> (<= s@2 r@0) (and (=> (= (ControlFlow 0 2) (- 0 3)) (<= s@2 r@0)) (=> (<= s@2 r@0) (=> (= (ControlFlow 0 2) (- 0 1)) (and (= u@0 (Factorial r@0)) (= u@2 (* s@2 (Factorial r@0))))))))))
(let ((INNER_correct  (=> (<= s@1 r@0) (=> (and (and (= u@0 (Factorial r@0)) (= u@1 (* s@1 (Factorial r@0)))) (and (= u@2 (+ u@1 u@0)) (= s@2 (+ s@1 1)))) (and (=> (= (ControlFlow 0 8) (- 0 9)) (<= (- s@2 1) r@0)) (=> (<= (- s@2 1) r@0) (and (=> (= (ControlFlow 0 8) 2) anon6_Then_correct) (=> (= (ControlFlow 0 8) 5) anon6_Else_correct))))))))
(let ((anon5_Else_correct  (=> (< r@0 n@@1) (and (=> (= (ControlFlow 0 10) (- 0 12)) (<= 1 r@0)) (=> (<= 1 r@0) (and (=> (= (ControlFlow 0 10) (- 0 11)) (and (= u@0 (Factorial r@0)) (= u@0 (* 1 (Factorial r@0))))) (=> (and (= u@0 (Factorial r@0)) (= u@0 (* 1 (Factorial r@0)))) (=> (= (ControlFlow 0 10) 8) INNER_correct))))))))
(let ((TOP_correct  (=> (and (and (<= 1 r@0) (<= r@0 n@@1)) (and (<= 1 u@0) (= u@0 (Factorial r@0)))) (and (=> (= (ControlFlow 0 16) 15) anon5_Then_correct) (=> (= (ControlFlow 0 16) 10) anon5_Else_correct)))))
(let ((anon0_correct  (and (=> (= (ControlFlow 0 17) (- 0 20)) (and (<= 1 1) (<= 1 n@@1))) (=> (and (<= 1 1) (<= 1 n@@1)) (and (=> (= (ControlFlow 0 17) (- 0 19)) (<= 1 1)) (=> (<= 1 1) (and (=> (= (ControlFlow 0 17) (- 0 18)) (= 1 (Factorial 1))) (=> (= 1 (Factorial 1)) (=> (= (ControlFlow 0 17) 16) TOP_correct)))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (<= 1 n@@1) (= (ControlFlow 0 21) 17)) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
