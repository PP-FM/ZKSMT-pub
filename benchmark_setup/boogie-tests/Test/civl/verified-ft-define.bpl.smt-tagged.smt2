(set-logic AUFLIA)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= (select shadow.Lock (ShadowableVar second_x)) nil) (= (select (store shadow.Lock (ShadowableVar second_x) second_tid) (ShadowableVar first_x)) nil)) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) second_tid) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicAcquireVarLock$1$anon0_correct  (=> (= (select shadow.Lock@0 (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicAcquireVarLock$1$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicAcquireVarLock$1$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |45|
)) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableVar first_x)) nil) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |46|
)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |47|
)) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |48|
)) (=> (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateSetW_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |49|
)) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |50|
)) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateSetR_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (not (= (select sx.R first_x) SHARED)))) (=> (=> true (not (= (select sx.R first_x) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |51|
)) (not (= (select sx.R first_x) SHARED))) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |52|
)) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |53|
)) (=> (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |54|
)) (=> (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |55|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select sx.R first_x) SHARED)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |56|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |57|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 8) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |58|
)) (=> (and (and (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid))) (and (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 11) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |59|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2)))) (=> (and (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11)))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 10) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |60|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (=> (and (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 11) 10)))) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 8) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |61|
)) (=> (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select (store shadow.Lock (ShadowableTid second_uid) nil) (ShadowableVar first_x)) nil) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableTid second_uid) nil) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableTid second_uid) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseJoinLock$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |62|
)) (=> (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid)) (=> (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_uid () Int)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseJoinLock_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 7) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (not (= first_tid first_uid)))) (=> (=> true (not (= first_tid first_uid))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_uid))) (=> (=> true (ValidTid first_uid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 6) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |63|
)) (=> (and (= (select shadow.Lock (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid))) (=> (and (and (ValidTid first_uid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 7) 6))) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED)) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil)) (= (select (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid) (ShadowableVar first_x)) nil)) (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true))) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid) (ShadowableVar first_x) first_tid))) (= thread.State thread.State))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock@0 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 3) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |64|
)) (ValidTid first_tid)) (=> (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4)) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= (select (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid) (ShadowableVar first_x)) nil)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid) (ShadowableVar first_x) first_tid))) (= shadow.VC@@0 shadow.VC@@0))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |65|
)) (=> (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4)) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicAllocTid_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) UNUSED) (= (select shadow.Lock@0 (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (=> (=> true (forall ((first_t@@0 Int) ) (!  (=> (= (select thread.State first_t@@0) UNUSED) (= (select shadow.Lock@0 (ShadowableTid first_t@@0)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |66|
)) (forall ((first_t@@1 Int) ) (!  (=> (= (select thread.State first_t@@1) UNUSED) (= (select shadow.Lock (ShadowableTid first_t@@1)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun first_x () T@Var)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= (select (store shadow.Lock (ShadowableTid second_uid) second_uid) (ShadowableVar first_x)) nil) (= thread.State@0 (store thread.State second_uid RUNNING))) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableTid second_uid) second_uid) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 3) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicStartThread$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |67|
)) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun first_uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicStartThread_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 8) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select thread.State first_uid) NEW))) (=> (=> true (= (select thread.State first_uid) NEW)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (not (= first_tid first_uid)))) (=> (=> true (not (= first_tid first_uid))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_uid))) (=> (=> true (ValidTid first_uid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 7) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |68|
)) (= (select thread.State first_uid) NEW)) (and (= (select shadow.Lock (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid)))) (and (and (ValidTid first_uid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 8) 7)))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (= (select (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid) (ShadowableVar first_x)) nil)) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock@0 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |69|
)) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToRelease$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicChooseLockToRelease)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToRelease$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) second_tid) (= (select shadow.Lock (ShadowableVar first_x)) nil)) (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (and (= (select shadow.Lock@0 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) second_tid) (= (ControlFlow 0 3) 2)) inline$AtomicChooseLockToRelease$0$Return_correct)))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseLockToRelease$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |70|
)) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select (store shadow.Lock (ShadowableLock second_l) nil) (ShadowableVar first_x)) nil) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableLock second_l) nil) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableLock second_l) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseChosenLock$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |71|
)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_l () T@Lock)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseChosenLock_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableLock first_l)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableLock first_l)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |72|
)) (=> (and (and (= (select shadow.Lock (ShadowableLock first_l)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicReleaseVarLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableVar first_x) nil))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$1$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) nil)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$1$anon0_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |73|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |74|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicReleaseVarLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |75|
)) (=> (and (and (not (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |76|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |77|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |78|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |79|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |80|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |81|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |82|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |83|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |84|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 11) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |85|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11)))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |86|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicThreadStateGetE_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |87|
)) (=> (and (and (not (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1))))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |88|
)) (=> (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4))) inline$AtomicThreadStateGetE$0$anon0_correct)))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1))))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |89|
)) (=> (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4))) inline$AtomicThreadStateGetE$0$anon0_correct)))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |90|
)) (=> (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicThreadStateGetE$0$anon0_correct)))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@2 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)) (and (and (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@2 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |91|
)) (=> (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicThreadStateGetE$0$anon0_correct)))))
inline$AtomicThreadStateGetE$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |92|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicThreadStateGetE$0$anon0_correct))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i))))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |93|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicThreadStateGetE$0$anon0_correct))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVarStateSetW_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |94|
)) (=> (and (and (not (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateSetW_AtomicVarStateGetW)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateGetW$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W second_x)) (= sx.W@0 (store sx.W first_x first_e))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@0 second_x)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetW$0$Return_correct)))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@0 (store sx.W first_x first_e)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetW$0$anon0_correct)))
(let ((inline$AtomicVarStateSetW$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |95|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateSetW$0$anon0_correct))))
inline$AtomicVarStateSetW$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVarStateGetW_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |96|
)) (=> (and (and (not (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateGetW_AtomicVarStateSetW)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateSetW$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= sx.W@0 (store sx.W second_x second_e)) (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@0 first_x))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@0 (store sx.W second_x second_e)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetW$0$Return_correct)))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W first_x)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetW$0$anon0_correct)))
(let ((inline$AtomicVarStateGetW$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |97|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateGetW$0$anon0_correct))))
inline$AtomicVarStateGetW$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVarStateSetR_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (not (= (select sx.R first_x) SHARED)) (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |98|
)) (=> (and (and (not (and (and (not (= (select sx.R first_x) SHARED)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateSetR_AtomicVarStateGetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateGetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= inline$AtomicVarStateGetR$0$e@1 (select sx.R second_x)) (= sx.R@0 (store sx.R first_x first_e))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@0 second_x)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R first_x first_e)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetR$0$anon0_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |99|
)) (=> (and (not (= (select sx.R first_x) SHARED)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateSetR$0$anon0_correct)))))
inline$AtomicVarStateSetR$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVarStateSetR$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R@0 first_x) SHARED)))))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 5) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |100|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (= (select sx.R first_x) SHARED))) (and (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicVarStateSetR$0$anon0_correct)))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVarStateSetR$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_r) first_tid))) (=> (=> true (= (select shadow.Lock first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R@0 (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 5) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |101|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (and (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicVarStateSetR$0$anon0_correct)))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVarStateSetR$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_r) first_tid))) (=> (=> true (= (select shadow.Lock first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R@0 (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R@0 (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 5) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |102|
)) (= (select shadow.Lock first_r) first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid))) (and (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicVarStateSetR$0$anon0_correct)))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVarStateSetR$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R@0 (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R@0 (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 8) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |103|
)) (=> (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid))) (and (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicVarStateSetR$0$anon0_correct)))))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVarStateGetR_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |104|
)) (=> (and (and (not (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateGetR_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateSetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= sx.R@0 (store sx.R second_x second_e)) (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@0 first_x))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetR$0$e@1 (select sx.R first_x)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetR$0$anon0_correct)))
(let ((inline$AtomicVarStateGetR$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |105|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateGetR$0$anon0_correct)))))
inline$AtomicVarStateGetR$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateGetRShared_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateSetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= (select sx.R@0 first_x) SHARED) (= sx.R@0 (store sx.R second_x second_e))) (= SHARED SHARED)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateGetRShared$0$anon0_correct  (=> (and (= (select sx.R first_x) SHARED) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetR$0$anon0_correct)))
(let ((inline$AtomicVarStateGetRShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |106|
)) (ValidTid first_tid)) (=> (and (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateGetRShared$0$anon0_correct))))
inline$AtomicVarStateGetRShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCGetSize_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 first_r) first_tid) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |107|
)) (=> (and (and (not (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetSize_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1))))) (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@1 first_r)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@@0 first_r))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCGetSize$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |108|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetSize$0$anon0_correct)))))
inline$AtomicVCGetSize$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetSize_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1))))) (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@1 first_r)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@@0 first_r))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVCGetSize$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |109|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetSize$0$anon0_correct)))))
inline$AtomicVCGetSize$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetSize_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@0 first_r)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@@0 first_r))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicVCGetSize$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |110|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetSize$0$anon0_correct)))))
inline$AtomicVCGetSize$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCGetElem_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 first_r) first_tid) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |111|
)) (=> (and (and (not (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1))))) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 first_r) first_i))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |112|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElem$0$anon0_correct)))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1))))) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 first_r) first_i))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |113|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElem$0$anon0_correct)))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@0 first_r) first_i))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |114|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElem$0$anon0_correct)))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@2 first_r) first_i))) (= shadow.Lock shadow.Lock)) (and (and (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@2 first_r) first_i))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 first_r) first_i)) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |115|
)) (=> (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicVCGetElem$0$anon0_correct)))))
inline$AtomicVCGetElem$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@0 first_r) first_i))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |116|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetElem$0$anon0_correct))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i))))) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 first_r) first_i))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |117|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetElem$0$anon0_correct))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1))))) (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@1 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |118|
)) (=> (and (ValidTid first_tid) (= (select sx.R first_x) SHARED)) (=> (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElemShared$0$anon0_correct)))))
inline$AtomicVCGetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1))))) (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@1 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |119|
)) (=> (and (ValidTid first_tid) (= (select sx.R first_x) SHARED)) (=> (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElemShared$0$anon0_correct)))))
inline$AtomicVCGetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@0 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |120|
)) (=> (and (ValidTid first_tid) (= (select sx.R first_x) SHARED)) (=> (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElemShared$0$anon0_correct)))))
inline$AtomicVCGetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@2 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock)) (and (and (and (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@2 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |121|
)) (=> (and (and (ValidTid first_tid) (= (select sx.R first_x) SHARED)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicVCGetElemShared$0$anon0_correct)))))
inline$AtomicVCGetElemShared$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i))))) (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@1 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |122|
)) (ValidTid first_tid)) (=> (and (and (and (= (select sx.R first_x) SHARED) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetElemShared$0$anon0_correct))))
inline$AtomicVCGetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCSetElemShared_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (= (select sx.R first_x) SHARED)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |123|
)) (=> (and (and (not (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (= (select sx.R first_x) SHARED))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |124|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCGetSize)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetSize$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@@0 second_r))) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@1 second_r))) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetSize$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetSize$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |125|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |126|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@1 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |127|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select sx.R first_x) SHARED) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$1$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (store (select shadow.VC@1 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@2 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@2 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$1$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$1$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |128|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (= (select sx.R first_x) SHARED))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct)))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_r (store (select shadow.VC@1 second_r) second_i second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_r (VCArraySetLen (select shadow.VC@2 second_r) (q@max (VCArrayLen (select shadow.VC@2 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |129|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (= (select sx.R first_x) SHARED))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct)))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r VC.bottom) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_r VC.bottom) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store (store shadow.VC@@0 second_r VC.bottom) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_r VC.bottom) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_r VC.bottom) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_r VC.bottom) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |130|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (= (select sx.R first_x) SHARED))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct)))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
))) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |131|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (and (= (select sx.R first_x) SHARED) (not (is-ShadowableVar second_v2))) (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)))) (= shadow.VC@4 (store (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@3 (store shadow.VC@1 second_v1@@0 (select shadow.VC@1 second_v2))) (=> (and (= shadow.VC@4 shadow.VC@3) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@1 second_v1@@0)) (VCArrayLen (select shadow.VC@1 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1)))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |132|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select sx.R first_x) SHARED)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@1 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 11) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |133|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 12) 11)))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)))) (= shadow.VC@2 (store (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@2 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@1 second_v1@@0)) (VCArrayLen (select shadow.VC@1 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |134|
)) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (= (select sx.R first_x) SHARED) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 10) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |135|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 11) 10)))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_v (VCArraySetLen (select shadow.VC@1 second_v) (q@max (VCArrayLen (select shadow.VC@1 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_v (store (select shadow.VC@2 second_v) second_i (EpochInc (select (select shadow.VC@2 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |136|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (and (= (select sx.R first_x) SHARED) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@1 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 8) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |137|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (=> (and (and (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 9) 8)))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x))) (+ first_tid 1)))))) (= sx.R sx.R))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar first_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar first_x))) (+ first_tid 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |138|
)) (=> (and (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (= (select sx.R first_x) SHARED) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCSetElem_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (= (select shadow.Lock@0 first_r) first_tid) (ValidTid first_tid)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |139|
)) (=> (and (and (not (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (VCArraySetLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r)) (+ first_i 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |140|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCGetSize)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetSize$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@@0 second_r))) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (VCArraySetLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r)) (+ first_i 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@1 second_r))) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetSize$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetSize$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |141|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (VCArraySetLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r)) (+ first_i 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |142|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (VCArraySetLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r)) (+ first_i 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@1 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |143|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_r (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_r) first_i first_e)) first_r (VCArraySetLen (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_r (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_r (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_r) first_i first_e)) first_r)) (+ first_i 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (store (select shadow.VC@1 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@2 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@2 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |144|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct)))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_r (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_r) first_i first_e)) first_r (VCArraySetLen (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_r (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_r (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_r) first_i first_e)) first_r)) (+ first_i 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$1$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_r (store (select shadow.VC@1 second_r) second_i second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_r (VCArraySetLen (select shadow.VC@2 second_r) (q@max (VCArrayLen (select shadow.VC@2 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$1$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$1$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |145|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct)))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r VC.bottom) first_r (store (select (store shadow.VC@@0 second_r VC.bottom) first_r) first_i first_e)) first_r (VCArraySetLen (select (store (store shadow.VC@@0 second_r VC.bottom) first_r (store (select (store shadow.VC@@0 second_r VC.bottom) first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_r VC.bottom) first_r (store (select (store shadow.VC@@0 second_r VC.bottom) first_r) first_i first_e)) first_r)) (+ first_i 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |146|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct)))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
))) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (VCArraySetLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r)) (+ first_i 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |147|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (not (is-ShadowableVar second_v2))) (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)))) (= shadow.VC@4 (store (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r) first_i first_e)) first_r (VCArraySetLen (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r) first_i first_e)) first_r)) (+ first_i 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r) first_i first_e)) first_r (VCArraySetLen (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r) first_i first_e)) first_r)) (+ first_i 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@3 (store shadow.VC@1 second_v1@@0 (select shadow.VC@1 second_v2))) (=> (and (= shadow.VC@4 shadow.VC@3) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@1 second_v1@@0)) (VCArrayLen (select shadow.VC@1 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1)))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |148|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVCSetElem$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@1 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 11) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |149|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 12) 11)))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)))) (= shadow.VC@2 (store (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r) first_i first_e)) first_r (VCArraySetLen (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r) first_i first_e)) first_r)) (+ first_i 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@2 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@1 second_v1@@0)) (VCArrayLen (select shadow.VC@1 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |150|
)) (=> (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVCSetElem$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 10) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |151|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 11) 10)))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_r (store (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_r) first_i first_e)) first_r (VCArraySetLen (select (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_r (store (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_r (store (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_r) first_i first_e)) first_r)) (+ first_i 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_v (VCArraySetLen (select shadow.VC@1 second_v) (q@max (VCArrayLen (select shadow.VC@1 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_v (store (select shadow.VC@2 second_v) second_i (EpochInc (select (select shadow.VC@2 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |152|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVCSetElem$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@1 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 8) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |153|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (=> (and (and (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 9) 8)))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (VCArraySetLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (q@max (VCArrayLen (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r)) (+ first_i 1)))))) (= sx.R sx.R))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (VCArraySetLen (select shadow.VC@0 first_r) (q@max (VCArrayLen (select shadow.VC@0 first_r)) (+ first_i 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |154|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCInit_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (= (select shadow.Lock@0 first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |155|
)) (=> (and (and (not (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |156|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCGetSize)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetSize$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@@0 second_r))) (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@0 second_r))) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetSize$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetSize$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |157|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@0 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |158|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@0 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |159|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (ValidTid first_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_r VC.bottom)) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@1 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@1 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |160|
)) (= (select shadow.Lock first_r) first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_r VC.bottom)) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) second_i second_e))) (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r (VCArraySetLen (select shadow.VC@1 second_r) (q@max (VCArrayLen (select shadow.VC@1 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |161|
)) (= (select shadow.Lock first_r) first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r VC.bottom) first_r VC.bottom)) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$1$anon0_correct  (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$1$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$1$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |162|
)) (= (select shadow.Lock first_r) first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
))) (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@0 second_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Leq$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |163|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (ValidTid first_tid) (not (is-ShadowableVar second_v2))) (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)))) (= shadow.VC@3 (store (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_r VC.bottom))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@3 (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r VC.bottom)) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@2 (store shadow.VC@0 second_v1@@0 (select shadow.VC@0 second_v2))) (=> (and (= shadow.VC@3 shadow.VC@2) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@1 second_v1@@0)) (= (VCArrayLen (select shadow.VC@1 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@0 second_v1@@0)) (VCArrayLen (select shadow.VC@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@1 (store shadow.VC@0 second_v1@@0 (select shadow.VC@1 second_v1@@0)))) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |164|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVCInit$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 11) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |165|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)))) (= shadow.VC@1 (store (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_r VC.bottom))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@1 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@1 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@0 second_v1@@0)) (VCArrayLen (select shadow.VC@0 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@0 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@1 (store shadow.VC@0 second_v1@@0 (select shadow.VC@1 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |166|
)) (=> (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVCInit$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 10) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |167|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 11) 10)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_r VC.bottom)) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 second_v (VCArraySetLen (select shadow.VC@0 second_v) (q@max (VCArrayLen (select shadow.VC@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@2 (store shadow.VC@1 second_v (store (select shadow.VC@1 second_v) second_i (EpochInc (select (select shadow.VC@1 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |168|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVCInit$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 8) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |169|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (=> (and (and (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom))) (= sx.R sx.R))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r VC.bottom)) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |170|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Leq_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (= (select shadow.Lock@0 first_v2) first_tid)) (= (select shadow.Lock@0 first_v1) first_tid)) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |171|
)) (=> (and (and (not (and (and (and (and (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1))))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (EpochLeq (VCArrayGet (select shadow.VC@1 first_v1) first_j) (VCArrayGet (select shadow.VC@1 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |172|
)) (=> (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1))))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (EpochLeq (VCArrayGet (select shadow.VC@1 first_v1) first_j) (VCArrayGet (select shadow.VC@1 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |173|
)) (=> (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (EpochLeq (VCArrayGet (select shadow.VC@0 first_v1) first_j) (VCArrayGet (select shadow.VC@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |174|
)) (=> (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (EpochLeq (VCArrayGet (select shadow.VC@2 first_v1) first_j) (VCArrayGet (select shadow.VC@2 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock)) (and (and (and (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j@@0 Int) ) (!  (=> (and (<= 0 first_j@@0) (f first_j@@0)) (EpochLeq (VCArrayGet (select shadow.VC@2 first_v1) first_j@@0) (VCArrayGet (select shadow.VC@2 first_v2) first_j@@0)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j@@0))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |175|
)) (=> (and (and (and (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid))) (and (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))))) inline$AtomicVC.Leq$0$anon0_correct))))
inline$AtomicVC.Leq$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (EpochLeq (VCArrayGet (select shadow.VC@0 first_v1) first_j) (VCArrayGet (select shadow.VC@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |176|
)) (not (is-ShadowableVar first_v2))) (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))))) inline$AtomicVC.Leq$0$anon0_correct)))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i))))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (EpochLeq (VCArrayGet (select shadow.VC@1 first_v1) first_j) (VCArrayGet (select shadow.VC@1 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |177|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock@0 first_v2) first_tid)) (= (select shadow.Lock@0 first_v1) first_tid)) (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |178|
)) (=> (and (and (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (VCArrayLen (select shadow.VC@2 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@2 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid))) (= shadow.Lock shadow.Lock)) (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@2 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |179|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2)))) (=> (and (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (ValidTid second_tid)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (VCArrayLen (select shadow.VC@2 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@2 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 second_r) second_i))) (= shadow.Lock shadow.Lock)) (and (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@2 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |180|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2)))) (=> (and (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (VCArrayLen (select shadow.VC@2 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@2 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar second_x)) second_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@2 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |181|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2)))) (=> (and (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (ValidTid second_tid) (= (select sx.R second_x) SHARED)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@4 first_v1)) (= (VCArrayLen (select shadow.VC@4 first_v1)) (q@max (VCArrayLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v1)) (VCArrayLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@4 first_v1) first_j) (VCArrayGet (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@4 (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v1 (select shadow.VC@4 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@4 (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v1 (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v2))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar second_x) (store (select shadow.VC@2 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@4 (store shadow.VC@3 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@3 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@3 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |182|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (select sx.R second_x) SHARED)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v1)) (VCRepOk (select shadow.VC@1 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |183|
)) (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@4 first_v1)) (= (VCArrayLen (select shadow.VC@4 first_v1)) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v1)) (VCArrayLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@4 first_v1) first_j) (VCArrayGet (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@4 (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v1 (select shadow.VC@4 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v1 (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v2))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@3 (store shadow.VC@2 second_r (store (select shadow.VC@2 second_r) second_i second_e))) (=> (and (= shadow.VC@4 (store shadow.VC@3 second_r (VCArraySetLen (select shadow.VC@3 second_r) (q@max (VCArrayLen (select shadow.VC@3 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |184|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v1)) (VCRepOk (select shadow.VC@1 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |185|
)) (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@3 first_v1)) (= (VCArrayLen (select shadow.VC@3 first_v1)) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r VC.bottom) first_v1)) (VCArrayLen (select (store shadow.VC@@0 second_r VC.bottom) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@3 first_v1) first_j) (VCArrayGet (select (store shadow.VC@@0 second_r VC.bottom) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@3 (store (store shadow.VC@@0 second_r VC.bottom) first_v1 (select shadow.VC@3 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@3 (store (store shadow.VC@@0 second_r VC.bottom) first_v1 (select (store shadow.VC@@0 second_r VC.bottom) first_v2))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@3 (store shadow.VC@2 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |186|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (= (select shadow.Lock second_r) second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (ValidTid second_tid)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (VCRepOk (select shadow.VC@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |187|
)) (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (VCArrayLen (select shadow.VC@2 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@2 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j@@0 Int) ) (!  (=> (and (<= 0 second_j@@0) (f second_j@@0)) (EpochLeq (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j@@0) (VCArrayGet (select shadow.VC@@0 second_v2) second_j@@0)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j@@0))
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@2 second_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |188|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2)))) (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)))) (and (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (not (is-ShadowableVar second_v2)) (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (= (select shadow.Lock second_v2) second_tid)) (and (= (select shadow.Lock second_v1@@0) second_tid) (ValidTid second_tid))))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 7) (let ((inline$AtomicVC.Copy$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (or (or (and (and (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)))) (VCRepOk (select shadow.VC@5 first_v1))) (= (VCArrayLen (select shadow.VC@5 first_v1)) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v1)) (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@5 first_v1) first_j) (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@5 (store (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v1 (select shadow.VC@5 first_v1)))) (= shadow.Lock shadow.Lock)) (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j@@0 Int) ) (!  (=> (<= 0 second_j@@0) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0) second_j@@0) (VCArrayGet (select shadow.VC@@0 second_v2) second_j@@0)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)))) (= shadow.VC@5 (store (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v1 (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v2)))) (= shadow.Lock shadow.Lock))) (and (and (and (and (VCRepOk (select shadow.VC@5 first_v1)) (= (VCArrayLen (select shadow.VC@5 first_v1)) (q@max (VCArrayLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1)) (VCArrayLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2))))) (forall ((first_j@@0 Int) ) (!  (=> (<= 0 first_j@@0) (= (VCArrayGet (select shadow.VC@5 first_v1) first_j@@0) (VCArrayGet (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) first_j@@0)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@5 (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1 (select shadow.VC@5 first_v1)))) (= shadow.Lock shadow.Lock))) (and (= shadow.VC@5 (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1 (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$1$anon3_Else_correct  (=> (= shadow.VC@4 (store shadow.VC@2 second_v1@@0 (select shadow.VC@2 second_v2))) (=> (and (= shadow.VC@5 shadow.VC@4) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$1$Return_correct))))
(let ((inline$AtomicVC.Copy$1$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@3 second_v1@@0)) (= (VCArrayLen (select shadow.VC@3 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@2 second_v1@@0)) (VCArrayLen (select shadow.VC@2 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$1$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$1$j) (= (VCArrayGet (select shadow.VC@3 second_v1@@0) inline$AtomicVC.Copy$1$j) (VCArrayGet (select shadow.VC@2 second_v2) inline$AtomicVC.Copy$1$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@3 (store shadow.VC@2 second_v1@@0 (select shadow.VC@3 second_v1@@0)))) (and (= shadow.VC@5 shadow.VC@3) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$1$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (and (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (= shadow.VC@2 shadow.VC@1)) (and (=> (= (ControlFlow 0 6) 3) inline$AtomicVC.Copy$1$anon3_Then_correct) (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$1$anon3_Else_correct)))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= shadow.VC@2 shadow.VC@0))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$1$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$1$anon3_Else_correct))))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |189|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v1@@0))))) (and (and (and (VCRepOk (select shadow.VC@@0 second_v2)) (not (is-ShadowableVar second_v2))) (and (not (is-ShadowableVar second_v1@@0)) (= (select shadow.Lock second_v2) second_tid))) (and (and (= (select shadow.Lock second_v1@@0) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_v1@@0 second_v2)) (ValidTid second_tid))))) (and (=> (= (ControlFlow 0 7) 5) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 7) 6) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct)))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 13) (let ((inline$AtomicVC.Copy$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@2 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@2 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@2 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@2 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 12) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 11) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |190|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v1@@0))))) (and (and (and (VCRepOk (select shadow.VC@@0 second_v2)) (not (is-ShadowableVar second_v2))) (and (not (is-ShadowableVar second_v1@@0)) (= (select shadow.Lock second_v2) second_tid))) (and (and (= (select shadow.Lock second_v1@@0) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_v1@@0 second_v2)) (ValidTid second_tid))))) (and (=> (= (ControlFlow 0 13) 11) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 13) 12) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (VCRepOk (select shadow.VC@2 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |191|
)) (=> (and (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid))) (VCRepOk (select shadow.VC@@0 second_v1@@0))) (=> (and (and (and (VCRepOk (select shadow.VC@@0 second_v2)) (not (is-ShadowableVar second_v2))) (and (not (is-ShadowableVar second_v1@@0)) (= (select shadow.Lock second_v2) second_tid))) (and (and (= (select shadow.Lock second_v1@@0) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_v1@@0 second_v2)) (ValidTid second_tid)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)))) (VCRepOk (select shadow.VC@3 first_v1))) (= (VCArrayLen (select shadow.VC@3 first_v1)) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1)) (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@3 first_v1) first_j) (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@3 (store (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1 (select shadow.VC@3 first_v1)))) (= shadow.Lock shadow.Lock)) (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j@@0 Int) ) (!  (=> (<= 0 second_j@@0) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) second_j@@0) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j@@0) (VCArrayGet (select shadow.VC@@0 second_v2) second_j@@0))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)))) (= shadow.VC@3 (store (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2)))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@3 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@3 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@2 second_v1@@0)) (VCArrayLen (select shadow.VC@2 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@3 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@2 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@3 (store shadow.VC@2 second_v1@@0 (select shadow.VC@3 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |192|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid)))) (and (and (and (VCRepOk (select shadow.VC@@0 second_v2)) (not (is-ShadowableVar second_v2))) (and (not (is-ShadowableVar second_v1@@0)) (= (select shadow.Lock second_v2) second_tid))) (and (and (= (select shadow.Lock second_v1@@0) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_v1@@0 second_v2)) (ValidTid second_tid))))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVC.Copy$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@2 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@2 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 11) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 10) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |193|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v1@@0))))) (and (and (and (VCRepOk (select shadow.VC@@0 second_v2)) (not (is-ShadowableVar second_v2))) (and (not (is-ShadowableVar second_v1@@0)) (= (select shadow.Lock second_v2) second_tid))) (and (and (= (select shadow.Lock second_v1@@0) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_v1@@0 second_v2)) (ValidTid second_tid))))) (and (=> (= (ControlFlow 0 12) 10) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 12) 11) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (VCRepOk (select shadow.VC@4 first_v1)) (= (VCArrayLen (select shadow.VC@4 first_v1)) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v1)) (VCArrayLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@4 first_v1) first_j) (VCArrayGet (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v1 (select shadow.VC@4 first_v1)))) (= shadow.Lock shadow.Lock)) (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v1 (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v2))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@3 (store shadow.VC@2 second_v (VCArraySetLen (select shadow.VC@2 second_v) (q@max (VCArrayLen (select shadow.VC@2 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@4 (store shadow.VC@3 second_v (store (select shadow.VC@3 second_v) second_i (EpochInc (select (select shadow.VC@3 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |194|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2)))) (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)))) (and (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (VCRepOk (select shadow.VC@@0 second_v)) (>= second_i 0))) (and (and (not (is-ShadowableVar second_v)) (= (select shadow.Lock second_v) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (ValidTid second_tid))))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 10) (let ((inline$AtomicVC.Copy$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@2 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@2 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 9) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 8) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |195|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v1@@0))))) (and (and (and (VCRepOk (select shadow.VC@@0 second_v2)) (not (is-ShadowableVar second_v2))) (and (not (is-ShadowableVar second_v1@@0)) (= (select shadow.Lock second_v2) second_tid))) (and (and (= (select shadow.Lock second_v1@@0) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_v1@@0 second_v2)) (ValidTid second_tid))))) (and (=> (= (ControlFlow 0 10) 8) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 10) 9) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v1)) (VCRepOk (select shadow.VC@1 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |196|
)) (=> (and (and (and (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid))) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (VCRepOk (select shadow.VC@2 first_v1))) (= (VCArrayLen (select shadow.VC@2 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@2 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@2 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |197|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock@0 first_v2) first_tid)) (= (select shadow.Lock@0 first_v1) first_tid)) (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |198|
)) (=> (and (and (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@0 first_v1) first_j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |199|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@0 first_v1) first_j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 second_r) second_i))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@0 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |200|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@0 first_v1) first_j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar second_x)) second_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@0 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |201|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (VCArrayLen (select shadow.VC@2 first_v1)) (q@max (VCArrayLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v1)) (VCArrayLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@2 first_v1) first_j) (EpochMax (VCArrayGet (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v1) first_j) (VCArrayGet (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@2 (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v1 (select shadow.VC@2 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@1 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@1 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |202|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |203|
)) (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (VCArrayLen (select shadow.VC@2 first_v1)) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v1)) (VCArrayLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@2 first_v1) first_j) (EpochMax (VCArrayGet (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v1) first_j) (VCArrayGet (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v1 (select shadow.VC@2 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) second_i second_e))) (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r (VCArraySetLen (select shadow.VC@1 second_r) (q@max (VCArrayLen (select shadow.VC@1 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |204|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |205|
)) (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v1)) (= (VCArrayLen (select shadow.VC@1 first_v1)) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r VC.bottom) first_v1)) (VCArrayLen (select (store shadow.VC@@0 second_r VC.bottom) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@1 first_v1) first_j) (EpochMax (VCArrayGet (select (store shadow.VC@@0 second_r VC.bottom) first_v1) first_j) (VCArrayGet (select (store shadow.VC@@0 second_r VC.bottom) first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@1 (store (store shadow.VC@@0 second_r VC.bottom) first_v1 (select shadow.VC@1 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |206|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |207|
)) (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@0 first_v1) first_j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@0 second_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |208|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (ValidTid first_tid) (not (is-ShadowableVar second_v2))) (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)))) (VCRepOk (select shadow.VC@3 first_v1))) (= (VCArrayLen (select shadow.VC@3 first_v1)) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1)) (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@3 first_v1) first_j) (EpochMax (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1) first_j) (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@3 (store (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1 (select shadow.VC@3 first_v1)))) (= shadow.Lock shadow.Lock)) (and (and (and (and (VCRepOk (select shadow.VC@3 first_v1)) (= (VCArrayLen (select shadow.VC@3 first_v1)) (q@max (VCArrayLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1)) (VCArrayLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2))))) (forall ((first_j@@0 Int) ) (!  (=> (<= 0 first_j@@0) (= (VCArrayGet (select shadow.VC@3 first_v1) first_j@@0) (EpochMax (VCArrayGet (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1) first_j@@0) (VCArrayGet (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) first_j@@0))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@3 (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1 (select shadow.VC@3 first_v1)))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@2 (store shadow.VC@0 second_v1@@0 (select shadow.VC@0 second_v2))) (=> (and (= shadow.VC@3 shadow.VC@2) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@1 second_v1@@0)) (= (VCArrayLen (select shadow.VC@1 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@0 second_v1@@0)) (VCArrayLen (select shadow.VC@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@1 (store shadow.VC@0 second_v1@@0 (select shadow.VC@1 second_v1@@0)))) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (and (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |209|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (=> (and (and (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVC.Join$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 11) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |210|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11))))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |211|
)) (=> (and (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid))) (VCRepOk (select shadow.VC@@0 second_v1@@0))) (=> (and (and (and (VCRepOk (select shadow.VC@@0 second_v2)) (not (is-ShadowableVar second_v2))) (and (not (is-ShadowableVar second_v1@@0)) (= (select shadow.Lock second_v2) second_tid))) (and (and (= (select shadow.Lock second_v1@@0) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_v1@@0 second_v2)) (ValidTid second_tid)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)))) (VCRepOk (select shadow.VC@1 first_v1))) (= (VCArrayLen (select shadow.VC@1 first_v1)) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1)) (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@1 first_v1) first_j) (EpochMax (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1) first_j) (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@1 (store (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1 (select shadow.VC@1 first_v1)))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$1$anon0_correct  (=> (VCRepOk (select shadow.VC@1 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@1 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@0 second_v1@@0)) (VCArrayLen (select shadow.VC@0 second_v2)))) (forall ((inline$AtomicVC.Join$1$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$1$j) (= (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$1$j) (EpochMax (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$1$j) (VCArrayGet (select shadow.VC@0 second_v2) inline$AtomicVC.Join$1$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@1 (store shadow.VC@0 second_v1@@0 (select shadow.VC@1 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$1$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Join$1$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |212|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVC.Join$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 10) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |213|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 11) 10))))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (VCArrayLen (select shadow.VC@2 first_v1)) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v1)) (VCArrayLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@2 first_v1) first_j) (EpochMax (VCArrayGet (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v1) first_j) (VCArrayGet (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@2 (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v1 (select shadow.VC@2 first_v1)))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 second_v (VCArraySetLen (select shadow.VC@0 second_v) (q@max (VCArrayLen (select shadow.VC@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@2 (store shadow.VC@1 second_v (store (select shadow.VC@1 second_v) second_i (EpochInc (select (select shadow.VC@1 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |214|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVC.Join$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 8) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |215|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8))))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |216|
)) (=> (and (and (and (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (ValidTid first_tid))) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (VCRepOk (select shadow.VC@0 first_v1))) (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (VCArrayGet (select shadow.VC@0 first_v1) first_j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) first_j) (VCArrayGet (select shadow.VC@@0 first_v2) first_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid)))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 first_v1)) (q@max (VCArrayLen (select shadow.VC@@0 first_v1)) (VCArrayLen (select shadow.VC@@0 first_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |217|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock@0 first_v) first_tid)) (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |218|
)) (=> (and (and (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v (store (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i)))))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |219|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v (store (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i)))))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |220|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (ValidTid first_tid) (= (select shadow.Lock second_r) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v (store (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@1 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |221|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (ValidTid first_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v)) (+ first_i 1)))) first_v (store (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))) first_v)) (+ first_i 1)))) first_v) first_i))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (store (select shadow.VC@1 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@2 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@2 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |222|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (=> (and (and (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |223|
)) (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v)) (+ first_i 1)))) first_v (store (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))) first_v)) (+ first_i 1)))) first_v) first_i))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_r (store (select shadow.VC@1 second_r) second_i second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_r (VCArraySetLen (select shadow.VC@2 second_r) (q@max (VCArrayLen (select shadow.VC@2 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |224|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (=> (and (and (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |225|
)) (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r VC.bottom) first_v (VCArraySetLen (select (store shadow.VC@@0 second_r VC.bottom) first_v) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r VC.bottom) first_v)) (+ first_i 1)))) first_v (store (select (store (store shadow.VC@@0 second_r VC.bottom) first_v (VCArraySetLen (select (store shadow.VC@@0 second_r VC.bottom) first_v) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r VC.bottom) first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store (store shadow.VC@@0 second_r VC.bottom) first_v (VCArraySetLen (select (store shadow.VC@@0 second_r VC.bottom) first_v) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r VC.bottom) first_v)) (+ first_i 1)))) first_v) first_i))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |226|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (=> (and (and (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |227|
)) (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))) (=> (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
))) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v (store (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |228|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (ValidTid first_tid) (not (is-ShadowableVar second_v2))) (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)))) (= shadow.VC@4 (store (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v (VCArraySetLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v)) (+ first_i 1)))) first_v (store (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v (VCArraySetLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v (VCArraySetLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v)) (+ first_i 1)))) first_v) first_i)))))) (= shadow.Lock shadow.Lock)) (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v (VCArraySetLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (q@max (VCArrayLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v)) (+ first_i 1)))) first_v (store (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v (VCArraySetLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (q@max (VCArrayLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v (VCArraySetLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (q@max (VCArrayLen (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v)) (+ first_i 1)))) first_v) first_i))))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@3 (store shadow.VC@1 second_v1@@0 (select shadow.VC@1 second_v2))) (=> (and (= shadow.VC@4 shadow.VC@3) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@1 second_v1@@0)) (VCArrayLen (select shadow.VC@1 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i)))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |229|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVC.Inc$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@1 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 11) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |230|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11))))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |231|
)) (=> (and (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid))) (VCRepOk (select shadow.VC@@0 second_v1@@0))) (=> (and (and (and (VCRepOk (select shadow.VC@@0 second_v2)) (not (is-ShadowableVar second_v2))) (and (not (is-ShadowableVar second_v1@@0)) (= (select shadow.Lock second_v2) second_tid))) (and (and (= (select shadow.Lock second_v1@@0) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_v1@@0 second_v2)) (ValidTid second_tid)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (= (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) second_j) (EpochMax (VCArrayGet (select shadow.VC@@0 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)))) (= shadow.VC@2 (store (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v (VCArraySetLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v)) (+ first_i 1)))) first_v (store (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v (VCArraySetLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v (VCArraySetLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (q@max (VCArrayLen (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v)) (+ first_i 1)))) first_v) first_i)))))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@2 second_v1@@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@1 second_v1@@0)) (VCArrayLen (select shadow.VC@1 second_v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |232|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))))) inline$AtomicVC.Inc$0$anon0_correct)))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVC.Inc$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 10) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |233|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 11) 10))))) inline$AtomicVC.Inc$0$anon0_correct)))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v)) (+ first_i 1)))) first_v (store (select (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v (VCArraySetLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v) (q@max (VCArrayLen (select (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))) first_v)) (+ first_i 1)))) first_v) first_i))))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$1$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_v (VCArraySetLen (select shadow.VC@1 second_v) (q@max (VCArrayLen (select shadow.VC@1 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_v (store (select shadow.VC@2 second_v) second_i (EpochInc (select (select shadow.VC@2 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$1$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$1$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |234|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVC.Inc$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@1 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 8) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |235|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (ValidTid first_tid) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |236|
)) (=> (and (and (and (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (ValidTid first_tid))) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v (store (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i (EpochInc (select (select (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1)))) first_v) first_i))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (VCArraySetLen (select shadow.VC@@0 first_v) (q@max (VCArrayLen (select shadow.VC@@0 first_v)) (+ first_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (EpochInc (select (select shadow.VC@0 first_v) first_i))))) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |237|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (=> (and (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun first_uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicReleaseJoinLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid first_uid) nil))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid first_uid) nil)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |238|
)) (= (select shadow.Lock (ShadowableTid first_uid)) first_tid)) (and (not (= first_tid first_uid)) (ValidTid first_uid))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |239|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_uid () Int)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicReleaseJoinLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid))) (ValidTid first_uid)) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |240|
)) (=> (and (and (not (and (and (and (= (select shadow.Lock (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid))) (ValidTid first_uid)) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |241|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |242|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |243|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |244|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |245|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |246|
)) (=> (and (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |247|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |248|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |249|
)) (not (is-ShadowableVar first_v2))) (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 11) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |250|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11)))) inline$AtomicReleaseJoinLock$0$anon0_correct))))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |251|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (=> (and (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicChooseThreadToJoin_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (not (= first_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED)) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (= (select (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil)) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) first_tid))) (= thread.HasJoined@0 (store thread.HasJoined first_tid inline$AtomicChooseThreadToJoin$0$uid@0 true))) (= thread.State thread.State))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= first_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) first_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined first_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |252|
)) (=> (and (and (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
inline$AtomicChooseThreadToJoin$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |253|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |254|
)) (=> (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |255|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |256|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |257|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |258|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 5) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |259|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (= (select sx.R first_x) SHARED))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 6) 5))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 5) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |260|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 6) 5))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 5) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |261|
)) (= (select shadow.Lock first_r) first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 6) 5))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 8) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |262|
)) (=> (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 9) 8))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 11) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |263|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_v1 first_v2)) (ValidTid first_tid))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 12) 11))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 8) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |264|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (=> (and (and (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 9) 8))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (= shadow.VC@@0 shadow.VC@@0))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |265|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) UNUSED) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |266|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicAllocTid_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) UNUSED) (= (select shadow.Lock@0 (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)) (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |267|
)) (=> (and (and (not (and (forall ((first_t@@0 Int) ) (!  (=> (= (select thread.State first_t@@0) UNUSED) (= (select shadow.Lock (ShadowableTid first_t@@0)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)) (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |268|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |269|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |270|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |271|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |272|
)) (= (select shadow.Lock first_r) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (VCArraySetLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (q@max (VCArrayLen (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x))) (+ second_tid 1)))))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (VCArraySetLen (select shadow.VC@0 (ShadowableVar second_x)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar second_x))) (+ second_tid 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |273|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) UNUSED) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid))) (and (and (= (select shadow.Lock (ShadowableVar second_x)) second_tid) (ValidTid second_tid)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 5) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |274|
)) (=> (and (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (= (select sx.R first_x) SHARED) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 6) 5))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (VCArraySetLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (q@max (VCArrayLen (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r)) (+ second_i 1)))))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (VCArraySetLen (select shadow.VC@0 second_r) (q@max (VCArrayLen (select shadow.VC@0 second_r)) (+ second_i 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |275|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) UNUSED) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (ValidTid second_tid)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 5) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |276|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 6) 5))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |277|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) UNUSED) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 5) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |278|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 6) 5))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 8) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |279|
)) (not (is-ShadowableVar first_v2))) (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 9) 8))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (VCArrayLen (select shadow.VC@2 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (VCArrayGet (select shadow.VC@2 second_v1@@0) second_j) (VCArrayGet (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (not (= first_tid inline$AtomicAllocTid$0$uid@0))) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@2 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@2 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (VCArrayLen (select shadow.VC@0 second_v1@@0)) (q@max (VCArrayLen (select shadow.VC@@0 second_v1@@0)) (VCArrayLen (select shadow.VC@@0 second_v2))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW)) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |280|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) UNUSED) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicAllocTid$0$anon0_correct)))))
inline$AtomicAllocTid$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 11) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |281|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 12) 11))) inline$AtomicAllocTid$0$anon0_correct))))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED)) (ValidTid inline$AtomicAllocTid$0$uid@0)) (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@1 (store (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v (store (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i (EpochInc (select (select (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1)))) second_v) second_i)))))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (VCArraySetLen (select shadow.VC@@0 second_v) (q@max (VCArrayLen (select shadow.VC@@0 second_v)) (+ second_i 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (EpochInc (select (select shadow.VC@0 second_v) second_i))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |282|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) UNUSED) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (and (and (= (select thread.State first_tid) RUNNING) (ValidTid first_tid)) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 8) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |283|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (=> (and (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (ValidTid first_tid) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) UNUSED) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) RUNNING) (ValidTid second_tid)) (= (ControlFlow 0 9) 8))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun first_uid () Int)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicStartThread_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= thread.State@0 (store thread.State first_uid RUNNING)) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid first_uid) first_uid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State first_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid first_uid) first_uid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |284|
)) (=> (and (and (and (= (select thread.State first_uid) NEW) (= (select shadow.Lock (ShadowableTid first_uid)) first_tid)) (and (not (= first_tid first_uid)) (ValidTid first_uid))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |285|
)) (=> (and (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun first_uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicStartThread_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (= (select thread.State first_uid) NEW) (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid)) (not (= first_tid first_uid))) (ValidTid first_uid)) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |286|
)) (=> (and (and (not (and (and (and (and (= (select thread.State first_uid) NEW) (= (select shadow.Lock (ShadowableTid first_uid)) first_tid)) (not (= first_tid first_uid))) (ValidTid first_uid)) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |287|
)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |288|
)) (=> (and (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |289|
)) (=> (and (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |290|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |291|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 5) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |292|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (ValidTid first_tid) (= (select sx.R first_x) SHARED)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 5) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |293|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 5) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |294|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 8) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |295|
)) (=> (and (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 11) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |296|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2)))) (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)))) (and (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11))))) inline$AtomicStartThread$0$anon0_correct)))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 8) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |297|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (and (= (select thread.State second_uid) NEW) (= (select shadow.Lock (ShadowableTid second_uid)) second_tid))) (and (and (not (= second_tid second_uid)) (ValidTid second_uid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicChooseLockToAcquire_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |298|
)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |299|
)) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |300|
)) (=> (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |301|
)) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |302|
)) (=> (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |303|
)) (=> (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |304|
)) (=> (and (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |305|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select sx.R first_x) SHARED)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |306|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (ValidTid first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |307|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 8) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |308|
)) (=> (and (and (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (= (select shadow.Lock first_v2) first_tid))) (and (and (= (select shadow.Lock first_v1) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 11) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |309|
)) (VCRepOk (select shadow.VC@@0 first_v1))) (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2)))) (=> (and (and (and (not (is-ShadowableVar first_v1)) (= (select shadow.Lock first_v2) first_tid)) (and (= (select shadow.Lock first_v1) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_v1 first_v2)) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11)))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 8) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |310|
)) (=> (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (and (not (is-ShadowableVar first_v)) (= (select shadow.Lock first_v) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (ValidTid first_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToRelease$0$l@0 () T@Lock)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicChooseLockToRelease_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select shadow.Lock@0 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) first_tid) (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (and (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) first_tid) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))
(let ((inline$AtomicChooseLockToRelease$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |311|
)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToRelease$0$anon0_correct))))
inline$AtomicChooseLockToRelease$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun first_l () T@Lock)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicReleaseChosenLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableLock first_l) nil))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock first_l) nil)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |312|
)) (= (select shadow.Lock (ShadowableLock first_l)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |313|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_l () T@Lock)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicReleaseChosenLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableLock first_l)) first_tid) (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |314|
)) (=> (and (and (not (and (= (select shadow.Lock (ShadowableLock first_l)) first_tid) (ValidTid first_tid))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |315|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |316|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |317|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |318|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |319|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |320|
)) (=> (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (ValidTid first_tid)) (=> (and (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (ValidTid first_tid))) (=> (=> true (ValidTid first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |321|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (ValidTid first_tid)) (=> (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |322|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |323|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 11) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |324|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 12) 11)))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (ValidTid first_tid)))))))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |325|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (ValidTid first_tid) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (ValidTid second_tid) (= (ControlFlow 0 9) 8)))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v1 () T@Shadowable)
(declare-fun v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun tid@@3 () Int)
(set-info :boogie-vc-id Civl_CooperationChecker_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((init_correct  (=> (= (ControlFlow 0 2) (- 0 1)) true)))
(let ((PreconditionGeneratedEntry_correct  (=> (and (VCRepOk (select shadow.VC@@0 v1)) (VCRepOk (select shadow.VC@@0 v2))) (=> (and (and (and (not (is-ShadowableVar v2)) (not (is-ShadowableVar v1))) (and (= (select shadow.Lock v2) tid@@3) (= (select shadow.Lock v1) tid@@3))) (and (and (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3) (not (= v1 v2))) (and (ValidTid tid@@3) (= (ControlFlow 0 3) 2)))) init_correct))))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun res@0 () Bool)
(declare-fun v1 () T@Shadowable)
(declare-fun v2 () T@Shadowable)
(declare-fun res () Bool)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun inline$AtomicVCGetSize$1$i@1 () Int)
(declare-fun i@0 () Int)
(declare-fun inline$AtomicVCGetElem$0$e@2 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@2 () T@Epoch)
(declare-fun i@1 () Int)
(set-info :boogie-vc-id Civl_VC.Leq_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 50) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 22) (- 0 24)) (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (= res@0 (forall ((j@@2 Int) ) (!  (=> (and (<= 0 j@@2) (f j@@2)) (EpochLeq (VCArrayGet (select shadow.VC@0 v1) j@@2) (VCArrayGet (select shadow.VC@0 v2) j@@2)))
 :qid |verifiedftdefinebpl.326:19|
 :skolemid |15|
 :pattern ( (f j@@2))
))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (= res@0 (forall ((j@@3 Int) ) (!  (=> (and (<= 0 j@@3) (f j@@3)) (EpochLeq (VCArrayGet (select shadow.VC@0 v1) j@@3) (VCArrayGet (select shadow.VC@0 v2) j@@3)))
 :qid |verifiedftdefinebpl.326:19|
 :skolemid |15|
 :pattern ( (f j@@3))
))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 22) (- 0 23)) (=> false (and (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (= res@0 res)))) (=> (=> false (and (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (= res@0 res))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (= res@0 (forall ((j@@4 Int) ) (!  (=> (and (<= 0 j@@4) (f j@@4)) (EpochLeq (VCArrayGet (select shadow.VC@0 v1) j@@4) (VCArrayGet (select shadow.VC@0 v2) j@@4)))
 :qid |verifiedftdefinebpl.326:19|
 :skolemid |15|
 :pattern ( (f j@@4))
))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (= res@0 res) false)))) (= (ControlFlow 0 22) (- 0 21))) Civl_ok@0)))))))
(let ((anon5_LoopDone_@2_Civl_ReturnChecker_correct  (=> (and (= res@0 true) (= (ControlFlow 0 36) 22)) Civl_ReturnChecker_correct)))
(let ((anon6_Then_@2_Civl_ReturnChecker_correct  (=> (and (= res@0 false) (= (ControlFlow 0 25) 22)) Civl_ReturnChecker_correct)))
(let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 18) (- 0 20)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 18) (- 0 19)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 18) (- 0 17)) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= (ControlFlow 0 16) (- 0 15))) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 13) (- 0 14)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 13) (- 0 12)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 10) (- 0 11)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 10) (- 0 9)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 5) (- 0 7)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 5) (- 0 6)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0) (=> (= (ControlFlow 0 5) (- 0 4)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((anon5_LoopDone_correct  (=> (<= (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) i@0) (and (and (and (and (and (and (=> (= (ControlFlow 0 37) 36) anon5_LoopDone_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 37) 5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 37) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 37) 10) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 37) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 37) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)) (=> (= (ControlFlow 0 37) 18) GeneratedUnifiedExit_correct)))))
(let ((anon6_Then_correct  (=> (not (EpochLeq inline$AtomicVCGetElem$0$e@2 inline$AtomicVCGetElem$1$e@2)) (and (=> (= (ControlFlow 0 26) (- 0 27)) (f i@0)) (=> (f i@0) (and (and (and (and (and (and (=> (= (ControlFlow 0 26) 25) anon6_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 26) 5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 26) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 26) 10) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 26) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 26) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)) (=> (= (ControlFlow 0 26) 18) GeneratedUnifiedExit_correct)))))))
(let ((anon6_Else_correct  (=> (and (EpochLeq inline$AtomicVCGetElem$0$e@2 inline$AtomicVCGetElem$1$e@2) (= i@1 (+ i@0 1))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (<= 0 i@1)) (=> (<= 0 i@1) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((j@@5 Int) ) (!  (=> (and (and (<= 0 j@@5) (< j@@5 i@1)) (f j@@5)) (EpochLeq (VCArrayGet (select shadow.VC@0 v1) j@@5) (VCArrayGet (select shadow.VC@0 v2) j@@5)))
 :qid |verifiedftdefinebpl.345:35|
 :skolemid |16|
 :pattern ( (f j@@5))
))))))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@2 (VCArrayGet (select shadow.VC@0 v2) i@0)) (and (=> (= (ControlFlow 0 28) 26) anon6_Then_correct) (=> (= (ControlFlow 0 28) 2) anon6_Else_correct)))))
(let ((anon5_LoopBody$1_correct  (and (=> (= (ControlFlow 0 29) (- 0 31)) (= (select shadow.Lock@0 v2) tid@@3)) (=> (= (select shadow.Lock@0 v2) tid@@3) (and (=> (= (ControlFlow 0 29) (- 0 30)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 29) 28) inline$AtomicVCGetElem$1$anon0_correct)))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@2 (VCArrayGet (select shadow.VC@0 v1) i@0)) (= (ControlFlow 0 32) 29)) anon5_LoopBody$1_correct)))
(let ((anon5_LoopBody_correct  (=> (< i@0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (and (=> (= (ControlFlow 0 33) (- 0 35)) (= (select shadow.Lock@0 v1) tid@@3)) (=> (= (select shadow.Lock@0 v1) tid@@3) (and (=> (= (ControlFlow 0 33) (- 0 34)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 33) 32) inline$AtomicVCGetElem$0$anon0_correct))))))))
(let ((anon5_LoopHead_correct  (=> (and (<= 0 i@0) (forall ((j@@6 Int) ) (!  (=> (and (and (<= 0 j@@6) (< j@@6 i@0)) (f j@@6)) (EpochLeq (VCArrayGet (select shadow.VC@0 v1) j@@6) (VCArrayGet (select shadow.VC@0 v2) j@@6)))
 :qid |verifiedftdefinebpl.345:35|
 :skolemid |16|
 :pattern ( (f j@@6))
))) (and (=> (= (ControlFlow 0 38) 37) anon5_LoopDone_correct) (=> (= (ControlFlow 0 38) 33) anon5_LoopBody_correct)))))
(let ((anon0$2_correct  (and (=> (= (ControlFlow 0 39) (- 0 41)) (<= 0 0)) (=> (<= 0 0) (and (=> (= (ControlFlow 0 39) (- 0 40)) (forall ((j@@7 Int) ) (!  (=> (and (and (<= 0 j@@7) (< j@@7 0)) (f j@@7)) (EpochLeq (VCArrayGet (select shadow.VC@0 v1) j@@7) (VCArrayGet (select shadow.VC@0 v2) j@@7)))
 :qid |verifiedftdefinebpl.345:35|
 :skolemid |16|
 :pattern ( (f j@@7))
))) (=> (forall ((j@@8 Int) ) (!  (=> (and (and (<= 0 j@@8) (< j@@8 0)) (f j@@8)) (EpochLeq (VCArrayGet (select shadow.VC@0 v1) j@@8) (VCArrayGet (select shadow.VC@0 v2) j@@8)))
 :qid |verifiedftdefinebpl.345:35|
 :skolemid |16|
 :pattern ( (f j@@8))
)) (=> (= (ControlFlow 0 39) 38) anon5_LoopHead_correct)))))))
(let ((inline$AtomicVCGetSize$1$anon0_correct  (=> (and (= inline$AtomicVCGetSize$1$i@1 (VCArrayLen (select shadow.VC@0 v1))) (= (ControlFlow 0 42) 39)) anon0$2_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 43) (- 0 45)) (= (select shadow.Lock@0 v1) tid@@3)) (=> (= (select shadow.Lock@0 v1) tid@@3) (and (=> (= (ControlFlow 0 43) (- 0 44)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 43) 42) inline$AtomicVCGetSize$1$anon0_correct)))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@0 v1))) (= (ControlFlow 0 46) 43)) anon0$1_correct)))
(let ((anon0_correct  (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (and (and (and (and (not (is-ShadowableVar v2)) (=> (is-ShadowableVar v1) (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED))) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (= (select shadow.Lock@0 v2) tid@@3)) (= (select shadow.Lock@0 v1) tid@@3)) (ValidTid tid@@3)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 47) (- 0 49)) (= (select shadow.Lock@0 v1) tid@@3)) (=> (= (select shadow.Lock@0 v1) tid@@3) (and (=> (= (ControlFlow 0 47) (- 0 48)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 47) 46) inline$AtomicVCGetSize$0$anon0_correct))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (FTRepOk shadow.VC@@0 sx.W sx.R) (ValidTid tid@@3)) (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 50) 47))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun v2 () T@Shadowable)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun inline$AtomicVCGetSize$1$i@1 () Int)
(declare-fun i@0 () Int)
(declare-fun i@1 () Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCGetElem$0$e@2 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_VC.Copy_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 62) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 37) (- 0 40)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 37) (- 0 39)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0) (and (=> (= (ControlFlow 0 37) (- 0 38)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 v1)) (not (= s@@1 v1))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@4 s@@1)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 v1)) (not (= s@@2 v1))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@4 s@@2)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 37) (- 0 36)) (FTRepOk shadow.VC@4 sx.W@0 sx.R@0))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (and (= shadow.VC@4 shadow.VC@1) (= (ControlFlow 0 41) 37)) GeneratedUnifiedExit_correct)))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= (ControlFlow 0 35) (- 0 34))) (FTRepOk shadow.VC@1 sx.W@0 sx.R@0))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 32) (- 0 33)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 32) (- 0 31)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 29) (- 0 30)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 29) (- 0 28)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@0 shadow.VC@1 sx.W@0 sx.R@0))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 24) (- 0 26)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 24) (- 0 25)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0) (=> (= (ControlFlow 0 24) (- 0 23)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (VCArrayLen (select shadow.VC@1 v1)) (q@max (VCArrayLen (select shadow.VC@0 v1)) (VCArrayLen (select shadow.VC@0 v2))))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (VCArrayGet (select shadow.VC@1 v1) j@@2) (VCArrayGet (select shadow.VC@0 v2) j@@2)))
 :qid |verifiedftdefinebpl.380:24|
 :skolemid |17|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@0 v2))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (VCArrayLen (select shadow.VC@1 v1)) (q@max (VCArrayLen (select shadow.VC@0 v1)) (VCArrayLen (select shadow.VC@0 v2))))) (forall ((j@@3 Int) ) (!  (=> (<= 0 j@@3) (= (VCArrayGet (select shadow.VC@1 v1) j@@3) (VCArrayGet (select shadow.VC@0 v2) j@@3)))
 :qid |verifiedftdefinebpl.380:24|
 :skolemid |17|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@0 v2))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (and (=> (= (ControlFlow 0 20) (- 0 21)) (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (VCArrayLen (select shadow.VC@1 v1)) (q@max (VCArrayLen (select shadow.VC@0 v1)) (VCArrayLen (select shadow.VC@0 v2))))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (VCArrayGet (select shadow.VC@1 v1) j@@4) (VCArrayGet (select shadow.VC@0 v2) j@@4)))
 :qid |verifiedftdefinebpl.380:24|
 :skolemid |17|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@0 v2))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) false))) (= (ControlFlow 0 20) (- 0 19))) Civl_ok@0)))))))
(let ((anon2_LoopDone_correct  (=> (<= (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) i@0) (and (and (and (and (and (and (=> (= (ControlFlow 0 42) 20) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 42) 41) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 42) 24) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 42) 27) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 42) 29) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 42) 32) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 42) 35) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)))))
(let ((anon2_LoopBody$2_correct  (=> (= i@1 (+ i@0 1)) (and (=> (= (ControlFlow 0 2) (- 0 9)) (forall ((s@@3 T@Shadowable) ) (!  (=> (not (= s@@3 v1)) (= (select shadow.VC@3 s@@3) (select shadow.VC@0 s@@3)))
 :qid |verifiedftdefinebpl.407:35|
 :skolemid |18|
))) (=> (forall ((s@@4 T@Shadowable) ) (!  (=> (not (= s@@4 v1)) (= (select shadow.VC@3 s@@4) (select shadow.VC@0 s@@4)))
 :qid |verifiedftdefinebpl.407:35|
 :skolemid |18|
)) (and (=> (= (ControlFlow 0 2) (- 0 8)) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@5) tid@@3) (= (select shadow.Lock@0 s@@5) tid@@3))
 :qid |verifiedftdefinebpl.408:35|
 :skolemid |19|
))) (=> (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@6) tid@@3) (= (select shadow.Lock@0 s@@6) tid@@3))
 :qid |verifiedftdefinebpl.408:35|
 :skolemid |19|
)) (and (=> (= (ControlFlow 0 2) (- 0 7)) (VCRepOk (select shadow.VC@3 v1))) (=> (VCRepOk (select shadow.VC@3 v1)) (and (=> (= (ControlFlow 0 2) (- 0 6)) (>= i@1 0)) (=> (>= i@1 0) (and (=> (= (ControlFlow 0 2) (- 0 5)) (<= i@1 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1))) (=> (<= i@1 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (= (VCArrayLen (select shadow.VC@3 v1)) (q@max inline$AtomicVCGetSize$0$i@1 i@1))) (=> (= (VCArrayLen (select shadow.VC@3 v1)) (q@max inline$AtomicVCGetSize$0$i@1 i@1)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (forall ((j@@5 Int) ) (!  (=> (and (<= 0 j@@5) (< j@@5 i@1)) (= (VCArrayGet (select shadow.VC@3 v1) j@@5) (VCArrayGet (select shadow.VC@3 v2) j@@5)))
 :qid |verifiedftdefinebpl.413:35|
 :skolemid |20|
))) (=> (forall ((j@@6 Int) ) (!  (=> (and (<= 0 j@@6) (< j@@6 i@1)) (= (VCArrayGet (select shadow.VC@3 v1) j@@6) (VCArrayGet (select shadow.VC@3 v2) j@@6)))
 :qid |verifiedftdefinebpl.413:35|
 :skolemid |20|
)) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((j@@7 Int) ) (!  (=> (<= (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) j@@7) (= (VCArrayGet (select shadow.VC@3 v1) j@@7) (VCArrayGet (select shadow.VC@3 v2) j@@7)))
 :qid |verifiedftdefinebpl.414:35|
 :skolemid |21|
))))))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 v1 (store (select shadow.VC@1 v1) i@0 inline$AtomicVCGetElem$0$e@2))) (=> (and (= shadow.VC@3 (store shadow.VC@2 v1 (VCArraySetLen (select shadow.VC@2 v1) (q@max (VCArrayLen (select shadow.VC@2 v1)) (+ i@0 1))))) (= (ControlFlow 0 10) 2)) anon2_LoopBody$2_correct))))
(let ((anon2_LoopBody$1_correct  (and (=> (= (ControlFlow 0 11) (- 0 14)) (= (select shadow.Lock@0 v1) tid@@3)) (=> (= (select shadow.Lock@0 v1) tid@@3) (and (=> (= (ControlFlow 0 11) (- 0 13)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 11) (- 0 12)) (=> (is-ShadowableVar v1) (not (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED)))) (=> (=> (is-ShadowableVar v1) (not (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED))) (=> (= (ControlFlow 0 11) 10) inline$AtomicVCSetElem$0$anon0_correct)))))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@2 (VCArrayGet (select shadow.VC@1 v2) i@0)) (= (ControlFlow 0 15) 11)) anon2_LoopBody$1_correct)))
(let ((anon2_LoopBody_correct  (=> (< i@0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (and (=> (= (ControlFlow 0 16) (- 0 18)) (= (select shadow.Lock@0 v2) tid@@3)) (=> (= (select shadow.Lock@0 v2) tid@@3) (and (=> (= (ControlFlow 0 16) (- 0 17)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 16) 15) inline$AtomicVCGetElem$0$anon0_correct))))))))
(let ((anon2_LoopHead_correct  (=> (and (and (and (forall ((s@@7 T@Shadowable) ) (!  (=> (not (= s@@7 v1)) (= (select shadow.VC@1 s@@7) (select shadow.VC@0 s@@7)))
 :qid |verifiedftdefinebpl.407:35|
 :skolemid |18|
)) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@8) tid@@3) (= (select shadow.Lock@0 s@@8) tid@@3))
 :qid |verifiedftdefinebpl.408:35|
 :skolemid |19|
))) (and (VCRepOk (select shadow.VC@1 v1)) (>= i@0 0))) (and (and (<= i@0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (= (VCArrayLen (select shadow.VC@1 v1)) (q@max inline$AtomicVCGetSize$0$i@1 i@0))) (and (forall ((j@@8 Int) ) (!  (=> (and (<= 0 j@@8) (< j@@8 i@0)) (= (VCArrayGet (select shadow.VC@1 v1) j@@8) (VCArrayGet (select shadow.VC@1 v2) j@@8)))
 :qid |verifiedftdefinebpl.413:35|
 :skolemid |20|
)) (forall ((j@@9 Int) ) (!  (=> (<= (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) j@@9) (= (VCArrayGet (select shadow.VC@1 v1) j@@9) (VCArrayGet (select shadow.VC@1 v2) j@@9)))
 :qid |verifiedftdefinebpl.414:35|
 :skolemid |21|
))))) (and (=> (= (ControlFlow 0 43) 42) anon2_LoopDone_correct) (=> (= (ControlFlow 0 43) 16) anon2_LoopBody_correct)))))
(let ((anon0$3_correct  (and (=> (= (ControlFlow 0 44) (- 0 52)) (forall ((s@@9 T@Shadowable) ) (!  (=> (not (= s@@9 v1)) (= (select shadow.VC@0 s@@9) (select shadow.VC@0 s@@9)))
 :qid |verifiedftdefinebpl.407:35|
 :skolemid |18|
))) (=> (forall ((s@@10 T@Shadowable) ) (!  (=> (not (= s@@10 v1)) (= (select shadow.VC@0 s@@10) (select shadow.VC@0 s@@10)))
 :qid |verifiedftdefinebpl.407:35|
 :skolemid |18|
)) (and (=> (= (ControlFlow 0 44) (- 0 51)) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@11) tid@@3) (= (select shadow.Lock@0 s@@11) tid@@3))
 :qid |verifiedftdefinebpl.408:35|
 :skolemid |19|
))) (=> (forall ((s@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@12) tid@@3) (= (select shadow.Lock@0 s@@12) tid@@3))
 :qid |verifiedftdefinebpl.408:35|
 :skolemid |19|
)) (and (=> (= (ControlFlow 0 44) (- 0 50)) (VCRepOk (select shadow.VC@0 v1))) (=> (VCRepOk (select shadow.VC@0 v1)) (and (=> (= (ControlFlow 0 44) (- 0 49)) (>= 0 0)) (=> (>= 0 0) (and (=> (= (ControlFlow 0 44) (- 0 48)) (<= 0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1))) (=> (<= 0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (and (=> (= (ControlFlow 0 44) (- 0 47)) (= (VCArrayLen (select shadow.VC@0 v1)) (q@max inline$AtomicVCGetSize$0$i@1 0))) (=> (= (VCArrayLen (select shadow.VC@0 v1)) (q@max inline$AtomicVCGetSize$0$i@1 0)) (and (=> (= (ControlFlow 0 44) (- 0 46)) (forall ((j@@10 Int) ) (!  (=> (and (<= 0 j@@10) (< j@@10 0)) (= (VCArrayGet (select shadow.VC@0 v1) j@@10) (VCArrayGet (select shadow.VC@0 v2) j@@10)))
 :qid |verifiedftdefinebpl.413:35|
 :skolemid |20|
))) (=> (forall ((j@@11 Int) ) (!  (=> (and (<= 0 j@@11) (< j@@11 0)) (= (VCArrayGet (select shadow.VC@0 v1) j@@11) (VCArrayGet (select shadow.VC@0 v2) j@@11)))
 :qid |verifiedftdefinebpl.413:35|
 :skolemid |20|
)) (and (=> (= (ControlFlow 0 44) (- 0 45)) (forall ((j@@12 Int) ) (!  (=> (<= (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) j@@12) (= (VCArrayGet (select shadow.VC@0 v1) j@@12) (VCArrayGet (select shadow.VC@0 v2) j@@12)))
 :qid |verifiedftdefinebpl.414:35|
 :skolemid |21|
))) (=> (forall ((j@@13 Int) ) (!  (=> (<= (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) j@@13) (= (VCArrayGet (select shadow.VC@0 v1) j@@13) (VCArrayGet (select shadow.VC@0 v2) j@@13)))
 :qid |verifiedftdefinebpl.414:35|
 :skolemid |21|
)) (=> (= (ControlFlow 0 44) 43) anon2_LoopHead_correct)))))))))))))))))))
(let ((inline$AtomicVCGetSize$1$anon0_correct  (=> (and (= inline$AtomicVCGetSize$1$i@1 (VCArrayLen (select shadow.VC@0 v2))) (= (ControlFlow 0 53) 44)) anon0$3_correct)))
(let ((anon0$2_correct  (and (=> (= (ControlFlow 0 54) (- 0 56)) (= (select shadow.Lock@0 v2) tid@@3)) (=> (= (select shadow.Lock@0 v2) tid@@3) (and (=> (= (ControlFlow 0 54) (- 0 55)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 54) 53) inline$AtomicVCGetSize$1$anon0_correct)))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@0 v1))) (= (ControlFlow 0 57) 54)) anon0$2_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 58) (- 0 60)) (= (select shadow.Lock@0 v1) tid@@3)) (=> (= (select shadow.Lock@0 v1) tid@@3) (and (=> (= (ControlFlow 0 58) (- 0 59)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 58) 57) inline$AtomicVCGetSize$0$anon0_correct)))))))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 v1)) (VCRepOk (select shadow.VC@0 v2))) (not (is-ShadowableVar v2))) (not (is-ShadowableVar v1))) (= (select shadow.Lock@0 v2) tid@@3)) (= (select shadow.Lock@0 v1) tid@@3)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (not (= v1 v2))) (ValidTid tid@@3)) (and (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= (ControlFlow 0 61) 58))) anon0$1_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 62) 61))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun v2 () T@Shadowable)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun inline$AtomicVCGetSize$1$i@1 () Int)
(declare-fun i@0 () Int)
(declare-fun i@1 () Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@2 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@2 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_VC.Join_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 67) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 42) (- 0 45)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 42) (- 0 44)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0) (and (=> (= (ControlFlow 0 42) (- 0 43)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 v1)) (not (= s@@1 v1))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@4 s@@1)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 v1)) (not (= s@@2 v1))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@4 s@@2)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 42) (- 0 41)) (FTRepOk shadow.VC@4 sx.W@0 sx.R@0))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (and (= shadow.VC@4 shadow.VC@1) (= (ControlFlow 0 46) 42)) GeneratedUnifiedExit_correct)))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= (ControlFlow 0 40) (- 0 39))) (FTRepOk shadow.VC@1 sx.W@0 sx.R@0))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 37) (- 0 38)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 37) (- 0 36)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 34) (- 0 35)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 34) (- 0 33)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@0 shadow.VC@1 sx.W@0 sx.R@0))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 29) (- 0 31)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 29) (- 0 30)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0) (=> (= (ControlFlow 0 29) (- 0 28)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 25) (- 0 27)) (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (VCArrayLen (select shadow.VC@1 v1)) (q@max (VCArrayLen (select shadow.VC@0 v1)) (VCArrayLen (select shadow.VC@0 v2))))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (VCArrayGet (select shadow.VC@1 v1) j@@2) (EpochMax (VCArrayGet (select shadow.VC@0 v1) j@@2) (VCArrayGet (select shadow.VC@0 v2) j@@2))))
 :qid |verifiedftdefinebpl.437:20|
 :skolemid |22|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (VCArrayLen (select shadow.VC@1 v1)) (q@max (VCArrayLen (select shadow.VC@0 v1)) (VCArrayLen (select shadow.VC@0 v2))))) (forall ((j@@3 Int) ) (!  (=> (<= 0 j@@3) (= (VCArrayGet (select shadow.VC@1 v1) j@@3) (EpochMax (VCArrayGet (select shadow.VC@0 v1) j@@3) (VCArrayGet (select shadow.VC@0 v2) j@@3))))
 :qid |verifiedftdefinebpl.437:20|
 :skolemid |22|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 25) (- 0 26)) (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (VCArrayLen (select shadow.VC@1 v1)) (q@max (VCArrayLen (select shadow.VC@0 v1)) (VCArrayLen (select shadow.VC@0 v2))))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (VCArrayGet (select shadow.VC@1 v1) j@@4) (EpochMax (VCArrayGet (select shadow.VC@0 v1) j@@4) (VCArrayGet (select shadow.VC@0 v2) j@@4))))
 :qid |verifiedftdefinebpl.437:20|
 :skolemid |22|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 25) (- 0 24))) Civl_ok@0)))))))
(let ((anon2_LoopDone_correct  (=> (<= (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) i@0) (and (and (and (and (and (and (=> (= (ControlFlow 0 47) 25) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 47) 46) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 47) 29) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 47) 32) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 47) 34) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 47) 37) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 47) 40) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)))))
(let ((anon2_LoopBody$3_correct  (=> (= i@1 (+ i@0 1)) (and (=> (= (ControlFlow 0 2) (- 0 9)) (forall ((s@@3 T@Shadowable) ) (!  (=> (not (= s@@3 v1)) (= (select shadow.VC@3 s@@3) (select shadow.VC@0 s@@3)))
 :qid |verifiedftdefinebpl.461:35|
 :skolemid |23|
))) (=> (forall ((s@@4 T@Shadowable) ) (!  (=> (not (= s@@4 v1)) (= (select shadow.VC@3 s@@4) (select shadow.VC@0 s@@4)))
 :qid |verifiedftdefinebpl.461:35|
 :skolemid |23|
)) (and (=> (= (ControlFlow 0 2) (- 0 8)) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@5) tid@@3) (= (select shadow.Lock@0 s@@5) tid@@3))
 :qid |verifiedftdefinebpl.462:35|
 :skolemid |24|
))) (=> (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@6) tid@@3) (= (select shadow.Lock@0 s@@6) tid@@3))
 :qid |verifiedftdefinebpl.462:35|
 :skolemid |24|
)) (and (=> (= (ControlFlow 0 2) (- 0 7)) (VCRepOk (select shadow.VC@3 v1))) (=> (VCRepOk (select shadow.VC@3 v1)) (and (=> (= (ControlFlow 0 2) (- 0 6)) (>= i@1 0)) (=> (>= i@1 0) (and (=> (= (ControlFlow 0 2) (- 0 5)) (<= i@1 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1))) (=> (<= i@1 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (= (VCArrayLen (select shadow.VC@3 v1)) (q@max inline$AtomicVCGetSize$0$i@1 i@1))) (=> (= (VCArrayLen (select shadow.VC@3 v1)) (q@max inline$AtomicVCGetSize$0$i@1 i@1)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (forall ((j@@5 Int) ) (!  (=> (and (<= 0 j@@5) (<= i@1 j@@5)) (= (VCArrayGet (select shadow.VC@3 v1) j@@5) (VCArrayGet (select shadow.VC@0 v1) j@@5)))
 :qid |verifiedftdefinebpl.467:35|
 :skolemid |25|
))) (=> (forall ((j@@6 Int) ) (!  (=> (and (<= 0 j@@6) (<= i@1 j@@6)) (= (VCArrayGet (select shadow.VC@3 v1) j@@6) (VCArrayGet (select shadow.VC@0 v1) j@@6)))
 :qid |verifiedftdefinebpl.467:35|
 :skolemid |25|
)) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((j@@7 Int) ) (!  (=> (and (<= 0 j@@7) (< j@@7 i@1)) (= (VCArrayGet (select shadow.VC@3 v1) j@@7) (EpochMax (VCArrayGet (select shadow.VC@0 v1) j@@7) (VCArrayGet (select shadow.VC@3 v2) j@@7))))
 :qid |verifiedftdefinebpl.468:35|
 :skolemid |26|
))))))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 v1 (store (select shadow.VC@1 v1) i@0 inline$AtomicVCSetElem$0$e@1))) (=> (and (= shadow.VC@3 (store shadow.VC@2 v1 (VCArraySetLen (select shadow.VC@2 v1) (q@max (VCArrayLen (select shadow.VC@2 v1)) (+ i@0 1))))) (= (ControlFlow 0 10) 2)) anon2_LoopBody$3_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (= inline$AtomicVCSetElem$0$e@1 (EpochMax inline$AtomicVCGetElem$0$e@2 inline$AtomicVCGetElem$1$e@2)) (= (ControlFlow 0 11) 10)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((anon2_LoopBody$2_correct  (and (=> (= (ControlFlow 0 12) (- 0 15)) (= (select shadow.Lock@0 v1) tid@@3)) (=> (= (select shadow.Lock@0 v1) tid@@3) (and (=> (= (ControlFlow 0 12) (- 0 14)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 12) (- 0 13)) (=> (is-ShadowableVar v1) (not (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED)))) (=> (=> (is-ShadowableVar v1) (not (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED))) (=> (= (ControlFlow 0 12) 11) inline$AtomicVCSetElem$0$Entry_correct)))))))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (and (= inline$AtomicVCGetElem$1$e@2 (VCArrayGet (select shadow.VC@1 v2) i@0)) (= (ControlFlow 0 16) 12)) anon2_LoopBody$2_correct)))
(let ((anon2_LoopBody$1_correct  (and (=> (= (ControlFlow 0 17) (- 0 19)) (= (select shadow.Lock@0 v2) tid@@3)) (=> (= (select shadow.Lock@0 v2) tid@@3) (and (=> (= (ControlFlow 0 17) (- 0 18)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 17) 16) inline$AtomicVCGetElem$1$anon0_correct)))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@2 (VCArrayGet (select shadow.VC@1 v1) i@0)) (= (ControlFlow 0 20) 17)) anon2_LoopBody$1_correct)))
(let ((anon2_LoopBody_correct  (=> (< i@0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (and (=> (= (ControlFlow 0 21) (- 0 23)) (= (select shadow.Lock@0 v1) tid@@3)) (=> (= (select shadow.Lock@0 v1) tid@@3) (and (=> (= (ControlFlow 0 21) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 21) 20) inline$AtomicVCGetElem$0$anon0_correct))))))))
(let ((anon2_LoopHead_correct  (=> (and (and (and (forall ((s@@7 T@Shadowable) ) (!  (=> (not (= s@@7 v1)) (= (select shadow.VC@1 s@@7) (select shadow.VC@0 s@@7)))
 :qid |verifiedftdefinebpl.461:35|
 :skolemid |23|
)) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@8) tid@@3) (= (select shadow.Lock@0 s@@8) tid@@3))
 :qid |verifiedftdefinebpl.462:35|
 :skolemid |24|
))) (and (VCRepOk (select shadow.VC@1 v1)) (>= i@0 0))) (and (and (<= i@0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (= (VCArrayLen (select shadow.VC@1 v1)) (q@max inline$AtomicVCGetSize$0$i@1 i@0))) (and (forall ((j@@8 Int) ) (!  (=> (and (<= 0 j@@8) (<= i@0 j@@8)) (= (VCArrayGet (select shadow.VC@1 v1) j@@8) (VCArrayGet (select shadow.VC@0 v1) j@@8)))
 :qid |verifiedftdefinebpl.467:35|
 :skolemid |25|
)) (forall ((j@@9 Int) ) (!  (=> (and (<= 0 j@@9) (< j@@9 i@0)) (= (VCArrayGet (select shadow.VC@1 v1) j@@9) (EpochMax (VCArrayGet (select shadow.VC@0 v1) j@@9) (VCArrayGet (select shadow.VC@1 v2) j@@9))))
 :qid |verifiedftdefinebpl.468:35|
 :skolemid |26|
))))) (and (=> (= (ControlFlow 0 48) 47) anon2_LoopDone_correct) (=> (= (ControlFlow 0 48) 21) anon2_LoopBody_correct)))))
(let ((anon0$3_correct  (and (=> (= (ControlFlow 0 49) (- 0 57)) (forall ((s@@9 T@Shadowable) ) (!  (=> (not (= s@@9 v1)) (= (select shadow.VC@0 s@@9) (select shadow.VC@0 s@@9)))
 :qid |verifiedftdefinebpl.461:35|
 :skolemid |23|
))) (=> (forall ((s@@10 T@Shadowable) ) (!  (=> (not (= s@@10 v1)) (= (select shadow.VC@0 s@@10) (select shadow.VC@0 s@@10)))
 :qid |verifiedftdefinebpl.461:35|
 :skolemid |23|
)) (and (=> (= (ControlFlow 0 49) (- 0 56)) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@11) tid@@3) (= (select shadow.Lock@0 s@@11) tid@@3))
 :qid |verifiedftdefinebpl.462:35|
 :skolemid |24|
))) (=> (forall ((s@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@12) tid@@3) (= (select shadow.Lock@0 s@@12) tid@@3))
 :qid |verifiedftdefinebpl.462:35|
 :skolemid |24|
)) (and (=> (= (ControlFlow 0 49) (- 0 55)) (VCRepOk (select shadow.VC@0 v1))) (=> (VCRepOk (select shadow.VC@0 v1)) (and (=> (= (ControlFlow 0 49) (- 0 54)) (>= 0 0)) (=> (>= 0 0) (and (=> (= (ControlFlow 0 49) (- 0 53)) (<= 0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1))) (=> (<= 0 (q@max inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1)) (and (=> (= (ControlFlow 0 49) (- 0 52)) (= (VCArrayLen (select shadow.VC@0 v1)) (q@max inline$AtomicVCGetSize$0$i@1 0))) (=> (= (VCArrayLen (select shadow.VC@0 v1)) (q@max inline$AtomicVCGetSize$0$i@1 0)) (and (=> (= (ControlFlow 0 49) (- 0 51)) (forall ((j@@10 Int) ) (!  (=> (and (<= 0 j@@10) (<= 0 j@@10)) (= (VCArrayGet (select shadow.VC@0 v1) j@@10) (VCArrayGet (select shadow.VC@0 v1) j@@10)))
 :qid |verifiedftdefinebpl.467:35|
 :skolemid |25|
))) (=> (forall ((j@@11 Int) ) (!  (=> (and (<= 0 j@@11) (<= 0 j@@11)) (= (VCArrayGet (select shadow.VC@0 v1) j@@11) (VCArrayGet (select shadow.VC@0 v1) j@@11)))
 :qid |verifiedftdefinebpl.467:35|
 :skolemid |25|
)) (and (=> (= (ControlFlow 0 49) (- 0 50)) (forall ((j@@12 Int) ) (!  (=> (and (<= 0 j@@12) (< j@@12 0)) (= (VCArrayGet (select shadow.VC@0 v1) j@@12) (EpochMax (VCArrayGet (select shadow.VC@0 v1) j@@12) (VCArrayGet (select shadow.VC@0 v2) j@@12))))
 :qid |verifiedftdefinebpl.468:35|
 :skolemid |26|
))) (=> (forall ((j@@13 Int) ) (!  (=> (and (<= 0 j@@13) (< j@@13 0)) (= (VCArrayGet (select shadow.VC@0 v1) j@@13) (EpochMax (VCArrayGet (select shadow.VC@0 v1) j@@13) (VCArrayGet (select shadow.VC@0 v2) j@@13))))
 :qid |verifiedftdefinebpl.468:35|
 :skolemid |26|
)) (=> (= (ControlFlow 0 49) 48) anon2_LoopHead_correct)))))))))))))))))))
(let ((inline$AtomicVCGetSize$1$anon0_correct  (=> (and (= inline$AtomicVCGetSize$1$i@1 (VCArrayLen (select shadow.VC@0 v2))) (= (ControlFlow 0 58) 49)) anon0$3_correct)))
(let ((anon0$2_correct  (and (=> (= (ControlFlow 0 59) (- 0 61)) (= (select shadow.Lock@0 v2) tid@@3)) (=> (= (select shadow.Lock@0 v2) tid@@3) (and (=> (= (ControlFlow 0 59) (- 0 60)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 59) 58) inline$AtomicVCGetSize$1$anon0_correct)))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@0 v1))) (= (ControlFlow 0 62) 59)) anon0$2_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 63) (- 0 65)) (= (select shadow.Lock@0 v1) tid@@3)) (=> (= (select shadow.Lock@0 v1) tid@@3) (and (=> (= (ControlFlow 0 63) (- 0 64)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 63) 62) inline$AtomicVCGetSize$0$anon0_correct)))))))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 v2)) (not (is-ShadowableVar v2))) (not (is-ShadowableVar v1))) (= (select shadow.Lock@0 v2) tid@@3)) (= (select shadow.Lock@0 v1) tid@@3)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (not (= v1 v2))) (ValidTid tid@@3)) (and (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= (ControlFlow 0 66) 63))) anon0$1_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 67) 66))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun v@@2 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun i@@2 () Int)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$0$e@0 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_VC.Inc_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 33) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 19) (- 0 21)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 v@@2)) (not (= s@@1 v@@2))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@2 s@@1)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 v@@2)) (not (= s@@2 v@@2))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@2 s@@2)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (FTRepOk shadow.VC@2 sx.W@0 sx.R@0))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= (ControlFlow 0 17) (- 0 16))) (FTRepOk shadow.VC@2 sx.W@0 sx.R@0))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@0 shadow.VC@2 sx.W@0 sx.R@0))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 6) (- 0 8)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 6) (- 0 7)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@0) (=> (= (ControlFlow 0 6) (- 0 5)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@2 (store (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2 (store (select (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2) i@@2 (EpochInc (select (select (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2) i@@2))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@2 (store (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2 (store (select (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2) i@@2 (EpochInc (select (select (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2) i@@2))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (= shadow.VC@2 (store (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2 (store (select (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2) i@@2 (EpochInc (select (select (store shadow.VC@0 v@@2 (VCArraySetLen (select shadow.VC@0 v@@2) (q@max (VCArrayLen (select shadow.VC@0 v@@2)) (+ i@@2 1)))) v@@2) i@@2))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (and (= shadow.VC@1 (store shadow.VC@0 v@@2 (store (select shadow.VC@0 v@@2) i@@2 inline$AtomicVCSetElem$0$e@0))) (= shadow.VC@2 (store shadow.VC@1 v@@2 (VCArraySetLen (select shadow.VC@1 v@@2) (q@max (VCArrayLen (select shadow.VC@1 v@@2)) (+ i@@2 1)))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 9) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 11) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (= inline$AtomicVCSetElem$0$e@0 (EpochInc inline$AtomicVCGetElem$0$e@1)) (= (ControlFlow 0 24) 23)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 v@@2) tid@@3)) (=> (= (select shadow.Lock@0 v@@2) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 27)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 26)) (=> (is-ShadowableVar v@@2) (not (= (select sx.R@0 (|x#ShadowableVar| v@@2)) SHARED)))) (=> (=> (is-ShadowableVar v@@2) (not (= (select sx.R@0 (|x#ShadowableVar| v@@2)) SHARED))) (=> (= (ControlFlow 0 25) 24) inline$AtomicVCSetElem$0$Entry_correct)))))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@0 v@@2) i@@2)) (= (ControlFlow 0 29) 25)) anon0$1_correct)))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 v@@2)) (>= i@@2 0)) (not (is-ShadowableVar v@@2))) (= (select shadow.Lock@0 v@@2) tid@@3)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (ValidTid tid@@3)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 30) (- 0 32)) (= (select shadow.Lock@0 v@@2) tid@@3)) (=> (= (select shadow.Lock@0 v@@2) tid@@3) (and (=> (= (ControlFlow 0 30) (- 0 31)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 30) 29) inline$AtomicVCGetElem$0$anon0_correct))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 33) 30))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun uid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v@0 () T@Shadowable)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Fork_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 34) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 23)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 20) (- 0 22)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@4)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@4) (and (=> (= (ControlFlow 0 20) (- 0 21)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableTid uid)))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@4 s@@1)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableTid uid)))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@4 s@@2)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 20) (- 0 19)) (FTRepOk shadow.VC@4 sx.W@4 sx.R@4))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@4 sx.R@2) (=> (and (and (= sx.W@4 sx.W@2) (= shadow.Lock@4 shadow.Lock@2)) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 24) 20))) GeneratedUnifiedExit_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0) (= (ControlFlow 0 14) (- 0 13))) (FTRepOk shadow.VC@3 sx.W@3 sx.R@3))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@3 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 Civl_global_old_shadow.Lock@0 Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (and (=> (= (ControlFlow 0 8) (- 0 9)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 8) (- 0 7)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@3 shadow.VC@3 sx.W@3 sx.R@3))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 3) (- 0 4)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@3)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@3) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@3 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((anon0_0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@2) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@2) (= sx.W@3 sx.W@2)) (and (= sx.R@3 sx.R@2) (= Civl_global_old_shadow.VC@0 shadow.VC@2))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@2) (= Civl_global_old_sx.W@0 sx.W@2)) (and (= Civl_global_old_sx.R@0 sx.R@2) (= Civl_linear_tid_available@3 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 18) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 18) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_0_correct  (=> (= call1formal@Civl_0_v@0 (ShadowableTid tid@@3)) (and (=> (= (ControlFlow 0 25) (- 0 28)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 27)) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 25) (- 0 26)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (ValidTid tid@@3) (=> (and (and (LocksPreserved tid@@3 shadow.Lock@1 shadow.Lock@2) (forall ((s@@3 T@Shadowable) ) (!  (=> (and (and (not (= s@@3 call1formal@Civl_0_v@0)) (not (= s@@3 call1formal@Civl_0_v@0))) (= (select shadow.Lock@1 s@@3) tid@@3)) (= (select shadow.VC@1 s@@3) (select shadow.VC@2 s@@3)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (and (FTRepOk shadow.VC@2 sx.W@2 sx.R@2) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 25) 17) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 25) 24) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 25) 18) anon0_0_@2_Civl_NoninterferenceChecker_correct)))))))))))))
(let ((anon0_1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@1) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@1) (= sx.W@3 sx.W@1)) (and (= sx.R@3 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@3 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@0) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@3 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@3 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_1_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableTid uid)) (= call2formal@Civl_0_v2@0 (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 29) (- 0 32)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 29) (- 0 31)) (FTPreserved tid@@3 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTPreserved tid@@3 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 29) (- 0 30)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (ValidTid tid@@3) (=> (and (and (LocksPreserved tid@@3 shadow.Lock@0 shadow.Lock@1) (forall ((s@@4 T@Shadowable) ) (!  (=> (and (and (not (= s@@4 call1formal@Civl_0_v1@0)) (not (= s@@4 call1formal@Civl_0_v1@0))) (= (select shadow.Lock@0 s@@4) tid@@3)) (= (select shadow.VC@0 s@@4) (select shadow.VC@1 s@@4)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (and (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 29) 25) anon0_0_correct) (=> (= (ControlFlow 0 29) 16) anon0_1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 29) 1) Civl_RefinementChecker_correct)))))))))))))
(let ((anon0_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 33) 29) anon0_1_correct) (=> (= (ControlFlow 0 33) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 33) 1) Civl_RefinementChecker_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 34) 33))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Join_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 29) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 19) (- 0 21)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@3)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@3) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableTid tid@@3)))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@3 s@@1)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableTid tid@@3)))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@3 s@@2)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (FTRepOk shadow.VC@3 sx.W@3 sx.R@3))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@3 sx.R@1) (=> (and (and (= sx.W@3 sx.W@1) (= shadow.Lock@3 shadow.Lock@1)) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 23) 19))) GeneratedUnifiedExit_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0) (= (ControlFlow 0 14) (- 0 13))) (FTRepOk shadow.VC@2 sx.W@2 sx.R@2))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 Civl_global_old_shadow.Lock@0 Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (and (=> (= (ControlFlow 0 8) (- 0 9)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 8) (- 0 7)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@2 shadow.VC@2 sx.W@2 sx.R@2))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 3) (- 0 4)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@2)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@2) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((anon0_0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@2 shadow.VC@1) (=> (and (and (and (= shadow.Lock@2 shadow.Lock@1) (= sx.W@2 sx.W@1)) (and (= sx.R@2 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 17) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 17) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_0_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableTid tid@@3)) (= call2formal@Civl_0_v2@0 (ShadowableTid uid))) (and (=> (= (ControlFlow 0 24) (- 0 27)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 24) (- 0 26)) (FTPreserved tid@@3 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTPreserved tid@@3 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 24) (- 0 25)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (ValidTid tid@@3) (=> (and (and (LocksPreserved tid@@3 shadow.Lock@0 shadow.Lock@1) (forall ((s@@3 T@Shadowable) ) (!  (=> (and (and (not (= s@@3 call1formal@Civl_0_v1@0)) (not (= s@@3 call1formal@Civl_0_v1@0))) (= (select shadow.Lock@0 s@@3) tid@@3)) (= (select shadow.VC@0 s@@3) (select shadow.VC@1 s@@3)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (and (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 24) 16) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 24) 23) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 24) 17) anon0_0_@2_Civl_NoninterferenceChecker_correct)))))))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@2 shadow.VC@0) (=> (and (and (and (= shadow.Lock@2 shadow.Lock@0) (= sx.W@2 sx.W@0)) (and (= sx.R@2 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 28) 24) anon0_0_correct) (=> (= (ControlFlow 0 28) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 28) 1) Civl_RefinementChecker_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 29) 28))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun l () T@Lock)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Acquire_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 29) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 19) (- 0 21)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@3)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@3) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableTid tid@@3)))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@3 s@@1)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableTid tid@@3)))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@3 s@@2)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (FTRepOk shadow.VC@3 sx.W@3 sx.R@3))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@3 sx.R@1) (=> (and (and (= sx.W@3 sx.W@1) (= shadow.Lock@3 shadow.Lock@1)) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 23) 19))) GeneratedUnifiedExit_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0) (= (ControlFlow 0 14) (- 0 13))) (FTRepOk shadow.VC@2 sx.W@2 sx.R@2))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 Civl_global_old_shadow.Lock@0 Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (and (=> (= (ControlFlow 0 8) (- 0 9)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 8) (- 0 7)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@2 shadow.VC@2 sx.W@2 sx.R@2))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 3) (- 0 4)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@2)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@2) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((anon0_0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@2 shadow.VC@1) (=> (and (and (and (= shadow.Lock@2 shadow.Lock@1) (= sx.W@2 sx.W@1)) (and (= sx.R@2 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 17) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 17) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_0_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableTid tid@@3)) (= call2formal@Civl_0_v2@0 (ShadowableLock l))) (and (=> (= (ControlFlow 0 24) (- 0 27)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 24) (- 0 26)) (FTPreserved tid@@3 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTPreserved tid@@3 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 24) (- 0 25)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (ValidTid tid@@3) (=> (and (and (LocksPreserved tid@@3 shadow.Lock@0 shadow.Lock@1) (forall ((s@@3 T@Shadowable) ) (!  (=> (and (and (not (= s@@3 call1formal@Civl_0_v1@0)) (not (= s@@3 call1formal@Civl_0_v1@0))) (= (select shadow.Lock@0 s@@3) tid@@3)) (= (select shadow.VC@0 s@@3) (select shadow.VC@1 s@@3)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (and (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 24) 16) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 24) 23) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 24) 17) anon0_0_@2_Civl_NoninterferenceChecker_correct)))))))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@2 shadow.VC@0) (=> (and (and (and (= shadow.Lock@2 shadow.Lock@0) (= sx.W@2 sx.W@0)) (and (= sx.R@2 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 28) 24) anon0_0_correct) (=> (= (ControlFlow 0 28) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 28) 1) Civl_RefinementChecker_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 29) 28))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun l () T@Lock)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v@0 () T@Shadowable)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Release_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 34) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 23)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 20) (- 0 22)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@4)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@4) (and (=> (= (ControlFlow 0 20) (- 0 21)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableLock l)))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@4 s@@1)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableLock l)))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@4 s@@2)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 20) (- 0 19)) (FTRepOk shadow.VC@4 sx.W@4 sx.R@4))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@4 sx.R@2) (=> (and (and (= sx.W@4 sx.W@2) (= shadow.Lock@4 shadow.Lock@2)) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 24) 20))) GeneratedUnifiedExit_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0) (= (ControlFlow 0 14) (- 0 13))) (FTRepOk shadow.VC@3 sx.W@3 sx.R@3))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@3 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 Civl_global_old_shadow.Lock@0 Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (and (=> (= (ControlFlow 0 8) (- 0 9)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 8) (- 0 7)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@3 shadow.VC@3 sx.W@3 sx.R@3))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 3) (- 0 4)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@3)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@3) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@3 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((anon0_0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@2) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@2) (= sx.W@3 sx.W@2)) (and (= sx.R@3 sx.R@2) (= Civl_global_old_shadow.VC@0 shadow.VC@2))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@2) (= Civl_global_old_sx.W@0 sx.W@2)) (and (= Civl_global_old_sx.R@0 sx.R@2) (= Civl_linear_tid_available@3 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 18) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 18) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_0_correct  (=> (= call1formal@Civl_0_v@0 (ShadowableTid tid@@3)) (and (=> (= (ControlFlow 0 25) (- 0 28)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 27)) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 25) (- 0 26)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (ValidTid tid@@3) (=> (and (and (LocksPreserved tid@@3 shadow.Lock@1 shadow.Lock@2) (forall ((s@@3 T@Shadowable) ) (!  (=> (and (and (not (= s@@3 call1formal@Civl_0_v@0)) (not (= s@@3 call1formal@Civl_0_v@0))) (= (select shadow.Lock@1 s@@3) tid@@3)) (= (select shadow.VC@1 s@@3) (select shadow.VC@2 s@@3)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (and (FTRepOk shadow.VC@2 sx.W@2 sx.R@2) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 25) 17) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 25) 24) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 25) 18) anon0_0_@2_Civl_NoninterferenceChecker_correct)))))))))))))
(let ((anon0_1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@1) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@1) (= sx.W@3 sx.W@1)) (and (= sx.R@3 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@3 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@0) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@3 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@3 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_1_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableLock l)) (= call2formal@Civl_0_v2@0 (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 29) (- 0 32)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 29) (- 0 31)) (FTPreserved tid@@3 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTPreserved tid@@3 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 29) (- 0 30)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (ValidTid tid@@3) (=> (and (and (LocksPreserved tid@@3 shadow.Lock@0 shadow.Lock@1) (forall ((s@@4 T@Shadowable) ) (!  (=> (and (and (not (= s@@4 call1formal@Civl_0_v1@0)) (not (= s@@4 call1formal@Civl_0_v1@0))) (= (select shadow.Lock@0 s@@4) tid@@3)) (= (select shadow.VC@0 s@@4) (select shadow.VC@1 s@@4)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (and (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 29) 25) anon0_0_correct) (=> (= (ControlFlow 0 29) 16) anon0_1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 29) 1) Civl_RefinementChecker_correct)))))))))))))
(let ((anon0_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 33) 29) anon0_1_correct) (=> (= (ControlFlow 0 33) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 33) 1) Civl_RefinementChecker_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 34) 33))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@8 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@11 () (Array T@Shadowable Int))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun sx.W@6 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@7 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@4 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$AtomicVarStateGetWNoLock$0$e@1 () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun x@@3 () T@Var)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@1 () T@Epoch)
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun call10formal@Civl_0_res@0 () Bool)
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun inline$AtomicVCGetElem$1$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$i@0 () Int)
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$i@0 () Int)
(declare-fun call1formal@Civl_1_old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun call2formal@Civl_1_old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun call3formal@Civl_1_old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun call4formal@Civl_1_old.sx.R@0 () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Write_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 73) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (FTRepOk shadow.VC@6 sx.W@8 sx.R@6)) (=> (FTRepOk shadow.VC@6 sx.W@8 sx.R@6) (and (=> (= (ControlFlow 0 20) (- 0 21)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 20) (- 0 19)) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@11 shadow.VC@6 sx.W@8 sx.R@6))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@6 sx.R@4) (=> (and (and (= sx.W@8 sx.W@6) (= shadow.Lock@11 shadow.Lock@9)) (and (= shadow.VC@6 shadow.VC@4) (= (ControlFlow 0 23) 20))) GeneratedUnifiedExit_correct))))
(let ((anon12_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@0) (=> (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@6 sx.W@0)) (and (= sx.R@4 sx.R@0) (= (ControlFlow 0 66) 23))) Civl_UnifiedReturn_correct))))
(let ((anon13_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (= shadow.Lock@9 shadow.Lock@8) (= sx.W@6 sx.W@1)) (and (= sx.R@4 sx.R@1) (= (ControlFlow 0 51) 23))) Civl_UnifiedReturn_correct))))
(let ((anon15_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (= shadow.Lock@9 shadow.Lock@7) (= sx.W@6 sx.W@1)) (and (= sx.R@4 sx.R@1) (= (ControlFlow 0 42) 23))) Civl_UnifiedReturn_correct))))
(let ((anon16_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@2) (=> (and (and (= shadow.Lock@9 shadow.Lock@4) (= sx.W@6 sx.W@2)) (and (= sx.R@4 sx.R@2) (= (ControlFlow 0 30) 23))) Civl_UnifiedReturn_correct))))
(let ((anon11$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@3) (=> (and (and (= shadow.Lock@9 shadow.Lock@6) (= sx.W@6 sx.W@5)) (and (= sx.R@4 sx.R@3) (= (ControlFlow 0 24) 23))) Civl_UnifiedReturn_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@1 Civl_global_old_sx.W@1 Civl_global_old_sx.R@1) (= (ControlFlow 0 14) (- 0 13))) (FTRepOk shadow.VC@5 sx.W@7 sx.R@5))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@4 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@10 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@4 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 Civl_global_old_shadow.Lock@1 Civl_global_old_shadow.VC@1 Civl_global_old_sx.W@1 Civl_global_old_sx.R@1)) (and (=> (= (ControlFlow 0 8) (- 0 9)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 8) (- 0 7)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@10 shadow.VC@5 sx.W@7 sx.R@5))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@4 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@1) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 3) (- 0 4)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@10)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@10) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@5 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((anon12_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@0) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@0) (= sx.W@7 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@4 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 67) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 67) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 67) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 67) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 67) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon12_Then_correct  (=> (= inline$AtomicVarStateGetWNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 68) 66) anon12_Then_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 68) 67) anon12_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 68) 18) Civl_ReturnChecker_correct)))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@1) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@8) (= sx.W@7 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@4 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 52) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 52) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 52) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 52) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 52) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$3$anon0_correct  (=> (= shadow.Lock@8 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 53) 51) anon13_Then$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 53) 52) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 53) 18) Civl_ReturnChecker_correct)))))
(let ((anon13_Then_correct  (=> (and (and (not (EpochLeq inline$AtomicVarStateGetW$0$e@1 inline$AtomicVCGetElem$0$e@1)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 54) 53))) inline$AtomicReleaseVarLock$3$anon0_correct)))
(let ((anon15_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@1) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@7) (= sx.W@7 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@4 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 43) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 43) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 43) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 43) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 43) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$2$anon0_correct  (=> (= shadow.Lock@7 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 44) 42) anon15_Then$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 44) 43) anon15_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 44) 18) Civl_ReturnChecker_correct)))))
(let ((anon15_Then_correct  (=> (and (and (not (EpochLeq inline$AtomicVarStateGetR$0$e@1 inline$AtomicVCGetElem$1$e@1)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 45) 44))) inline$AtomicReleaseVarLock$2$anon0_correct)))
(let ((anon16_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@2) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@4) (= sx.W@7 sx.W@2)) (and (= sx.R@5 sx.R@2) (= Civl_global_old_shadow.VC@1 shadow.VC@2))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@3) (= Civl_global_old_sx.W@1 sx.W@2)) (and (= Civl_global_old_sx.R@1 sx.R@2) (= Civl_linear_tid_available@4 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 31) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 31) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 31) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 31) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 31) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (= shadow.Lock@4 (store shadow.Lock@3 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 32) 30) anon16_Then$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 32) 31) anon16_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 32) 18) Civl_ReturnChecker_correct)))))
(let ((anon16_Then_correct  (=> (and (and (not call10formal@Civl_0_res@0) (= (select shadow.Lock@3 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 33) 32))) inline$AtomicReleaseVarLock$1$anon0_correct)))
(let ((anon11$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@3) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@6) (= sx.W@7 sx.W@5)) (and (= sx.R@5 sx.R@3) (= Civl_global_old_shadow.VC@1 Civl_global_old_shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 Civl_global_old_shadow.Lock@0) (= Civl_global_old_sx.W@1 Civl_global_old_sx.W@0)) (and (= Civl_global_old_sx.R@1 Civl_global_old_sx.R@0) (= Civl_linear_tid_available@4 Civl_linear_tid_available@3)))) (and (and (and (and (=> (= (ControlFlow 0 17) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 17) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (= shadow.Lock@6 (store shadow.Lock@5 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 25) 24) anon11$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 25) 17) anon11$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 25) 18) Civl_ReturnChecker_correct)))))
(let ((anon11_correct  (=> (= (select shadow.Lock@5 (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 26) 25)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((anon15_Else$1_correct  (=> (and (= shadow.VC@3 shadow.VC@1) (= shadow.Lock@5 shadow.Lock@2)) (=> (and (and (and (= sx.W@5 sx.W@4) (= sx.R@3 sx.R@1)) (and (= Civl_global_old_shadow.VC@0 shadow.VC@1) (= Civl_global_old_shadow.Lock@0 shadow.Lock@1))) (and (and (= Civl_global_old_sx.W@0 sx.W@1) (= Civl_global_old_sx.R@0 sx.R@1)) (and (= Civl_linear_tid_available@3 Civl_linear_tid_available@1) (= (ControlFlow 0 39) 26)))) anon11_correct))))
(let ((inline$AtomicVarStateSetW$1$anon0_correct  (=> (and (= sx.W@4 (store sx.W@1 x@@3 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 40) 39)) anon15_Else$1_correct)))
(let ((anon15_Else_correct  (=> (and (and (EpochLeq inline$AtomicVarStateGetR$0$e@1 inline$AtomicVCGetElem$1$e@1) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 41) 40))) inline$AtomicVarStateSetW$1$anon0_correct)))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@1 (VCArrayGet (select shadow.VC@1 inline$AtomicVCGetElem$1$r@0) inline$AtomicVCGetElem$1$i@0)) (and (=> (= (ControlFlow 0 46) 45) anon15_Then_correct) (=> (= (ControlFlow 0 46) 41) anon15_Else_correct)))))
(let ((inline$AtomicVCGetElem$1$Entry_correct  (=> (= inline$AtomicVCGetElem$1$r@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVCGetElem$1$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 47) 46)) inline$AtomicVCGetElem$1$anon0_correct))))
(let ((anon14_Then_correct  (=> (and (and (not (= inline$AtomicVarStateGetR$0$e@1 SHARED)) (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 48) 47))) inline$AtomicVCGetElem$1$Entry_correct)))
(let ((anon16_Else$1_correct  (=> (and (= shadow.VC@3 shadow.VC@2) (= shadow.Lock@5 shadow.Lock@3)) (=> (and (and (and (= sx.W@5 sx.W@3) (= sx.R@3 sx.R@2)) (and (= Civl_global_old_shadow.VC@0 shadow.VC@2) (= Civl_global_old_shadow.Lock@0 shadow.Lock@3))) (and (and (= Civl_global_old_sx.W@0 sx.W@2) (= Civl_global_old_sx.R@0 sx.R@2)) (and (= Civl_linear_tid_available@3 Civl_linear_tid_available@2) (= (ControlFlow 0 27) 26)))) anon11_correct))))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@3 (store sx.W@2 x@@3 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 28) 27)) anon16_Else$1_correct)))
(let ((anon16_Else_correct  (=> (and (and call10formal@Civl_0_res@0 (= (select shadow.Lock@3 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 29) 28))) inline$AtomicVarStateSetW$0$anon0_correct)))
(let ((anon14_Else_0_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableVar x@@3)) (= call2formal@Civl_0_v2@0 (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 34) (- 0 37)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 34) (- 0 36)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 34) (- 0 35)) (FTPreserved tid@@3 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1) (=> (and (and (FTRepOk shadow.VC@2 sx.W@2 sx.R@2) (ValidTid tid@@3)) (and (FTPreserved tid@@3 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@3 shadow.VC@2 sx.W@2 sx.R@2) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 34) 33) anon16_Then_correct) (=> (= (ControlFlow 0 34) 29) anon16_Else_correct))))))))))))
(let ((anon14_Else_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@1) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@2) (= sx.W@7 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@4 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon12_Else_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@0) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@0) (= sx.W@7 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@4 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon14_Else_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 SHARED) (and (and (=> (= (ControlFlow 0 38) 34) anon14_Else_0_correct) (=> (= (ControlFlow 0 38) 16) anon14_Else_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 38) 1) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@1 x@@3)) (and (=> (= (ControlFlow 0 49) 48) anon14_Then_correct) (=> (= (ControlFlow 0 49) 38) anon14_Else_correct)))))
(let ((anon13_Else_correct  (=> (and (and (EpochLeq inline$AtomicVarStateGetW$0$e@1 inline$AtomicVCGetElem$0$e@1) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 50) 49))) inline$AtomicVarStateGetR$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 inline$AtomicVCGetElem$0$r@0) inline$AtomicVCGetElem$0$i@0)) (and (=> (= (ControlFlow 0 55) 54) anon13_Then_correct) (=> (= (ControlFlow 0 55) 50) anon13_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= inline$AtomicVCGetElem$0$r@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVCGetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetW$0$e@1)) (= (ControlFlow 0 56) 55)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((anon2_0$2_correct  (=> (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 57) 56)) inline$AtomicVCGetElem$0$Entry_correct))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@1 x@@3)) (= (ControlFlow 0 58) 57)) anon2_0$2_correct)))
(let ((anon2_0$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 59) 58)) inline$AtomicVarStateGetW$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableVar x@@3)) nil) (=> (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableVar x@@3) tid@@3)) (= (ControlFlow 0 60) 59)) anon2_0$1_correct))))
(let ((anon2_0_correct  (=> (and (and (= call1formal@Civl_1_old.shadow.Lock@0 shadow.Lock) (= call2formal@Civl_1_old.shadow.VC@0 shadow.VC@@0)) (and (= call3formal@Civl_1_old.sx.W@0 sx.W) (= call4formal@Civl_1_old.sx.R@0 sx.R))) (and (=> (= (ControlFlow 0 61) (- 0 64)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 61) (- 0 63)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 61) (- 0 62)) (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (=> (and (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (ValidTid tid@@3)) (=> (and (and (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (ValidTid tid@@3) (= (ControlFlow 0 61) 60))) inline$AtomicAcquireVarLock$0$anon0_correct)))))))))))
(let ((anon12_Else_correct  (=> (not (= inline$AtomicVarStateGetWNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 65) 61) anon2_0_correct) (=> (= (ControlFlow 0 65) 15) anon12_Else_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 65) 1) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVarStateGetWNoLock$0$anon0_correct  (=> (= inline$AtomicVarStateGetWNoLock$0$e@1 (select sx.W@0 x@@3)) (and (=> (= (ControlFlow 0 69) 68) anon12_Then_correct) (=> (= (ControlFlow 0 69) 65) anon12_Else_correct)))))
(let ((anon0$1_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 70) 69)) inline$AtomicVarStateGetWNoLock$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (= (ControlFlow 0 71) 70)) anon0$1_correct)))
(let ((anon0_correct  (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 72) 71))) inline$AtomicThreadStateGetE$0$anon0_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (FTRepOk shadow.VC@@0 sx.W sx.R) (ValidTid tid@@3)) (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 73) 72))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@11 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@10 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$AtomicVarStateGetRNoLock$0$e@1 () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun x@@3 () T@Var)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@1 () T@Epoch)
(declare-fun shadow.VC@7 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$1$r@0 () T@Shadowable)
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCSetElem$0$i@0 () Int)
(declare-fun inline$AtomicVCInit$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$i@0 () Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCGetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$i@0 () Int)
(declare-fun call1formal@Civl_1_old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun call2formal@Civl_1_old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun call3formal@Civl_1_old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun call4formal@Civl_1_old.sx.R@0 () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Read_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 86) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 21)) (FTRepOk shadow.VC@11 sx.W@4 sx.R@6)) (=> (FTRepOk shadow.VC@11 sx.W@4 sx.R@6) (and (=> (= (ControlFlow 0 19) (- 0 20)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 19) (- 0 18)) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@9 shadow.VC@11 sx.W@4 sx.R@6))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@6 sx.R@4) (=> (and (and (= sx.W@4 sx.W@2) (= shadow.Lock@9 shadow.Lock@7)) (and (= shadow.VC@11 shadow.VC@9) (= (ControlFlow 0 22) 19))) GeneratedUnifiedExit_correct))))
(let ((anon13_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (and (= shadow.Lock@7 shadow.Lock@0) (= sx.R@4 sx.R@0)) (and (= sx.W@2 sx.W@0) (= (ControlFlow 0 78) 22))) Civl_UnifiedReturn_correct))))
(let ((anon14_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (and (= shadow.Lock@7 shadow.Lock@0) (= sx.R@4 sx.R@0)) (and (= sx.W@2 sx.W@0) (= (ControlFlow 0 70) 22))) Civl_UnifiedReturn_correct))))
(let ((anon15_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (= shadow.Lock@7 shadow.Lock@6) (= sx.R@4 sx.R@1)) (and (= sx.W@2 sx.W@1) (= (ControlFlow 0 55) 22))) Civl_UnifiedReturn_correct))))
(let ((anon17_Then$2_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (= shadow.Lock@7 shadow.Lock@5) (= sx.R@4 sx.R@3)) (and (= sx.W@2 sx.W@1) (= (ControlFlow 0 43) 22))) Civl_UnifiedReturn_correct))))
(let ((anon17_Else$5_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@8) (=> (and (and (= shadow.Lock@7 shadow.Lock@4) (= sx.R@4 sx.R@2)) (and (= sx.W@2 sx.W@1) (= (ControlFlow 0 28) 22))) Civl_UnifiedReturn_correct))))
(let ((anon16_Else$2_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@3) (=> (and (and (= shadow.Lock@7 shadow.Lock@3) (= sx.R@4 sx.R@1)) (and (= sx.W@2 sx.W@1) (= (ControlFlow 0 23) 22))) Civl_UnifiedReturn_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0) (= (ControlFlow 0 14) (- 0 13))) (FTRepOk shadow.VC@10 sx.W@3 sx.R@5))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@8 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 Civl_global_old_shadow.Lock@0 Civl_global_old_shadow.VC@0 Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (and (=> (= (ControlFlow 0 8) (- 0 9)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 8) (- 0 7)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@8 shadow.VC@10 sx.W@3 sx.R@5))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 3) (- 0 4)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@8)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@8) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@10 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((anon13_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 79) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 79) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 79) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 79) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 79) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon13_Then_correct  (=> (= inline$AtomicVarStateGetRNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 80) 78) anon13_Then_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 80) 79) anon13_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 80) 17) Civl_ReturnChecker_correct)))))
(let ((anon14_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 71) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 71) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 71) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 71) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 71) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon14_Then_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 72) 70) anon14_Then_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 72) 71) anon14_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 72) 17) Civl_ReturnChecker_correct)))))
(let ((anon15_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@1) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@6) (= sx.W@3 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 56) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 56) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 56) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 56) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 56) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$3$anon0_correct  (=> (= shadow.Lock@6 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 57) 55) anon15_Then$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 57) 56) anon15_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 57) 17) Civl_ReturnChecker_correct)))))
(let ((anon15_Then_correct  (=> (and (and (not (EpochLeq inline$AtomicVarStateGetW$0$e@1 inline$AtomicVCGetElem$0$e@1)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 58) 57))) inline$AtomicReleaseVarLock$3$anon0_correct)))
(let ((anon17_Then$2_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@1) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@5) (= sx.W@3 sx.W@1)) (and (= sx.R@5 sx.R@3) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 44) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 44) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 44) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 44) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 44) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$2$anon0_correct  (=> (= shadow.Lock@5 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 45) 43) anon17_Then$2_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 45) 44) anon17_Then$2_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 45) 17) Civl_ReturnChecker_correct)))))
(let ((anon17_Then$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 46) 45)) inline$AtomicReleaseVarLock$2$anon0_correct))))
(let ((inline$AtomicVarStateSetR$1$anon0_correct  (=> (and (= sx.R@3 (store sx.R@1 x@@3 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 47) 46)) anon17_Then$1_correct)))
(let ((anon17_Then_correct  (=> (EpochLeq inline$AtomicVarStateGetR$0$e@1 inline$AtomicVCGetElem$1$e@1) (and (=> (= (ControlFlow 0 48) (- 0 49)) (>= (|tid#epoch| inline$AtomicThreadStateGetE$0$e@1) 0)) (=> (>= (|tid#epoch| inline$AtomicThreadStateGetE$0$e@1) 0) (=> (and (and (not (= (select sx.R@1 x@@3) SHARED)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 48) 47))) inline$AtomicVarStateSetR$1$anon0_correct))))))
(let ((anon17_Else$5_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@8) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@4) (= sx.W@3 sx.W@1)) (and (= sx.R@5 sx.R@2) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 29) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 29) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 29) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 29) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 29) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (= shadow.Lock@4 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 30) 28) anon17_Else$5_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 30) 29) anon17_Else$5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 30) 17) Civl_ReturnChecker_correct)))))
(let ((anon17_Else$4_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 31) 30)) inline$AtomicReleaseVarLock$1$anon0_correct))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@2 (store sx.R@1 x@@3 SHARED)) (= (ControlFlow 0 32) 31)) anon17_Else$4_correct)))
(let ((anon17_Else$3_correct  (=> (and (and (not (= (select sx.R@1 x@@3) SHARED)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 33) 32))) inline$AtomicVarStateSetR$0$anon0_correct)))
(let ((inline$AtomicVCSetElem$1$anon0_correct  (=> (= shadow.VC@7 (store shadow.VC@6 inline$AtomicVCSetElem$1$r@0 (store (select shadow.VC@6 inline$AtomicVCSetElem$1$r@0) tid@@3 inline$AtomicThreadStateGetE$0$e@1))) (=> (and (= shadow.VC@8 (store shadow.VC@7 inline$AtomicVCSetElem$1$r@0 (VCArraySetLen (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0) (q@max (VCArrayLen (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0)) (+ tid@@3 1))))) (= (ControlFlow 0 34) 33)) anon17_Else$3_correct))))
(let ((inline$AtomicVCSetElem$1$Entry_correct  (=> (and (= inline$AtomicVCSetElem$1$r@0 (ShadowableVar x@@3)) (= (ControlFlow 0 35) 34)) inline$AtomicVCSetElem$1$anon0_correct)))
(let ((anon17_Else$2_correct  (=> (and (and (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (ValidTid tid@@3)) (and (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED))) (= (ControlFlow 0 36) 35))) inline$AtomicVCSetElem$1$Entry_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@5 (store shadow.VC@4 inline$AtomicVCSetElem$0$r@0 (store (select shadow.VC@4 inline$AtomicVCSetElem$0$r@0) inline$AtomicVCSetElem$0$i@0 inline$AtomicVarStateGetR$0$e@1))) (=> (and (= shadow.VC@6 (store shadow.VC@5 inline$AtomicVCSetElem$0$r@0 (VCArraySetLen (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0) (q@max (VCArrayLen (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0)) (+ inline$AtomicVCSetElem$0$i@0 1))))) (= (ControlFlow 0 37) 36)) anon17_Else$2_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (= inline$AtomicVCSetElem$0$r@0 (ShadowableVar x@@3)) (=> (and (= inline$AtomicVCSetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 38) 37)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((anon17_Else$1_correct  (=> (and (and (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (ValidTid tid@@3)) (and (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED))) (= (ControlFlow 0 39) 38))) inline$AtomicVCSetElem$0$Entry_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@4 (store shadow.VC@1 inline$AtomicVCInit$0$r@0 VC.bottom)) (= (ControlFlow 0 40) 39)) anon17_Else$1_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (= inline$AtomicVCInit$0$r@0 (ShadowableVar x@@3)) (= (ControlFlow 0 41) 40)) inline$AtomicVCInit$0$anon0_correct)))
(let ((anon17_Else_correct  (=> (not (EpochLeq inline$AtomicVarStateGetR$0$e@1 inline$AtomicVCGetElem$1$e@1)) (=> (and (and (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED)))) (and (ValidTid tid@@3) (= (ControlFlow 0 42) 41))) inline$AtomicVCInit$0$Entry_correct))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@1 (VCArrayGet (select shadow.VC@1 inline$AtomicVCGetElem$1$r@0) inline$AtomicVCGetElem$1$i@0)) (and (=> (= (ControlFlow 0 50) 48) anon17_Then_correct) (=> (= (ControlFlow 0 50) 42) anon17_Else_correct)))))
(let ((inline$AtomicVCGetElem$1$Entry_correct  (=> (= inline$AtomicVCGetElem$1$r@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVCGetElem$1$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 51) 50)) inline$AtomicVCGetElem$1$anon0_correct))))
(let ((anon16_Then_correct  (=> (and (and (not (= inline$AtomicVarStateGetR$0$e@1 SHARED)) (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 52) 51))) inline$AtomicVCGetElem$1$Entry_correct)))
(let ((anon16_Else$2_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@3) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@3) (= sx.W@3 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (= shadow.Lock@3 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 24) 23) anon16_Else$2_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 24) 16) anon16_Else$2_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 24) 17) Civl_ReturnChecker_correct)))))
(let ((anon16_Else$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 25) 24)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar x@@3) (store (select shadow.VC@1 (ShadowableVar x@@3)) tid@@3 inline$AtomicThreadStateGetE$0$e@1))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar x@@3) (VCArraySetLen (select shadow.VC@2 (ShadowableVar x@@3)) (q@max (VCArrayLen (select shadow.VC@2 (ShadowableVar x@@3))) (+ tid@@3 1))))) (= (ControlFlow 0 26) 25)) anon16_Else$1_correct))))
(let ((anon16_Else_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 SHARED) (=> (and (and (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (ValidTid tid@@3)) (and (= (select sx.R@1 x@@3) SHARED) (= (ControlFlow 0 27) 26))) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@1 x@@3)) (and (=> (= (ControlFlow 0 53) 52) anon16_Then_correct) (=> (= (ControlFlow 0 53) 27) anon16_Else_correct)))))
(let ((anon15_Else_correct  (=> (and (and (EpochLeq inline$AtomicVarStateGetW$0$e@1 inline$AtomicVCGetElem$0$e@1) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 54) 53))) inline$AtomicVarStateGetR$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 inline$AtomicVCGetElem$0$r@0) inline$AtomicVCGetElem$0$i@0)) (and (=> (= (ControlFlow 0 59) 58) anon15_Then_correct) (=> (= (ControlFlow 0 59) 54) anon15_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= inline$AtomicVCGetElem$0$r@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVCGetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetW$0$e@1)) (= (ControlFlow 0 60) 59)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((anon5_0$2_correct  (=> (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 61) 60)) inline$AtomicVCGetElem$0$Entry_correct))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@1 x@@3)) (= (ControlFlow 0 62) 61)) anon5_0$2_correct)))
(let ((anon5_0$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 63) 62)) inline$AtomicVarStateGetW$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableVar x@@3)) nil) (=> (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableVar x@@3) tid@@3)) (= (ControlFlow 0 64) 63)) anon5_0$1_correct))))
(let ((anon5_0_correct  (=> (and (and (= call1formal@Civl_1_old.shadow.Lock@0 shadow.Lock) (= call2formal@Civl_1_old.shadow.VC@0 shadow.VC@@0)) (and (= call3formal@Civl_1_old.sx.W@0 sx.W) (= call4formal@Civl_1_old.sx.R@0 sx.R))) (and (=> (= (ControlFlow 0 65) (- 0 68)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 65) (- 0 67)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 65) (- 0 66)) (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (=> (and (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (ValidTid tid@@3)) (=> (and (and (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (ValidTid tid@@3) (= (ControlFlow 0 65) 64))) inline$AtomicAcquireVarLock$0$anon0_correct)))))))))))
(let ((anon5_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon13_Else_correct  (=> (not (= inline$AtomicVarStateGetRNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 77) 65) anon5_0_correct) (=> (= (ControlFlow 0 77) 15) anon5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 77) 1) Civl_RefinementChecker_correct)))))
(let ((anon12_Then$1_correct  (=> (not (= inline$AtomicVarStateGetRNoLock$0$e@1 SHARED)) (and (=> (= (ControlFlow 0 81) 80) anon13_Then_correct) (=> (= (ControlFlow 0 81) 77) anon13_Else_correct)))))
(let ((inline$AtomicVarStateGetRNoLock$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetRNoLock$0$e@1 (select sx.R@0 x@@3)) (= (ControlFlow 0 82) 81)) anon12_Then$1_correct)))
(let ((anon12_Then_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 83) 82)) inline$AtomicVarStateGetRNoLock$0$anon0_correct)))
(let ((anon14_Else_correct  (=> (not (= inline$AtomicVCGetElemShared$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 69) 65) anon5_0_correct) (=> (= (ControlFlow 0 69) 15) anon5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 69) 1) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3)) (and (=> (= (ControlFlow 0 73) 72) anon14_Then_correct) (=> (= (ControlFlow 0 73) 69) anon14_Else_correct)))))
(let ((anon12_Else$1_correct  (=> (and (and (= SHARED SHARED) (ValidTid tid@@3)) (and (= (select sx.R@0 x@@3) SHARED) (= (ControlFlow 0 74) 73))) inline$AtomicVCGetElemShared$0$anon0_correct)))
(let ((inline$AtomicVarStateGetRShared$0$anon0_correct  (=> (and (= (select sx.R@0 x@@3) SHARED) (= (ControlFlow 0 75) 74)) anon12_Else$1_correct)))
(let ((anon12_Else_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 76) 75)) inline$AtomicVarStateGetRShared$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (and (=> (= (ControlFlow 0 84) 83) anon12_Then_correct) (=> (= (ControlFlow 0 84) 76) anon12_Else_correct)))))
(let ((anon0_correct  (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 85) 84))) inline$AtomicThreadStateGetE$0$anon0_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (FTRepOk shadow.VC@@0 sx.W sx.R) (ValidTid tid@@3)) (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 86) 85))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock@14 () (Array T@Shadowable Int))
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@8 () (Array T@Var T@Epoch))
(declare-fun sx.R@8 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@2 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@9 () (Array T@Var T@Epoch))
(declare-fun sx.R@9 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@10 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@15 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun ok@0 () Bool)
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@9 () (Array Int Bool))
(declare-fun shadow.Lock@11 () (Array T@Shadowable Int))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@6 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@1 () T@Lock)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@5 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToRelease$0$l@1 () T@Lock)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@4 () (Array Int Bool))
(declare-fun thread.State@5 () (Array Int Int))
(declare-fun thread.State@4 () (Array Int Int))
(declare-fun inline$AtomicAllocTid$0$uid@1 () Int)
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun thread.State@3 () (Array Int Int))
(declare-fun thread.ForkedBy@3 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@1 () Int)
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.VC@7 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@7 () (Array T@Var T@Epoch))
(declare-fun sx.R@7 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@13 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@8 () (Array Int Bool))
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@6 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@12 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@7 () (Array Int Bool))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Driver_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 86) (let ((Civl_ReturnChecker_correct true))
(let ((anon8_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 20) (- 0 21)) (= (select shadow.Lock@14 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@14 (ShadowableTid tid@@3)) tid@@3) (=> (= (ControlFlow 0 20) (- 0 19)) (FTRepOk shadow.VC@8 sx.W@8 sx.R@8))))))))
(let ((Civl_UnchangedChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@2 Civl_global_old_sx.W@2 Civl_global_old_sx.R@2) (= (ControlFlow 0 14) (- 0 13))) (FTRepOk shadow.VC@9 sx.W@9 sx.R@9))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@15 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 Civl_global_old_shadow.Lock@2 Civl_global_old_shadow.VC@2 Civl_global_old_sx.W@2 Civl_global_old_sx.R@2)) (and (=> (= (ControlFlow 0 8) (- 0 9)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (=> (= (ControlFlow 0 8) (- 0 7)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 shadow.Lock@15 shadow.VC@9 sx.W@9 sx.R@9))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@2) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (and (=> (= (ControlFlow 0 3) (- 0 4)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@15)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 shadow.Lock@15) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@9 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
))))))))))
(let ((anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 78) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 78) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 78) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 78) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 78) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon9_LoopDone_correct  (=> (not ok@0) (and (=> (= (ControlFlow 0 79) 77) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 79) 78) anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon12_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@10) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 72) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 72) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 72) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 72) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 72) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 59) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 59) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 59) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 59) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 59) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon14_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@5) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 41) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 41) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 41) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 41) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 41) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon14_Else$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@2) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 32) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 32) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 32) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 32) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 32) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon8_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@8) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@14) (= sx.W@9 sx.W@8)) (and (= sx.R@9 sx.R@8) (= Civl_global_old_shadow.VC@2 Civl_global_old_shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 Civl_global_old_shadow.Lock@1) (= Civl_global_old_sx.W@2 Civl_global_old_sx.W@1)) (and (= Civl_global_old_sx.R@2 Civl_global_old_sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@9)))) (and (and (and (and (=> (= (ControlFlow 0 23) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 23) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon12_Then_0_correct  (and (=> (= (ControlFlow 0 68) (- 0 71)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 68) (- 0 70)) (FTPreserved tid@@3 shadow.Lock@10 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@10 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@10 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@10 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 68) (- 0 69)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (and (ValidTid tid@@3) (LocksPreserved tid@@3 shadow.Lock@10 shadow.Lock@11)) (=> (and (and (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableTid tid@@3)))) (= (select shadow.Lock@10 s@@1) tid@@3)) (= (select shadow.VC@1 s@@1) (select shadow.VC@5 s@@1)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (FTRepOk shadow.VC@5 sx.W@5 sx.R@5)) (and (= Civl_linear_tid_available@6 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= shadow.VC@8 shadow.VC@5))) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@11) (= sx.W@8 sx.W@5)) (and (= sx.R@8 sx.R@5) (= Civl_global_old_shadow.VC@1 shadow.VC@5))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@11) (= Civl_global_old_sx.W@1 sx.W@5)) (and (= Civl_global_old_sx.R@1 sx.R@5) (= Civl_linear_tid_available@9 Civl_linear_tid_available@6)))) (and (and (=> (= (ControlFlow 0 68) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 68) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 68) 17) Civl_UnchangedChecker_correct)))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (and (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) nil) (= shadow.Lock@10 (store shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1) tid@@3))) (and (and (=> (= (ControlFlow 0 73) 68) anon12_Then_0_correct) (=> (= (ControlFlow 0 73) 72) anon12_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 73) 17) Civl_UnchangedChecker_correct)))))
(let ((anon12_Then_correct  (and (=> (= (ControlFlow 0 74) (- 0 75)) (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 74) 73)) inline$AtomicChooseLockToAcquire$0$anon0_correct)))))
(let ((anon13_Then_0$1_correct  (=> (= shadow.VC@8 shadow.VC@4) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@9) (= sx.W@8 sx.W@4)) (and (= sx.R@8 sx.R@4) (= Civl_global_old_shadow.VC@1 shadow.VC@4))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@8) (= Civl_global_old_sx.W@1 sx.W@4)) (and (= Civl_global_old_sx.R@1 sx.R@4) (= Civl_linear_tid_available@9 Civl_linear_tid_available@5)))) (and (and (=> (= (ControlFlow 0 60) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 60) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 60) 17) Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@9 (store shadow.Lock@8 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1) nil)) (= (ControlFlow 0 61) 60)) anon13_Then_0$1_correct)))
(let ((anon13_Then_0_correct  (and (=> (= (ControlFlow 0 62) (- 0 65)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 62) (- 0 64)) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 62) (- 0 63)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (and (and (and (ValidTid tid@@3) (LocksPreserved tid@@3 shadow.Lock@1 shadow.Lock@8)) (and (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)))) (= (select shadow.Lock@1 s@@2) tid@@3)) (= (select shadow.VC@1 s@@2) (select shadow.VC@4 s@@2)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (FTRepOk shadow.VC@4 sx.W@4 sx.R@4))) (and (and (= Civl_linear_tid_available@5 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@8 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 62) 61)))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3) (and (and (=> (= (ControlFlow 0 66) 62) anon13_Then_0_correct) (=> (= (ControlFlow 0 66) 59) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 66) 17) Civl_UnchangedChecker_correct)))))
(let ((anon13_Then_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 67) 66)) inline$AtomicChooseLockToRelease$0$anon0_correct)))
(let ((anon14_Then_0$1_correct  (=> (= shadow.VC@8 shadow.VC@3) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@7) (= sx.W@8 sx.W@3)) (and (= sx.R@8 sx.R@3) (= Civl_global_old_shadow.VC@1 shadow.VC@3))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@6) (= Civl_global_old_sx.W@1 sx.W@3)) (and (= Civl_global_old_sx.R@1 sx.R@3) (= Civl_linear_tid_available@9 Civl_linear_tid_available@4)))) (and (and (=> (= (ControlFlow 0 42) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 42) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 42) 17) Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@5 (store thread.State@4 inline$AtomicAllocTid$0$uid@1 RUNNING)) (=> (and (= shadow.Lock@7 (store shadow.Lock@6 (ShadowableTid inline$AtomicAllocTid$0$uid@1) inline$AtomicAllocTid$0$uid@1)) (= (ControlFlow 0 43) 42)) anon14_Then_0$1_correct))))
(let ((anon14_Then_0_correct  (and (=> (= (ControlFlow 0 44) (- 0 47)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 44) (- 0 46)) (FTPreserved tid@@3 shadow.Lock@5 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@5 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@5 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@5 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 44) (- 0 45)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (ValidTid tid@@3) (=> (and (LocksPreserved tid@@3 shadow.Lock@5 shadow.Lock@6) (forall ((s@@3 T@Shadowable) ) (!  (=> (and (and (not (= s@@3 (ShadowableTid tid@@3))) (not (= s@@3 (ShadowableTid inline$AtomicAllocTid$0$uid@1)))) (= (select shadow.Lock@5 s@@3) tid@@3)) (= (select shadow.VC@1 s@@3) (select shadow.VC@3 s@@3)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
))) (=> (and (and (and (FTRepOk shadow.VC@3 sx.W@3 sx.R@3) (= Civl_linear_tid_available@4 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (= (select thread.State@4 inline$AtomicAllocTid$0$uid@1) NEW) (= (select shadow.Lock@6 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3))) (and (and (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (and (ValidTid tid@@3) (= (ControlFlow 0 44) 43)))) inline$AtomicStartThread$0$anon0_correct)))))))))))
(let ((anon14_Then$1_correct  (and (=> (= (ControlFlow 0 48) (- 0 56)) (= (select shadow.Lock@5 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@5 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 48) (- 0 55)) (= (select shadow.Lock@5 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3)) (=> (= (select shadow.Lock@5 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3) (and (=> (= (ControlFlow 0 48) (- 0 54)) (forall ((s@@4 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@4))
 :qid |verifiedftdefinebpl.976:37|
 :skolemid |38|
))) (=> (forall ((s@@5 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@5))
 :qid |verifiedftdefinebpl.976:37|
 :skolemid |38|
)) (and (=> (= (ControlFlow 0 48) (- 0 53)) (not (= tid@@3 inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 48) (- 0 52)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 48) (- 0 51)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (=> (ValidTid inline$AtomicAllocTid$0$uid@1) (and (=> (= (ControlFlow 0 48) (- 0 50)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 48) (- 0 49)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (=> (ValidTid inline$AtomicAllocTid$0$uid@1) (and (and (=> (= (ControlFlow 0 48) 44) anon14_Then_0_correct) (=> (= (ControlFlow 0 48) 41) anon14_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 48) 17) Civl_UnchangedChecker_correct))))))))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicAllocTid$0$uid@1) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@1)) (= thread.State@3 (store thread.State@1 inline$AtomicAllocTid$0$uid@1 NEW))) (and (and (= thread.ForkedBy@3 (store thread.ForkedBy@1 inline$AtomicAllocTid$0$uid@1 tid@@3)) (= shadow.Lock@5 (store shadow.Lock@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1) tid@@3))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1))) (= (ControlFlow 0 57) 48)))) anon14_Then$1_correct))))
(let ((anon14_Then_correct  (=> (forall ((t Int) ) (!  (=> (= (select thread.State@1 t) UNUSED) (= (select shadow.Lock@1 (ShadowableTid t)) nil))
 :qid |verifiedftdefinebpl.1025:20|
 :skolemid |39|
)) (=> (and (and (= (select thread.State@1 tid@@3) RUNNING) (ValidTid tid@@3)) (= (ControlFlow 0 58) 57)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((anon14_Else_0$1_correct  (=> (= shadow.VC@8 shadow.VC@2) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@4) (= sx.W@8 sx.W@2)) (and (= sx.R@8 sx.R@2) (= Civl_global_old_shadow.VC@1 shadow.VC@2))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@3) (= Civl_global_old_sx.W@1 sx.W@2)) (and (= Civl_global_old_sx.R@1 sx.R@2) (= Civl_linear_tid_available@9 Civl_linear_tid_available@3)))) (and (and (=> (= (ControlFlow 0 33) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 33) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 33) 17) Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@4 (store shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) nil)) (= (ControlFlow 0 34) 33)) anon14_Else_0$1_correct)))
(let ((anon14_Else_0_correct  (and (=> (= (ControlFlow 0 35) (- 0 38)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 35) (- 0 37)) (FTPreserved tid@@3 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 35) (- 0 36)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (and (ValidTid tid@@3) (LocksPreserved tid@@3 shadow.Lock@2 shadow.Lock@3)) (=> (and (and (and (forall ((s@@6 T@Shadowable) ) (!  (=> (and (and (not (= s@@6 (ShadowableTid tid@@3))) (not (= s@@6 (ShadowableTid tid@@3)))) (= (select shadow.Lock@2 s@@6) tid@@3)) (= (select shadow.VC@1 s@@6) (select shadow.VC@2 s@@6)))
 :qid |verifiedftdefinebpl.316:18|
 :skolemid |14|
)) (FTRepOk shadow.VC@2 sx.W@2 sx.R@2)) (and (= Civl_linear_tid_available@3 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid@@3))) (and (and (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1)) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1)) (and (ValidTid tid@@3) (= (ControlFlow 0 35) 34)))) inline$AtomicReleaseJoinLock$0$anon0_correct))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicChooseThreadToJoin$0$uid@1) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1)) (= (select shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) nil)) (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) tid@@3)) (= thread.HasJoined@2 (store thread.HasJoined@1 tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1 true)))) (and (and (=> (= (ControlFlow 0 39) 35) anon14_Else_0_correct) (=> (= (ControlFlow 0 39) 32) anon14_Else$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 39) 17) Civl_UnchangedChecker_correct))))))
(let ((anon14_Else_correct  (=> (and (and (= (select thread.State@1 tid@@3) RUNNING) (ValidTid tid@@3)) (= (ControlFlow 0 40) 39)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
(let ((anon10_Then_0_correct  (and (=> (= (ControlFlow 0 28) (- 0 31)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 28) (- 0 30)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 28) (- 0 29)) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (=> (FTRepOk shadow.VC@7 sx.W@7 sx.R@7) (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@13 shadow.VC@7 sx.W@7 sx.R@7)) (and (= Civl_linear_tid_available@8 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= shadow.VC@8 shadow.VC@7))) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@13) (= sx.W@8 sx.W@7)) (and (= sx.R@8 sx.R@7) (= Civl_global_old_shadow.VC@1 shadow.VC@7))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@13) (= Civl_global_old_sx.W@1 sx.W@7)) (and (= Civl_global_old_sx.R@1 sx.R@7) (= Civl_linear_tid_available@9 Civl_linear_tid_available@8)))) (and (and (=> (= (ControlFlow 0 28) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 28) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 28) 17) Civl_UnchangedChecker_correct)))))))))))))
(let ((anon11_Then_0_correct  (and (=> (= (ControlFlow 0 24) (- 0 27)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 24) (- 0 26)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 24) (- 0 25)) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (=> (FTRepOk shadow.VC@6 sx.W@6 sx.R@6) (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@12 shadow.VC@6 sx.W@6 sx.R@6)) (and (= Civl_linear_tid_available@7 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= shadow.VC@8 shadow.VC@6))) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@12) (= sx.W@8 sx.W@6)) (and (= sx.R@8 sx.R@6) (= Civl_global_old_shadow.VC@1 shadow.VC@6))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@12) (= Civl_global_old_sx.W@1 sx.W@6)) (and (= Civl_global_old_sx.R@1 sx.R@6) (= Civl_linear_tid_available@9 Civl_linear_tid_available@7)))) (and (and (=> (= (ControlFlow 0 24) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 24) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 24) 17) Civl_UnchangedChecker_correct)))))))))))))
(let ((anon10_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 18) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 18) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon11_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon9_LoopBody_correct  (=> ok@0 (and (and (and (and (and (and (and (and (=> (= (ControlFlow 0 76) 74) anon12_Then_correct) (=> (= (ControlFlow 0 76) 67) anon13_Then_correct)) (=> (= (ControlFlow 0 76) 58) anon14_Then_correct)) (=> (= (ControlFlow 0 76) 40) anon14_Else_correct)) (=> (= (ControlFlow 0 76) 24) anon11_Then_0_correct)) (=> (= (ControlFlow 0 76) 16) anon11_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 76) 17) Civl_UnchangedChecker_correct)) (=> (= (ControlFlow 0 76) 28) anon10_Then_0_correct)) (=> (= (ControlFlow 0 76) 18) anon10_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon9_LoopHead_correct  (=> (and (and (ValidTid tid@@3) (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3)) (and (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 80) 79) anon9_LoopDone_correct) (=> (= (ControlFlow 0 80) 76) anon9_LoopBody_correct)))))
(let ((anon0_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 81) (- 0 84)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 81) (- 0 83)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 81) (- 0 82)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (= (ControlFlow 0 81) 80) anon9_LoopHead_correct)))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@0) (= sx.W@9 sx.W@0)) (and (= sx.R@9 sx.R@0) (= Civl_global_old_shadow.VC@2 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@0) (= Civl_global_old_sx.W@2 sx.W@0)) (and (= Civl_global_old_sx.R@2 sx.R@0) (= Civl_linear_tid_available@10 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_correct  (=> (and (and (ValidTid tid@@3) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 85) 81) anon0_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 85) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 85) 1) Civl_RefinementChecker_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 86) 85))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun uid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVC.Inc$0$v@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Join$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Join$0$v2@0 () T@Shadowable)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Fork_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 43) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 19) (- 0 21)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableTid uid)))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@3 s@@1)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableTid uid)))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@3 s@@2)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (FTRepOk shadow.VC@3 sx.W@0 sx.R@0))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= (ControlFlow 0 17) (- 0 16))) (FTRepOk shadow.VC@3 sx.W@0 sx.R@0))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (and (=> (= (ControlFlow 0 10) (- 0 11)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@3 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 6) (- 0 7)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (=> (= (ControlFlow 0 6) (- 0 5)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@0 shadow.VC@3 sx.W@0 sx.R@0))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (and (and (= (VCArrayLen (select shadow.VC@3 (ShadowableTid uid))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid uid))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))))) (VCRepOk (select shadow.VC@3 (ShadowableTid uid)))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid uid)) j@@2) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid uid)) j@@2) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@2))))
 :qid |verifiedftdefinebpl.547:20|
 :skolemid |28|
))) (VCRepOk (select shadow.VC@3 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@3 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@3 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@3 Int) ) (!  (=> (and (<= 0 j@@3) (not (= j@@3 tid@@3))) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid tid@@3)) j@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@3)))
 :qid |verifiedftdefinebpl.551:20|
 :skolemid |29|
))) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@3 (store (store shadow.VC@0 (ShadowableTid uid) (select shadow.VC@3 (ShadowableTid uid))) (ShadowableTid tid@@3) (select shadow.VC@3 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (and (and (= (VCArrayLen (select shadow.VC@3 (ShadowableTid uid))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid uid))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))))) (VCRepOk (select shadow.VC@3 (ShadowableTid uid)))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid uid)) j@@4) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid uid)) j@@4) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@4))))
 :qid |verifiedftdefinebpl.547:20|
 :skolemid |28|
))) (VCRepOk (select shadow.VC@3 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@3 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@3 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@5 Int) ) (!  (=> (and (<= 0 j@@5) (not (= j@@5 tid@@3))) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid tid@@3)) j@@5) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@5)))
 :qid |verifiedftdefinebpl.551:20|
 :skolemid |29|
))) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@3 (store (store shadow.VC@0 (ShadowableTid uid) (select shadow.VC@3 (ShadowableTid uid))) (ShadowableTid tid@@3) (select shadow.VC@3 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (and (and (and (and (and (and (= (VCArrayLen (select shadow.VC@3 (ShadowableTid uid))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid uid))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))))) (VCRepOk (select shadow.VC@3 (ShadowableTid uid)))) (forall ((j@@6 Int) ) (!  (=> (<= 0 j@@6) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid uid)) j@@6) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid uid)) j@@6) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@6))))
 :qid |verifiedftdefinebpl.547:20|
 :skolemid |28|
))) (VCRepOk (select shadow.VC@3 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@3 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@3 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@7 Int) ) (!  (=> (and (<= 0 j@@7) (not (= j@@7 tid@@3))) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid tid@@3)) j@@7) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@7)))
 :qid |verifiedftdefinebpl.551:20|
 :skolemid |29|
))) (= (VCArrayGet (select shadow.VC@3 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@3 (store (store shadow.VC@0 (ShadowableTid uid) (select shadow.VC@3 (ShadowableTid uid))) (ShadowableTid tid@@3) (select shadow.VC@3 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (and (= shadow.VC@2 (store shadow.VC@1 inline$AtomicVC.Inc$0$v@0 (VCArraySetLen (select shadow.VC@1 inline$AtomicVC.Inc$0$v@0) (q@max (VCArrayLen (select shadow.VC@1 inline$AtomicVC.Inc$0$v@0)) (+ tid@@3 1))))) (= shadow.VC@3 (store shadow.VC@2 inline$AtomicVC.Inc$0$v@0 (store (select shadow.VC@2 inline$AtomicVC.Inc$0$v@0) tid@@3 (EpochInc (select (select shadow.VC@2 inline$AtomicVC.Inc$0$v@0) tid@@3)))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 10) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (= inline$AtomicVC.Inc$0$v@0 (ShadowableTid tid@@3)) (= (ControlFlow 0 24) 23)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 25) (- 0 31)) (VCRepOk (select shadow.VC@1 (ShadowableTid tid@@3)))) (=> (VCRepOk (select shadow.VC@1 (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 25) (- 0 30)) (>= tid@@3 0)) (=> (>= tid@@3 0) (and (=> (= (ControlFlow 0 25) (- 0 29)) (not (is-ShadowableVar (ShadowableTid tid@@3)))) (=> (not (is-ShadowableVar (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 27)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 26)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 25) 24) inline$AtomicVC.Inc$0$Entry_correct)))))))))))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (=> (and (and (= (VCArrayLen (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (q@max (VCArrayLen (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0)) (VCArrayLen (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@1 (store shadow.VC@0 inline$AtomicVC.Join$0$v1@0 (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0))) (= (ControlFlow 0 32) 25))) anon0$1_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (= inline$AtomicVC.Join$0$v1@0 (ShadowableTid uid)) (=> (and (= inline$AtomicVC.Join$0$v2@0 (ShadowableTid tid@@3)) (= (ControlFlow 0 33) 32)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (and (and (and (not (= tid@@3 uid)) (= (select shadow.Lock@0 (ShadowableTid uid)) tid@@3)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (ValidTid uid)) (ValidTid tid@@3)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 34) (- 0 42)) (VCRepOk (select shadow.VC@0 (ShadowableTid tid@@3)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 34) (- 0 41)) (not (is-ShadowableVar (ShadowableTid tid@@3)))) (=> (not (is-ShadowableVar (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 34) (- 0 40)) (not (is-ShadowableVar (ShadowableTid uid)))) (=> (not (is-ShadowableVar (ShadowableTid uid))) (and (=> (= (ControlFlow 0 34) (- 0 39)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 34) (- 0 38)) (= (select shadow.Lock@0 (ShadowableTid uid)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid uid)) tid@@3) (and (=> (= (ControlFlow 0 34) (- 0 37)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 34) (- 0 36)) (not (= (ShadowableTid uid) (ShadowableTid tid@@3)))) (=> (not (= (ShadowableTid uid) (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 34) (- 0 35)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 34) 33) inline$AtomicVC.Join$0$Entry_correct))))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 43) 34))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun uid () Int)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun inline$AtomicVC.Join$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Join$0$v2@0 () T@Shadowable)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Join_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 34) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 19) (- 0 21)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableTid tid@@3)))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@1 s@@1)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableTid tid@@3)))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@1 s@@2)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (FTRepOk shadow.VC@1 sx.W@0 sx.R@0))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= (ControlFlow 0 17) (- 0 16))) (FTRepOk shadow.VC@1 sx.W@0 sx.R@0))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (and (=> (= (ControlFlow 0 10) (- 0 11)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 6) (- 0 7)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (=> (= (ControlFlow 0 6) (- 0 5)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@0 shadow.VC@1 sx.W@0 sx.R@0))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (VCArrayLen (select shadow.VC@1 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid uid))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))))) (VCRepOk (select shadow.VC@1 (ShadowableTid tid@@3)))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (VCArrayGet (select shadow.VC@1 (ShadowableTid tid@@3)) j@@2) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@2) (VCArrayGet (select shadow.VC@0 (ShadowableTid uid)) j@@2))))
 :qid |verifiedftdefinebpl.588:20|
 :skolemid |30|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid@@3) (select shadow.VC@1 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (VCArrayLen (select shadow.VC@1 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid uid))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))))) (VCRepOk (select shadow.VC@1 (ShadowableTid tid@@3)))) (forall ((j@@3 Int) ) (!  (=> (<= 0 j@@3) (= (VCArrayGet (select shadow.VC@1 (ShadowableTid tid@@3)) j@@3) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid uid)) j@@3))))
 :qid |verifiedftdefinebpl.588:20|
 :skolemid |30|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid@@3) (select shadow.VC@1 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (and (and (= (VCArrayLen (select shadow.VC@1 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid uid))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))))) (VCRepOk (select shadow.VC@1 (ShadowableTid tid@@3)))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (VCArrayGet (select shadow.VC@1 (ShadowableTid tid@@3)) j@@4) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@4) (VCArrayGet (select shadow.VC@0 (ShadowableTid uid)) j@@4))))
 :qid |verifiedftdefinebpl.588:20|
 :skolemid |30|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid@@3) (select shadow.VC@1 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (and (and (VCRepOk (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (= (VCArrayLen (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (q@max (VCArrayLen (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0)) (VCArrayLen (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0))))) (and (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
)) (= shadow.VC@1 (store shadow.VC@0 inline$AtomicVC.Join$0$v1@0 (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 10) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (= inline$AtomicVC.Join$0$v1@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVC.Join$0$v2@0 (ShadowableTid uid)) (= (ControlFlow 0 24) 23)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (and (and (and (not (= tid@@3 uid)) (= (select shadow.Lock@0 (ShadowableTid uid)) tid@@3)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (ValidTid uid)) (ValidTid tid@@3)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 25) (- 0 33)) (VCRepOk (select shadow.VC@0 (ShadowableTid uid)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableTid uid))) (and (=> (= (ControlFlow 0 25) (- 0 32)) (not (is-ShadowableVar (ShadowableTid uid)))) (=> (not (is-ShadowableVar (ShadowableTid uid))) (and (=> (= (ControlFlow 0 25) (- 0 31)) (not (is-ShadowableVar (ShadowableTid tid@@3)))) (=> (not (is-ShadowableVar (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 25) (- 0 30)) (= (select shadow.Lock@0 (ShadowableTid uid)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid uid)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 29)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 27)) (not (= (ShadowableTid tid@@3) (ShadowableTid uid)))) (=> (not (= (ShadowableTid tid@@3) (ShadowableTid uid))) (and (=> (= (ControlFlow 0 25) (- 0 26)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 25) 24) inline$AtomicVC.Join$0$Entry_correct))))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 34) 25))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun l () T@Lock)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun inline$AtomicVC.Join$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Join$0$v2@0 () T@Shadowable)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Acquire_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 34) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 19) (- 0 21)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableTid tid@@3)))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@1 s@@1)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableTid tid@@3)))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@1 s@@2)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (FTRepOk shadow.VC@1 sx.W@0 sx.R@0))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= (ControlFlow 0 17) (- 0 16))) (FTRepOk shadow.VC@1 sx.W@0 sx.R@0))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (and (=> (= (ControlFlow 0 10) (- 0 11)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 6) (- 0 7)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (=> (= (ControlFlow 0 6) (- 0 5)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@0 shadow.VC@1 sx.W@0 sx.R@0))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 (ShadowableTid tid@@3))) (= (VCArrayLen (select shadow.VC@1 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableLock l)))))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (VCArrayGet (select shadow.VC@1 (ShadowableTid tid@@3)) j@@2) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@2) (VCArrayGet (select shadow.VC@0 (ShadowableLock l)) j@@2))))
 :qid |verifiedftdefinebpl.621:20|
 :skolemid |31|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid@@3) (select shadow.VC@1 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 (ShadowableTid tid@@3))) (= (VCArrayLen (select shadow.VC@1 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableLock l)))))) (forall ((j@@3 Int) ) (!  (=> (<= 0 j@@3) (= (VCArrayGet (select shadow.VC@1 (ShadowableTid tid@@3)) j@@3) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@3) (VCArrayGet (select shadow.VC@0 (ShadowableLock l)) j@@3))))
 :qid |verifiedftdefinebpl.621:20|
 :skolemid |31|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid@@3) (select shadow.VC@1 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 (ShadowableTid tid@@3))) (= (VCArrayLen (select shadow.VC@1 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableLock l)))))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (VCArrayGet (select shadow.VC@1 (ShadowableTid tid@@3)) j@@4) (EpochMax (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@4) (VCArrayGet (select shadow.VC@0 (ShadowableLock l)) j@@4))))
 :qid |verifiedftdefinebpl.621:20|
 :skolemid |31|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid@@3) (select shadow.VC@1 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (and (and (VCRepOk (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (= (VCArrayLen (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (q@max (VCArrayLen (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0)) (VCArrayLen (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0))))) (and (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
)) (= shadow.VC@1 (store shadow.VC@0 inline$AtomicVC.Join$0$v1@0 (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 10) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (= inline$AtomicVC.Join$0$v1@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVC.Join$0$v2@0 (ShadowableLock l)) (= (ControlFlow 0 24) 23)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (and (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (= (select shadow.Lock@0 (ShadowableLock l)) tid@@3)) (ValidTid tid@@3)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 25) (- 0 33)) (VCRepOk (select shadow.VC@0 (ShadowableLock l)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableLock l))) (and (=> (= (ControlFlow 0 25) (- 0 32)) (not (is-ShadowableVar (ShadowableLock l)))) (=> (not (is-ShadowableVar (ShadowableLock l))) (and (=> (= (ControlFlow 0 25) (- 0 31)) (not (is-ShadowableVar (ShadowableTid tid@@3)))) (=> (not (is-ShadowableVar (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 25) (- 0 30)) (= (select shadow.Lock@0 (ShadowableLock l)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableLock l)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 29)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 27)) (not (= (ShadowableTid tid@@3) (ShadowableLock l)))) (=> (not (= (ShadowableTid tid@@3) (ShadowableLock l))) (and (=> (= (ControlFlow 0 25) (- 0 26)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 25) 24) inline$AtomicVC.Join$0$Entry_correct))))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 34) 25))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun l () T@Lock)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVC.Inc$0$v@0 () T@Shadowable)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVC.Copy$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Copy$0$v2@0 () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Release_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 45) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 19) (- 0 21)) (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0)) (=> (LocksPreserved tid@@3 shadow.Lock shadow.Lock@0) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableLock l)))) (= (select shadow.Lock s@@1) tid@@3)) (= (select shadow.VC@@0 s@@1) (select shadow.VC@5 s@@1)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
))) (=> (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableLock l)))) (= (select shadow.Lock s@@2) tid@@3)) (= (select shadow.VC@@0 s@@2) (select shadow.VC@5 s@@2)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (FTRepOk shadow.VC@5 sx.W@0 sx.R@0))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= (ControlFlow 0 17) (- 0 16))) (FTRepOk shadow.VC@5 sx.W@0 sx.R@0))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (and (=> (= (ControlFlow 0 10) (- 0 11)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@0) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@5 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 6) (- 0 7)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (=> (= (ControlFlow 0 6) (- 0 5)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@0 shadow.VC@5 sx.W@0 sx.R@0))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (and (and (and (and (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@5 (ShadowableLock l))) (= (VCArrayLen (select shadow.VC@5 (ShadowableLock l))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableLock l))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3)))))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (VCArrayGet (select shadow.VC@5 (ShadowableLock l)) j@@2) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@2)))
 :qid |verifiedftdefinebpl.657:24|
 :skolemid |32|
))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@3 Int) ) (!  (=> (and (<= 0 j@@3) (not (= j@@3 tid@@3))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) j@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@3)))
 :qid |verifiedftdefinebpl.664:20|
 :skolemid |33|
))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid@@3) (select shadow.VC@5 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (select shadow.VC@5 (ShadowableLock l)) (select shadow.VC@0 (ShadowableTid tid@@3))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@4 Int) ) (!  (=> (and (<= 0 j@@4) (not (= j@@4 tid@@3))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) j@@4) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@4)))
 :qid |verifiedftdefinebpl.664:20|
 :skolemid |33|
))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid@@3) (select shadow.VC@5 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (and (and (and (and (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@5 (ShadowableLock l))) (= (VCArrayLen (select shadow.VC@5 (ShadowableLock l))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableLock l))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3)))))) (forall ((j@@5 Int) ) (!  (=> (<= 0 j@@5) (= (VCArrayGet (select shadow.VC@5 (ShadowableLock l)) j@@5) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@5)))
 :qid |verifiedftdefinebpl.657:24|
 :skolemid |32|
))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@6 Int) ) (!  (=> (and (<= 0 j@@6) (not (= j@@6 tid@@3))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) j@@6) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@6)))
 :qid |verifiedftdefinebpl.664:20|
 :skolemid |33|
))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid@@3) (select shadow.VC@5 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (select shadow.VC@5 (ShadowableLock l)) (select shadow.VC@0 (ShadowableTid tid@@3))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@7 Int) ) (!  (=> (and (<= 0 j@@7) (not (= j@@7 tid@@3))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) j@@7) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@7)))
 :qid |verifiedftdefinebpl.664:20|
 :skolemid |33|
))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid@@3) (select shadow.VC@5 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (or (and (and (and (and (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@5 (ShadowableLock l))) (= (VCArrayLen (select shadow.VC@5 (ShadowableLock l))) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableLock l))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3)))))) (forall ((j@@8 Int) ) (!  (=> (<= 0 j@@8) (= (VCArrayGet (select shadow.VC@5 (ShadowableLock l)) j@@8) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@8)))
 :qid |verifiedftdefinebpl.657:24|
 :skolemid |32|
))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@9 Int) ) (!  (=> (and (<= 0 j@@9) (not (= j@@9 tid@@3))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) j@@9) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@9)))
 :qid |verifiedftdefinebpl.664:20|
 :skolemid |33|
))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid@@3) (select shadow.VC@5 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (select shadow.VC@5 (ShadowableLock l)) (select shadow.VC@0 (ShadowableTid tid@@3))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid@@3)))) (= (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (q@max (VCArrayLen (select shadow.VC@5 (ShadowableTid tid@@3))) (+ tid@@3 1)))) (forall ((j@@10 Int) ) (!  (=> (and (<= 0 j@@10) (not (= j@@10 tid@@3))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) j@@10) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@10)))
 :qid |verifiedftdefinebpl.664:20|
 :skolemid |33|
))) (= (VCArrayGet (select shadow.VC@5 (ShadowableTid tid@@3)) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid@@3) (select shadow.VC@5 (ShadowableTid tid@@3))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (and (= shadow.VC@4 (store shadow.VC@3 inline$AtomicVC.Inc$0$v@0 (VCArraySetLen (select shadow.VC@3 inline$AtomicVC.Inc$0$v@0) (q@max (VCArrayLen (select shadow.VC@3 inline$AtomicVC.Inc$0$v@0)) (+ tid@@3 1))))) (= shadow.VC@5 (store shadow.VC@4 inline$AtomicVC.Inc$0$v@0 (store (select shadow.VC@4 inline$AtomicVC.Inc$0$v@0) tid@@3 (EpochInc (select (select shadow.VC@4 inline$AtomicVC.Inc$0$v@0) tid@@3)))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 10) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (= inline$AtomicVC.Inc$0$v@0 (ShadowableTid tid@@3)) (= (ControlFlow 0 24) 23)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 25) (- 0 31)) (VCRepOk (select shadow.VC@3 (ShadowableTid tid@@3)))) (=> (VCRepOk (select shadow.VC@3 (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 25) (- 0 30)) (>= tid@@3 0)) (=> (>= tid@@3 0) (and (=> (= (ControlFlow 0 25) (- 0 29)) (not (is-ShadowableVar (ShadowableTid tid@@3)))) (=> (not (is-ShadowableVar (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 27)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 26)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 25) 24) inline$AtomicVC.Inc$0$Entry_correct)))))))))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@2 (store shadow.VC@0 inline$AtomicVC.Copy$0$v1@0 (select shadow.VC@0 inline$AtomicVC.Copy$0$v2@0))) (=> (and (= shadow.VC@3 shadow.VC@2) (= (ControlFlow 0 33) 25)) anon0$1_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@1 inline$AtomicVC.Copy$0$v1@0)) (= (VCArrayLen (select shadow.VC@1 inline$AtomicVC.Copy$0$v1@0)) (q@max (VCArrayLen (select shadow.VC@0 inline$AtomicVC.Copy$0$v1@0)) (VCArrayLen (select shadow.VC@0 inline$AtomicVC.Copy$0$v2@0))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@1 inline$AtomicVC.Copy$0$v1@0) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@0 inline$AtomicVC.Copy$0$v2@0) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@1 (store shadow.VC@0 inline$AtomicVC.Copy$0$v1@0 (select shadow.VC@1 inline$AtomicVC.Copy$0$v1@0)))) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 32) 25))) anon0$1_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (= inline$AtomicVC.Copy$0$v1@0 (ShadowableLock l)) (= inline$AtomicVC.Copy$0$v2@0 (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 34) 32) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 34) 33) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (and (= (select shadow.Lock@0 (ShadowableLock l)) tid@@3) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (ValidTid tid@@3)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 35) (- 0 44)) (VCRepOk (select shadow.VC@0 (ShadowableLock l)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableLock l))) (and (=> (= (ControlFlow 0 35) (- 0 43)) (VCRepOk (select shadow.VC@0 (ShadowableTid tid@@3)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 35) (- 0 42)) (not (is-ShadowableVar (ShadowableTid tid@@3)))) (=> (not (is-ShadowableVar (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 35) (- 0 41)) (not (is-ShadowableVar (ShadowableLock l)))) (=> (not (is-ShadowableVar (ShadowableLock l))) (and (=> (= (ControlFlow 0 35) (- 0 40)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 35) (- 0 39)) (= (select shadow.Lock@0 (ShadowableLock l)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableLock l)) tid@@3) (and (=> (= (ControlFlow 0 35) (- 0 38)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 35) (- 0 37)) (not (= (ShadowableLock l) (ShadowableTid tid@@3)))) (=> (not (= (ShadowableLock l) (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 35) (- 0 36)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 35) 34) inline$AtomicVC.Copy$0$Entry_correct))))))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 45) 35))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun Civl_pc@1 () Bool)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@2 () (Array Int Int))
(declare-fun Civl_global_old_thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@2 () (Array Int Int))
(declare-fun Civl_global_old_thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun Civl_global_old_thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun x@@3 () T@Var)
(declare-fun tid@@3 () Int)
(declare-fun ok@0 () Bool)
(declare-fun Civl_old_ok@0 () Bool)
(declare-fun Civl_pc@2 () Bool)
(declare-fun Civl_ok@2 () Bool)
(declare-fun Civl_ok@1 () Bool)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun ok () Bool)
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@8 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun sx.W@6 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@7 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$AtomicVarStateGetWNoLock$0$e@1 () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@1 () T@Epoch)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun inline$AtomicVCGetElem$1$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$i@0 () Int)
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun inline$AtomicVC.Leq$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$v2@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$i@0 () Int)
(declare-fun call1formal@Civl_1_old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun call2formal@Civl_1_old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun call3formal@Civl_1_old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun call4formal@Civl_1_old.sx.R@0 () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Write_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 110) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 26) (- 0 28)) (or Civl_pc@1 (or (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@5 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)) (= ok@0 true)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select Civl_global_old_sx.W@0 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@3)))) (not (= (select sx.R@2 x@@3) SHARED))) (EpochLeq (select sx.R@2 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@2 x@@3))))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@3 (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select Civl_global_old_sx.W@0 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@3)))) (= (select sx.R@2 x@@3) SHARED)) (forall ((j@@2 Int) ) (!  (=> (and (and (<= 0 j@@2) (< j@@2 (q@max (VCArrayLen (select shadow.VC@2 (ShadowableVar x@@3))) (VCArrayLen (select shadow.VC@2 (ShadowableTid tid@@3)))))) (f j@@2)) (EpochLeq (VCArrayGet (select shadow.VC@2 (ShadowableVar x@@3)) j@@2) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) j@@2)))
 :qid |verifiedftdefinebpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@2))
))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@3 (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@5 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@5 x@@3))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@2 x@@3) SHARED)) (not (EpochLeq (select sx.R@2 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@2 x@@3)))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@2 x@@3) SHARED) (not (forall ((j@@3 Int) ) (!  (=> (and (and (<= 0 j@@3) (< j@@3 (q@max (VCArrayLen (select shadow.VC@2 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@2 (ShadowableVar x@@3)))))) (f j@@3)) (EpochLeq (VCArrayGet (select shadow.VC@2 (ShadowableVar x@@3)) j@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) j@@3)))
 :qid |verifiedftdefinebpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@3))
)))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)))))) (=> (or Civl_pc@1 (or (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@5 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)) (= ok@0 true)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select Civl_global_old_sx.W@0 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@3)))) (not (= (select sx.R@2 x@@3) SHARED))) (EpochLeq (select sx.R@2 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@2 x@@3))))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@3 (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select Civl_global_old_sx.W@0 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@3)))) (= (select sx.R@2 x@@3) SHARED)) (forall ((j@@4 Int) ) (!  (=> (and (and (<= 0 j@@4) (< j@@4 (q@max (VCArrayLen (select shadow.VC@2 (ShadowableVar x@@3))) (VCArrayLen (select shadow.VC@2 (ShadowableTid tid@@3)))))) (f j@@4)) (EpochLeq (VCArrayGet (select shadow.VC@2 (ShadowableVar x@@3)) j@@4) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) j@@4)))
 :qid |verifiedftdefinebpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@4))
))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@3 (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@5 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@5 x@@3))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@2 x@@3) SHARED)) (not (EpochLeq (select sx.R@2 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@2 x@@3)))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@2 x@@3) SHARED) (not (forall ((j@@5 Int) ) (!  (=> (and (and (<= 0 j@@5) (< j@@5 (q@max (VCArrayLen (select shadow.VC@2 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@2 (ShadowableVar x@@3)))))) (f j@@5)) (EpochLeq (VCArrayGet (select shadow.VC@2 (ShadowableVar x@@3)) j@@5) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) j@@5)))
 :qid |verifiedftdefinebpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@5))
)))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))))) (and (=> (= (ControlFlow 0 26) (- 0 27)) (=> Civl_pc@1 (and (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (= ok@0 Civl_old_ok@0)))) (=> (=> Civl_pc@1 (and (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (= ok@0 Civl_old_ok@0))) (=> (and (and (= Civl_pc@2  (=> (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) Civl_pc@1)) (= Civl_ok@2  (or (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@5 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)) (= ok@0 true)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select Civl_global_old_sx.W@0 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@3)))) (not (= (select sx.R@2 x@@3) SHARED))) (EpochLeq (select sx.R@2 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@2 x@@3))))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@3 (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select Civl_global_old_sx.W@0 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@3)))) (= (select sx.R@2 x@@3) SHARED)) (forall ((j@@6 Int) ) (!  (=> (and (and (<= 0 j@@6) (< j@@6 (q@max (VCArrayLen (select shadow.VC@2 (ShadowableVar x@@3))) (VCArrayLen (select shadow.VC@2 (ShadowableTid tid@@3)))))) (f j@@6)) (EpochLeq (VCArrayGet (select shadow.VC@2 (ShadowableVar x@@3)) j@@6) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) j@@6)))
 :qid |verifiedftdefinebpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@6))
))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@3 (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@5 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@5 x@@3))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@2 x@@3) SHARED)) (not (EpochLeq (select sx.R@2 x@@3) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@2 x@@3)))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@2 x@@3) SHARED) (not (forall ((j@@7 Int) ) (!  (=> (and (and (<= 0 j@@7) (< j@@7 (q@max (VCArrayLen (select shadow.VC@2 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@2 (ShadowableVar x@@3)))))) (f j@@7)) (EpochLeq (VCArrayGet (select shadow.VC@2 (ShadowableVar x@@3)) j@@7) (VCArrayGet (select shadow.VC@2 (ShadowableTid tid@@3)) j@@7)))
 :qid |verifiedftdefinebpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@7))
)))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (= ok@0 Civl_old_ok@0) Civl_ok@1)))) (= (ControlFlow 0 26) (- 0 25))) Civl_ok@2)))))))
(let ((anon12_Then_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@0) (=> (and (= sx.W@5 sx.W@0) (= ok@0 true)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= sx.R@2 sx.R@0)) (and (= thread.State@2 thread.State@0) (= thread.ForkedBy@2 thread.ForkedBy@0))) (and (and (= thread.HasJoined@2 thread.HasJoined@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_global_old_thread.State@0 thread.State@0)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@0) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@0))) (and (and (= Civl_pc@1 false) (= Civl_ok@1 false)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 99) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon13_Then$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@6) (=> (and (= sx.W@5 sx.W@1) (= ok@0 false)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@1) (= sx.R@2 sx.R@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 76) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon15_Then$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@5) (=> (and (= sx.W@5 sx.W@1) (= ok@0 false)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@1) (= sx.R@2 sx.R@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 60) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon16_Then$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@3) (=> (and (= sx.W@5 sx.W@1) (= ok@0 false)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@1) (= sx.R@2 sx.R@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 39) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon11$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@4) (=> (and (= sx.W@5 sx.W@4) (= ok@0 true)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@1) (= sx.R@2 sx.R@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 29) 26))))) Civl_ReturnChecker_correct)))))
(let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (FTRepOk shadow.VC@5 sx.W@8 sx.R@5)) (=> (FTRepOk shadow.VC@5 sx.W@8 sx.R@5) (and (=> (= (ControlFlow 0 20) (- 0 21)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 20) (- 0 19)) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@10 shadow.VC@5 sx.W@8 sx.R@5))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@5 sx.R@3) (=> (and (and (= sx.W@8 sx.W@6) (= shadow.Lock@10 shadow.Lock@8)) (and (= shadow.VC@5 shadow.VC@3) (= (ControlFlow 0 23) 20))) GeneratedUnifiedExit_correct))))
(let ((anon12_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@0) (=> (and (and (= sx.W@6 sx.W@0) (= shadow.VC@3 shadow.VC@0)) (and (= sx.R@3 sx.R@0) (= (ControlFlow 0 100) 23))) Civl_UnifiedReturn_correct))))
(let ((anon13_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@6) (=> (and (and (= sx.W@6 sx.W@1) (= shadow.VC@3 shadow.VC@1)) (and (= sx.R@3 sx.R@1) (= (ControlFlow 0 77) 23))) Civl_UnifiedReturn_correct))))
(let ((anon15_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@5) (=> (and (and (= sx.W@6 sx.W@1) (= shadow.VC@3 shadow.VC@1)) (and (= sx.R@3 sx.R@1) (= (ControlFlow 0 61) 23))) Civl_UnifiedReturn_correct))))
(let ((anon16_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@3) (=> (and (and (= sx.W@6 sx.W@1) (= shadow.VC@3 shadow.VC@1)) (and (= sx.R@3 sx.R@1) (= (ControlFlow 0 40) 23))) Civl_UnifiedReturn_correct))))
(let ((anon11$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@4) (=> (and (and (= sx.W@6 sx.W@4) (= shadow.VC@3 shadow.VC@1)) (and (= sx.R@3 sx.R@1) (= (ControlFlow 0 24) 23))) Civl_UnifiedReturn_correct))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@1 Civl_global_old_sx.W@1 Civl_global_old_sx.R@1) (= (ControlFlow 0 16) (- 0 15))) (FTRepOk shadow.VC@4 sx.W@7 sx.R@4))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 13) (- 0 14)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (=> (= (ControlFlow 0 13) (- 0 12)) (= (select shadow.Lock@9 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@1) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select Civl_global_old_shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 9) (- 0 11)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (and (=> (= (ControlFlow 0 9) (- 0 10)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@9)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@9) (=> (= (ControlFlow 0 9) (- 0 8)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@4 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 Civl_global_old_shadow.Lock@1 Civl_global_old_shadow.VC@1 Civl_global_old_sx.W@1 Civl_global_old_sx.R@1)) (and (=> (= (ControlFlow 0 5) (- 0 6)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (=> (= (ControlFlow 0 5) (- 0 4)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@9 shadow.VC@4 sx.W@7 sx.R@4))))))))
(let ((anon12_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@7 sx.W@0)) (and (= sx.R@4 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 101) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 101) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 101) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 101) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 101) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon12_Then_correct  (=> (= inline$AtomicVarStateGetWNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 102) 99) anon12_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 102) 100) anon12_Then_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 102) 101) anon12_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@6) (= sx.W@7 sx.W@1)) (and (= sx.R@4 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 78) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 78) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 78) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 78) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 78) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$3$anon0_correct  (=> (= shadow.Lock@6 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 79) 76) anon13_Then$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 79) 77) anon13_Then$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 79) 78) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon13_Then_correct  (=> (not (EpochLeq inline$AtomicVarStateGetW$0$e@1 inline$AtomicVCGetElem$0$e@1)) (and (=> (= (ControlFlow 0 80) (- 0 82)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 80) (- 0 81)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 80) 79) inline$AtomicReleaseVarLock$3$anon0_correct))))))))
(let ((anon15_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@5) (= sx.W@7 sx.W@1)) (and (= sx.R@4 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 62) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 62) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 62) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 62) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 62) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$2$anon0_correct  (=> (= shadow.Lock@5 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 63) 60) anon15_Then$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 63) 61) anon15_Then$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 63) 62) anon15_Then$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon15_Then_correct  (=> (not (EpochLeq inline$AtomicVarStateGetR$0$e@1 inline$AtomicVCGetElem$1$e@1)) (and (=> (= (ControlFlow 0 64) (- 0 66)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 64) (- 0 65)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 64) 63) inline$AtomicReleaseVarLock$2$anon0_correct))))))))
(let ((anon16_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@3) (= sx.W@7 sx.W@1)) (and (= sx.R@4 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 41) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 41) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 41) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 41) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 41) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (= shadow.Lock@3 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 42) 39) anon16_Then$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 42) 40) anon16_Then$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 42) 41) anon16_Then$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon16_Then_correct  (=> (not inline$AtomicVC.Leq$0$res@1) (and (=> (= (ControlFlow 0 43) (- 0 45)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 43) (- 0 44)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 43) 42) inline$AtomicReleaseVarLock$1$anon0_correct))))))))
(let ((anon11$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@4) (= sx.W@7 sx.W@4)) (and (= sx.R@4 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 18) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 18) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (= shadow.Lock@4 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 30) 29) anon11$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 30) 24) anon11$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 30) 18) anon11$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon11_correct  (and (=> (= (ControlFlow 0 31) (- 0 33)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 31) (- 0 32)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 31) 30) inline$AtomicReleaseVarLock$0$anon0_correct)))))))
(let ((anon15_Else$1_correct  (=> (and (= sx.W@4 sx.W@3) (= (ControlFlow 0 55) 31)) anon11_correct)))
(let ((inline$AtomicVarStateSetW$1$anon0_correct  (=> (and (= sx.W@3 (store sx.W@1 x@@3 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 56) 55)) anon15_Else$1_correct)))
(let ((anon15_Else_correct  (=> (EpochLeq inline$AtomicVarStateGetR$0$e@1 inline$AtomicVCGetElem$1$e@1) (and (=> (= (ControlFlow 0 57) (- 0 59)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 57) (- 0 58)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 57) 56) inline$AtomicVarStateSetW$1$anon0_correct))))))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@1 (VCArrayGet (select shadow.VC@1 inline$AtomicVCGetElem$1$r@0) inline$AtomicVCGetElem$1$i@0)) (and (=> (= (ControlFlow 0 67) 64) anon15_Then_correct) (=> (= (ControlFlow 0 67) 57) anon15_Else_correct)))))
(let ((inline$AtomicVCGetElem$1$Entry_correct  (=> (= inline$AtomicVCGetElem$1$r@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVCGetElem$1$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 68) 67)) inline$AtomicVCGetElem$1$anon0_correct))))
(let ((anon14_Then_correct  (=> (not (= inline$AtomicVarStateGetR$0$e@1 SHARED)) (and (=> (= (ControlFlow 0 69) (- 0 71)) (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 69) (- 0 70)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 69) 68) inline$AtomicVCGetElem$1$Entry_correct))))))))
(let ((anon16_Else$1_correct  (=> (and (= sx.W@4 sx.W@2) (= (ControlFlow 0 34) 31)) anon11_correct)))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@2 (store sx.W@1 x@@3 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 35) 34)) anon16_Else$1_correct)))
(let ((anon16_Else_correct  (=> inline$AtomicVC.Leq$0$res@1 (and (=> (= (ControlFlow 0 36) (- 0 38)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 36) (- 0 37)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 36) 35) inline$AtomicVarStateSetW$0$anon0_correct))))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@1 inline$AtomicVC.Leq$0$v1@0) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@1 inline$AtomicVC.Leq$0$v2@0) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (and (=> (= (ControlFlow 0 46) 43) anon16_Then_correct) (=> (= (ControlFlow 0 46) 36) anon16_Else_correct)))))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (= inline$AtomicVC.Leq$0$v1@0 (ShadowableVar x@@3)) (=> (and (= inline$AtomicVC.Leq$0$v2@0 (ShadowableTid tid@@3)) (= (ControlFlow 0 47) 46)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((anon14_Else_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 SHARED) (and (=> (= (ControlFlow 0 48) (- 0 54)) (not (is-ShadowableVar (ShadowableTid tid@@3)))) (=> (not (is-ShadowableVar (ShadowableTid tid@@3))) (and (=> (= (ControlFlow 0 48) (- 0 53)) (=> (is-ShadowableVar (ShadowableVar x@@3)) (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED))) (=> (=> (is-ShadowableVar (ShadowableVar x@@3)) (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED)) (and (=> (= (ControlFlow 0 48) (- 0 52)) (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 48) (- 0 51)) (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 48) (- 0 50)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 48) (- 0 49)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 48) 47) inline$AtomicVC.Leq$0$Entry_correct))))))))))))))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@1 x@@3)) (and (=> (= (ControlFlow 0 72) 69) anon14_Then_correct) (=> (= (ControlFlow 0 72) 48) anon14_Else_correct)))))
(let ((anon13_Else_correct  (=> (EpochLeq inline$AtomicVarStateGetW$0$e@1 inline$AtomicVCGetElem$0$e@1) (and (=> (= (ControlFlow 0 73) (- 0 75)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 73) (- 0 74)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 73) 72) inline$AtomicVarStateGetR$0$anon0_correct))))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 inline$AtomicVCGetElem$0$r@0) inline$AtomicVCGetElem$0$i@0)) (and (=> (= (ControlFlow 0 83) 80) anon13_Then_correct) (=> (= (ControlFlow 0 83) 73) anon13_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= inline$AtomicVCGetElem$0$r@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVCGetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetW$0$e@1)) (= (ControlFlow 0 84) 83)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((anon2_0$2_correct  (and (=> (= (ControlFlow 0 85) (- 0 87)) (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 85) (- 0 86)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 85) 84) inline$AtomicVCGetElem$0$Entry_correct)))))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@1 x@@3)) (= (ControlFlow 0 88) 85)) anon2_0$2_correct)))
(let ((anon2_0$1_correct  (and (=> (= (ControlFlow 0 89) (- 0 91)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 89) (- 0 90)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 89) 88) inline$AtomicVarStateGetW$0$anon0_correct)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableVar x@@3)) nil) (=> (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableVar x@@3) tid@@3)) (= (ControlFlow 0 92) 89)) anon2_0$1_correct))))
(let ((anon2_0_correct  (=> (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3)))) (not (= (select sx.R@0 x@@3) SHARED))) (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3))))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3)))) (= (select sx.R@0 x@@3) SHARED)) (forall ((j@@8 Int) ) (!  (=> (and (and (<= 0 j@@8) (< j@@8 (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar x@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3)))))) (f j@@8)) (EpochLeq (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) j@@8) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@8)))
 :qid |verifiedftdefinebpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@8))
))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (not (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3)))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (not (forall ((j@@9 Int) ) (!  (=> (and (and (<= 0 j@@9) (< j@@9 (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableVar x@@3)))))) (f j@@9)) (EpochLeq (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) j@@9) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@9)))
 :qid |verifiedftdefinebpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@9))
)))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (= ok ok) false)))) (=> (and (and (= call1formal@Civl_1_old.shadow.Lock@0 shadow.Lock) (= call2formal@Civl_1_old.shadow.VC@0 shadow.VC@@0)) (and (= call3formal@Civl_1_old.sx.W@0 sx.W) (= call4formal@Civl_1_old.sx.R@0 sx.R))) (and (=> (= (ControlFlow 0 93) (- 0 97)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 93) (- 0 96)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 93) (- 0 95)) (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (and (or Civl_pc@0 (ValidTid tid@@3)) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 93) (- 0 94)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 93) 92) inline$AtomicAcquireVarLock$0$anon0_correct)))))))))))))))
(let ((anon12_Else_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@7 sx.W@0)) (and (= sx.R@4 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 17) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 17) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 17) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 17) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3)))) (not (= (select sx.R@0 x@@3) SHARED))) (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3))))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3)))) (= (select sx.R@0 x@@3) SHARED)) (forall ((j@@10 Int) ) (!  (=> (and (and (<= 0 j@@10) (< j@@10 (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar x@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3)))))) (f j@@10)) (EpochLeq (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) j@@10) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@10)))
 :qid |verifiedftdefinebpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@10))
))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (not (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3)))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (not (forall ((j@@11 Int) ) (!  (=> (and (and (<= 0 j@@11) (< j@@11 (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableVar x@@3)))))) (f j@@11)) (EpochLeq (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) j@@11) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@11)))
 :qid |verifiedftdefinebpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@11))
)))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3)))) (not (= (select sx.R@0 x@@3) SHARED))) (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3))))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3)))) (= (select sx.R@0 x@@3) SHARED)) (forall ((j@@12 Int) ) (!  (=> (and (and (<= 0 j@@12) (< j@@12 (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar x@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3)))))) (f j@@12)) (EpochLeq (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) j@@12) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@12)))
 :qid |verifiedftdefinebpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@12))
))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (not (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3)))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (not (forall ((j@@13 Int) ) (!  (=> (and (and (<= 0 j@@13) (< j@@13 (q@max (VCArrayLen (select shadow.VC@0 (ShadowableTid tid@@3))) (VCArrayLen (select shadow.VC@0 (ShadowableVar x@@3)))))) (f j@@13)) (EpochLeq (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) j@@13) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) j@@13)))
 :qid |verifiedftdefinebpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@13))
)))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> false (and (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (= ok ok))))))))
(let ((anon12_Else_correct  (=> (not (= inline$AtomicVarStateGetWNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 98) 93) anon2_0_correct) (=> (= (ControlFlow 0 98) 17) anon12_Else_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 98) 2) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVarStateGetWNoLock$0$anon0_correct  (=> (= inline$AtomicVarStateGetWNoLock$0$e@1 (select sx.W@0 x@@3)) (and (=> (= (ControlFlow 0 103) 102) anon12_Then_correct) (=> (= (ControlFlow 0 103) 98) anon12_Else_correct)))))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 104) (- 0 105)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 104) 103) inline$AtomicVarStateGetWNoLock$0$anon0_correct)))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (= (ControlFlow 0 106) 104)) anon0$1_correct)))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (and (ValidTid tid@@3) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 107) (- 0 109)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 107) (- 0 108)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 107) 106) inline$AtomicThreadStateGetE$0$anon0_correct))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (ValidTid tid@@3) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (=> (and (and (FTRepOk shadow.VC@@0 sx.W sx.R) (ValidTid tid@@3)) (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 110) 107))) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun Civl_pc@1 () Bool)
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@2 () (Array Int Int))
(declare-fun Civl_global_old_thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@2 () (Array Int Int))
(declare-fun Civl_global_old_thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun Civl_global_old_thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun x@@3 () T@Var)
(declare-fun tid@@3 () Int)
(declare-fun ok@0 () Bool)
(declare-fun Civl_old_ok@0 () Bool)
(declare-fun Civl_pc@2 () Bool)
(declare-fun Civl_ok@2 () Bool)
(declare-fun Civl_ok@1 () Bool)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun ok () Bool)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun shadow.VC@12 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun sx.R@7 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun shadow.VC@10 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@11 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$AtomicVarStateGetRNoLock$0$e@1 () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@1 () T@Epoch)
(declare-fun shadow.VC@7 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$1$r@0 () T@Shadowable)
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCSetElem$0$i@0 () Int)
(declare-fun inline$AtomicVCInit$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$i@0 () Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCGetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$i@0 () Int)
(declare-fun call1formal@Civl_1_old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun call2formal@Civl_1_old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun call3formal@Civl_1_old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun call4formal@Civl_1_old.sx.R@0 () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Read_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 138) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 26) (- 0 28)) (or Civl_pc@1 (or (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3)) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) SHARED) (= (VCArrayGet (select shadow.VC@9 (ShadowableVar x@@3)) tid@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3))) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (EpochLeq (select Civl_global_old_sx.R@0 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3))))) (= ok@0 true)) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@3 (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) SHARED) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= ok@0 true)) (= shadow.VC@9 (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (VCArrayLen (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3))) (+ tid@@3 1)))))) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= shadow.VC@9 (store (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) 1) (+ tid@@3 1)))))) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@3 SHARED))) (= ok@0 true)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= ok@0 false)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)))))) (=> (or Civl_pc@1 (or (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3)) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) SHARED) (= (VCArrayGet (select shadow.VC@9 (ShadowableVar x@@3)) tid@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3))) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (EpochLeq (select Civl_global_old_sx.R@0 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3))))) (= ok@0 true)) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@3 (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) SHARED) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= ok@0 true)) (= shadow.VC@9 (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (VCArrayLen (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3))) (+ tid@@3 1)))))) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= shadow.VC@9 (store (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) 1) (+ tid@@3 1)))))) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@3 SHARED))) (= ok@0 true)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= ok@0 false)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))))) (and (=> (= (ControlFlow 0 26) (- 0 27)) (=> Civl_pc@1 (and (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (= ok@0 Civl_old_ok@0)))) (=> (=> Civl_pc@1 (and (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (= ok@0 Civl_old_ok@0))) (=> (and (and (= Civl_pc@2  (=> (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) Civl_pc@1)) (= Civl_ok@2  (or (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3)) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) SHARED) (= (VCArrayGet (select shadow.VC@9 (ShadowableVar x@@3)) tid@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3))) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (EpochLeq (select Civl_global_old_sx.R@0 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3))))) (= ok@0 true)) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@3 (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@3) SHARED) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= ok@0 true)) (= shadow.VC@9 (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (VCArrayLen (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3))) (+ tid@@3 1)))))) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select Civl_global_old_shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= shadow.VC@9 (store (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) (select Civl_global_old_sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@3)) 1) (+ tid@@3 1)))))) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@3 SHARED))) (= ok@0 true)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@2 x@@3) (VCArrayGet (select shadow.VC@9 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@2 x@@3))))) (= ok@0 false)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (= ok@0 Civl_old_ok@0) Civl_ok@1)))) (= (ControlFlow 0 26) (- 0 25))) Civl_ok@2)))))))
(let ((anon13_Then_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (= shadow.Lock@7 shadow.Lock@0) (= sx.R@4 sx.R@0)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@0)) (and (= thread.State@2 thread.State@0) (= thread.ForkedBy@2 thread.ForkedBy@0))) (and (and (= thread.HasJoined@2 thread.HasJoined@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_global_old_thread.State@0 thread.State@0)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@0) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@0))) (and (and (= Civl_pc@1 false) (= Civl_ok@1 false)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 126) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon14_Then_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (= shadow.Lock@7 shadow.Lock@0) (= sx.R@4 sx.R@0)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@0)) (and (= thread.State@2 thread.State@0) (= thread.ForkedBy@2 thread.ForkedBy@0))) (and (and (= thread.HasJoined@2 thread.HasJoined@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_global_old_thread.State@0 thread.State@0)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@0) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@0))) (and (and (= Civl_pc@1 false) (= Civl_ok@1 false)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 114) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon15_Then$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (= shadow.Lock@7 shadow.Lock@6) (= sx.R@4 sx.R@1)) (=> (and (and (and (and (= ok@0 false) (= sx.W@2 sx.W@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 91) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon17_Then$2_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (= shadow.Lock@7 shadow.Lock@5) (= sx.R@4 sx.R@3)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 69) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon17_Else$5_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@8) (=> (and (= shadow.Lock@7 shadow.Lock@4) (= sx.R@4 sx.R@2)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 39) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon16_Else$2_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@3) (=> (and (= shadow.Lock@7 shadow.Lock@3) (= sx.R@4 sx.R@1)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 29) 26))))) Civl_ReturnChecker_correct)))))
(let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (FTRepOk shadow.VC@12 sx.W@5 sx.R@7)) (=> (FTRepOk shadow.VC@12 sx.W@5 sx.R@7) (and (=> (= (ControlFlow 0 20) (- 0 21)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 20) (- 0 19)) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@10 shadow.VC@12 sx.W@5 sx.R@7))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@7 sx.R@5) (=> (and (and (= sx.W@5 sx.W@3) (= shadow.Lock@10 shadow.Lock@8)) (and (= shadow.VC@12 shadow.VC@10) (= (ControlFlow 0 23) 20))) GeneratedUnifiedExit_correct))))
(let ((anon13_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.R@5 sx.R@0)) (and (= sx.W@3 sx.W@0) (= (ControlFlow 0 127) 23))) Civl_UnifiedReturn_correct))))
(let ((anon14_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.R@5 sx.R@0)) (and (= sx.W@3 sx.W@0) (= (ControlFlow 0 115) 23))) Civl_UnifiedReturn_correct))))
(let ((anon15_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@1) (=> (and (and (= shadow.Lock@8 shadow.Lock@6) (= sx.R@5 sx.R@1)) (and (= sx.W@3 sx.W@1) (= (ControlFlow 0 92) 23))) Civl_UnifiedReturn_correct))))
(let ((anon17_Then$2_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@1) (=> (and (and (= shadow.Lock@8 shadow.Lock@5) (= sx.R@5 sx.R@3)) (and (= sx.W@3 sx.W@1) (= (ControlFlow 0 70) 23))) Civl_UnifiedReturn_correct))))
(let ((anon17_Else$5_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@8) (=> (and (and (= shadow.Lock@8 shadow.Lock@4) (= sx.R@5 sx.R@2)) (and (= sx.W@3 sx.W@1) (= (ControlFlow 0 40) 23))) Civl_UnifiedReturn_correct))))
(let ((anon16_Else$2_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@3) (=> (and (and (= shadow.Lock@8 shadow.Lock@3) (= sx.R@5 sx.R@1)) (and (= sx.W@3 sx.W@1) (= (ControlFlow 0 24) 23))) Civl_UnifiedReturn_correct))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@1 Civl_global_old_sx.W@1 Civl_global_old_sx.R@1) (= (ControlFlow 0 16) (- 0 15))) (FTRepOk shadow.VC@11 sx.W@4 sx.R@6))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 13) (- 0 14)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (=> (= (ControlFlow 0 13) (- 0 12)) (= (select shadow.Lock@9 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@1) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select Civl_global_old_shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 9) (- 0 11)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (and (=> (= (ControlFlow 0 9) (- 0 10)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@9)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@9) (=> (= (ControlFlow 0 9) (- 0 8)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@11 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 Civl_global_old_shadow.Lock@1 Civl_global_old_shadow.VC@1 Civl_global_old_sx.W@1 Civl_global_old_sx.R@1)) (and (=> (= (ControlFlow 0 5) (- 0 6)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (=> (= (ControlFlow 0 5) (- 0 4)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@9 shadow.VC@11 sx.W@4 sx.R@6))))))))
(let ((anon13_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@4 sx.W@0)) (and (= sx.R@6 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 128) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 128) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 128) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 128) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 128) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon13_Then_correct  (=> (= inline$AtomicVarStateGetRNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 129) 126) anon13_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 129) 127) anon13_Then_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 129) 128) anon13_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon14_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@4 sx.W@0)) (and (= sx.R@6 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 116) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 116) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 116) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 116) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 116) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon14_Then_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 117) 114) anon14_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 117) 115) anon14_Then_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 117) 116) anon14_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon15_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@6) (= sx.W@4 sx.W@1)) (and (= sx.R@6 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 93) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 93) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 93) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 93) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 93) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$3$anon0_correct  (=> (= shadow.Lock@6 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 94) 91) anon15_Then$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 94) 92) anon15_Then$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 94) 93) anon15_Then$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon15_Then_correct  (=> (not (EpochLeq inline$AtomicVarStateGetW$0$e@1 inline$AtomicVCGetElem$0$e@1)) (and (=> (= (ControlFlow 0 95) (- 0 97)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 95) (- 0 96)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 95) 94) inline$AtomicReleaseVarLock$3$anon0_correct))))))))
(let ((anon17_Then$2_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@5) (= sx.W@4 sx.W@1)) (and (= sx.R@6 sx.R@3) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 71) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 71) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 71) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 71) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 71) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$2$anon0_correct  (=> (= shadow.Lock@5 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 72) 69) anon17_Then$2_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 72) 70) anon17_Then$2_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 72) 71) anon17_Then$2_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon17_Then$1_correct  (and (=> (= (ControlFlow 0 73) (- 0 75)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 73) (- 0 74)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 73) 72) inline$AtomicReleaseVarLock$2$anon0_correct)))))))
(let ((inline$AtomicVarStateSetR$1$anon0_correct  (=> (and (= sx.R@3 (store sx.R@1 x@@3 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 76) 73)) anon17_Then$1_correct)))
(let ((anon17_Then_correct  (=> (EpochLeq inline$AtomicVarStateGetR$0$e@1 inline$AtomicVCGetElem$1$e@1) (and (=> (= (ControlFlow 0 77) (- 0 81)) (>= (|tid#epoch| inline$AtomicThreadStateGetE$0$e@1) 0)) (=> (>= (|tid#epoch| inline$AtomicThreadStateGetE$0$e@1) 0) (and (=> (= (ControlFlow 0 77) (- 0 80)) (not (= (select sx.R@1 x@@3) SHARED))) (=> (not (= (select sx.R@1 x@@3) SHARED)) (and (=> (= (ControlFlow 0 77) (- 0 79)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 77) (- 0 78)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 77) 76) inline$AtomicVarStateSetR$1$anon0_correct))))))))))))
(let ((anon17_Else$5_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@8) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@4) (= sx.W@4 sx.W@1)) (and (= sx.R@6 sx.R@2) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 41) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 41) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 41) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 41) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 41) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (= shadow.Lock@4 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 42) 39) anon17_Else$5_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 42) 40) anon17_Else$5_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 42) 41) anon17_Else$5_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon17_Else$4_correct  (and (=> (= (ControlFlow 0 43) (- 0 45)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 43) (- 0 44)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 43) 42) inline$AtomicReleaseVarLock$1$anon0_correct)))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@2 (store sx.R@1 x@@3 SHARED)) (= (ControlFlow 0 46) 43)) anon17_Else$4_correct)))
(let ((anon17_Else$3_correct  (and (=> (= (ControlFlow 0 47) (- 0 50)) (not (= (select sx.R@1 x@@3) SHARED))) (=> (not (= (select sx.R@1 x@@3) SHARED)) (and (=> (= (ControlFlow 0 47) (- 0 49)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 47) (- 0 48)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 47) 46) inline$AtomicVarStateSetR$0$anon0_correct)))))))))
(let ((inline$AtomicVCSetElem$1$anon0_correct  (=> (= shadow.VC@7 (store shadow.VC@6 inline$AtomicVCSetElem$1$r@0 (store (select shadow.VC@6 inline$AtomicVCSetElem$1$r@0) tid@@3 inline$AtomicThreadStateGetE$0$e@1))) (=> (and (= shadow.VC@8 (store shadow.VC@7 inline$AtomicVCSetElem$1$r@0 (VCArraySetLen (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0) (q@max (VCArrayLen (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0)) (+ tid@@3 1))))) (= (ControlFlow 0 51) 47)) anon17_Else$3_correct))))
(let ((inline$AtomicVCSetElem$1$Entry_correct  (=> (and (= inline$AtomicVCSetElem$1$r@0 (ShadowableVar x@@3)) (= (ControlFlow 0 52) 51)) inline$AtomicVCSetElem$1$anon0_correct)))
(let ((anon17_Else$2_correct  (and (=> (= (ControlFlow 0 53) (- 0 56)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 53) (- 0 55)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 53) (- 0 54)) (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED)))) (=> (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED))) (=> (= (ControlFlow 0 53) 52) inline$AtomicVCSetElem$1$Entry_correct)))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@5 (store shadow.VC@4 inline$AtomicVCSetElem$0$r@0 (store (select shadow.VC@4 inline$AtomicVCSetElem$0$r@0) inline$AtomicVCSetElem$0$i@0 inline$AtomicVarStateGetR$0$e@1))) (=> (and (= shadow.VC@6 (store shadow.VC@5 inline$AtomicVCSetElem$0$r@0 (VCArraySetLen (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0) (q@max (VCArrayLen (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0)) (+ inline$AtomicVCSetElem$0$i@0 1))))) (= (ControlFlow 0 57) 53)) anon17_Else$2_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (= inline$AtomicVCSetElem$0$r@0 (ShadowableVar x@@3)) (=> (and (= inline$AtomicVCSetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 58) 57)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((anon17_Else$1_correct  (and (=> (= (ControlFlow 0 59) (- 0 62)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 59) (- 0 61)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 59) (- 0 60)) (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED)))) (=> (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED))) (=> (= (ControlFlow 0 59) 58) inline$AtomicVCSetElem$0$Entry_correct)))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@4 (store shadow.VC@1 inline$AtomicVCInit$0$r@0 VC.bottom)) (= (ControlFlow 0 63) 59)) anon17_Else$1_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (= inline$AtomicVCInit$0$r@0 (ShadowableVar x@@3)) (= (ControlFlow 0 64) 63)) inline$AtomicVCInit$0$anon0_correct)))
(let ((anon17_Else_correct  (=> (not (EpochLeq inline$AtomicVarStateGetR$0$e@1 inline$AtomicVCGetElem$1$e@1)) (and (=> (= (ControlFlow 0 65) (- 0 68)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 65) (- 0 67)) (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED)))) (=> (=> (is-ShadowableVar (ShadowableVar x@@3)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@3))) SHARED))) (and (=> (= (ControlFlow 0 65) (- 0 66)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 65) 64) inline$AtomicVCInit$0$Entry_correct))))))))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@1 (VCArrayGet (select shadow.VC@1 inline$AtomicVCGetElem$1$r@0) inline$AtomicVCGetElem$1$i@0)) (and (=> (= (ControlFlow 0 82) 77) anon17_Then_correct) (=> (= (ControlFlow 0 82) 65) anon17_Else_correct)))))
(let ((inline$AtomicVCGetElem$1$Entry_correct  (=> (= inline$AtomicVCGetElem$1$r@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVCGetElem$1$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 83) 82)) inline$AtomicVCGetElem$1$anon0_correct))))
(let ((anon16_Then_correct  (=> (not (= inline$AtomicVarStateGetR$0$e@1 SHARED)) (and (=> (= (ControlFlow 0 84) (- 0 86)) (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 84) (- 0 85)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 84) 83) inline$AtomicVCGetElem$1$Entry_correct))))))))
(let ((anon16_Else$2_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@3) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@3) (= sx.W@4 sx.W@1)) (and (= sx.R@6 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 18) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 18) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (= shadow.Lock@3 (store shadow.Lock@2 (ShadowableVar x@@3) nil)) (and (and (=> (= (ControlFlow 0 30) 29) anon16_Else$2_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 30) 24) anon16_Else$2_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 30) 18) anon16_Else$2_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon16_Else$1_correct  (and (=> (= (ControlFlow 0 31) (- 0 33)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 31) (- 0 32)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 31) 30) inline$AtomicReleaseVarLock$0$anon0_correct)))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar x@@3) (store (select shadow.VC@1 (ShadowableVar x@@3)) tid@@3 inline$AtomicThreadStateGetE$0$e@1))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar x@@3) (VCArraySetLen (select shadow.VC@2 (ShadowableVar x@@3)) (q@max (VCArrayLen (select shadow.VC@2 (ShadowableVar x@@3))) (+ tid@@3 1))))) (= (ControlFlow 0 34) 31)) anon16_Else$1_correct))))
(let ((anon16_Else_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 SHARED) (and (=> (= (ControlFlow 0 35) (- 0 38)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 35) (- 0 37)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 35) (- 0 36)) (= (select sx.R@1 x@@3) SHARED)) (=> (= (select sx.R@1 x@@3) SHARED) (=> (= (ControlFlow 0 35) 34) inline$AtomicVCSetElemShared$0$anon0_correct))))))))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@1 x@@3)) (and (=> (= (ControlFlow 0 87) 84) anon16_Then_correct) (=> (= (ControlFlow 0 87) 35) anon16_Else_correct)))))
(let ((anon15_Else_correct  (=> (EpochLeq inline$AtomicVarStateGetW$0$e@1 inline$AtomicVCGetElem$0$e@1) (and (=> (= (ControlFlow 0 88) (- 0 90)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 88) (- 0 89)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 88) 87) inline$AtomicVarStateGetR$0$anon0_correct))))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@1 inline$AtomicVCGetElem$0$r@0) inline$AtomicVCGetElem$0$i@0)) (and (=> (= (ControlFlow 0 98) 95) anon15_Then_correct) (=> (= (ControlFlow 0 98) 88) anon15_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= inline$AtomicVCGetElem$0$r@0 (ShadowableTid tid@@3)) (=> (and (= inline$AtomicVCGetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetW$0$e@1)) (= (ControlFlow 0 99) 98)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((anon5_0$2_correct  (and (=> (= (ControlFlow 0 100) (- 0 102)) (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 100) (- 0 101)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 100) 99) inline$AtomicVCGetElem$0$Entry_correct)))))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@1 x@@3)) (= (ControlFlow 0 103) 100)) anon5_0$2_correct)))
(let ((anon5_0$1_correct  (and (=> (= (ControlFlow 0 104) (- 0 106)) (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@3)) tid@@3) (and (=> (= (ControlFlow 0 104) (- 0 105)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 104) 103) inline$AtomicVarStateGetW$0$anon0_correct)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableVar x@@3)) nil) (=> (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableVar x@@3) tid@@3)) (= (ControlFlow 0 107) 104)) anon5_0$1_correct))))
(let ((anon5_0_correct  (=> (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (= (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3))))) (= ok true)) (= sx.R@0 (store sx.R@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok true)) (= shadow.VC@0 (store (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (VCArrayLen (select (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3))) (+ tid@@3 1)))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= shadow.VC@0 (store (store (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (+ (|tid#epoch| (select sx.R@0 x@@3)) 1) (+ tid@@3 1)))))) (= sx.R@0 (store sx.R@0 x@@3 SHARED))) (= ok true)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (= ok ok) false)))) (=> (and (and (= call1formal@Civl_1_old.shadow.Lock@0 shadow.Lock) (= call2formal@Civl_1_old.shadow.VC@0 shadow.VC@@0)) (and (= call3formal@Civl_1_old.sx.W@0 sx.W) (= call4formal@Civl_1_old.sx.R@0 sx.R))) (and (=> (= (ControlFlow 0 108) (- 0 112)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (and (=> (= (ControlFlow 0 108) (- 0 111)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 108) (- 0 110)) (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (and (and (ValidTid tid@@3) (FTPreserved tid@@3 call1formal@Civl_1_old.shadow.Lock@0 call2formal@Civl_1_old.shadow.VC@0 call3formal@Civl_1_old.sx.W@0 call4formal@Civl_1_old.sx.R@0 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (and (or Civl_pc@0 (and (and (and (not (= tid@@3 nil)) (>= tid@@3 0)) (>= tid@@3 0)) (ValidTid tid@@3))) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 108) (- 0 109)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 108) 107) inline$AtomicAcquireVarLock$0$anon0_correct)))))))))))))))
(let ((anon5_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@4 sx.W@0)) (and (= sx.R@6 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 17) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 17) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 17) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 17) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (= (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3))))) (= ok true)) (= sx.R@0 (store sx.R@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok true)) (= shadow.VC@0 (store (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (VCArrayLen (select (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3))) (+ tid@@3 1)))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= shadow.VC@0 (store (store (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (+ (|tid#epoch| (select sx.R@0 x@@3)) 1) (+ tid@@3 1)))))) (= sx.R@0 (store sx.R@0 x@@3 SHARED))) (= ok true)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (= (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (EpochLeq (select sx.R@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.R@0 x@@3))))) (= ok true)) (= sx.R@0 (store sx.R@0 x@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@3) SHARED) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok true)) (= shadow.VC@0 (store (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (VCArrayLen (select (store shadow.VC@0 (ShadowableVar x@@3) (store (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3))) (+ tid@@3 1)))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@3) SHARED)) (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= shadow.VC@0 (store (store (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3) (VCArraySetLen (select (store (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3) (store (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableVar x@@3)) tid@@3 (VCArrayGet (select (store (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3) (store (select (store shadow.VC@0 (ShadowableVar x@@3) VC.bottom) (ShadowableVar x@@3)) (|tid#epoch| (select sx.R@0 x@@3)) (select sx.R@0 x@@3))) (ShadowableTid tid@@3)) tid@@3))) (ShadowableVar x@@3)) (q@max (+ (|tid#epoch| (select sx.R@0 x@@3)) 1) (+ tid@@3 1)))))) (= sx.R@0 (store sx.R@0 x@@3 SHARED))) (= ok true)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (EpochLeq (select sx.W@0 x@@3) (VCArrayGet (select shadow.VC@0 (ShadowableTid tid@@3)) (|tid#epoch| (select sx.W@0 x@@3))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> false (and (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (= ok ok))))))))
(let ((anon13_Else_correct  (=> (not (= inline$AtomicVarStateGetRNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 125) 108) anon5_0_correct) (=> (= (ControlFlow 0 125) 17) anon5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 125) 2) Civl_RefinementChecker_correct)))))
(let ((anon12_Then$1_correct  (=> (not (= inline$AtomicVarStateGetRNoLock$0$e@1 SHARED)) (and (=> (= (ControlFlow 0 130) 129) anon13_Then_correct) (=> (= (ControlFlow 0 130) 125) anon13_Else_correct)))))
(let ((inline$AtomicVarStateGetRNoLock$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetRNoLock$0$e@1 (select sx.R@0 x@@3)) (= (ControlFlow 0 131) 130)) anon12_Then$1_correct)))
(let ((anon12_Then_correct  (and (=> (= (ControlFlow 0 132) (- 0 133)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 132) 131) inline$AtomicVarStateGetRNoLock$0$anon0_correct)))))
(let ((anon14_Else_correct  (=> (not (= inline$AtomicVCGetElemShared$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 113) 108) anon5_0_correct) (=> (= (ControlFlow 0 113) 17) anon5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 113) 2) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@0 (ShadowableVar x@@3)) tid@@3)) (and (=> (= (ControlFlow 0 118) 117) anon14_Then_correct) (=> (= (ControlFlow 0 118) 113) anon14_Else_correct)))))
(let ((anon12_Else$1_correct  (=> (= SHARED SHARED) (and (=> (= (ControlFlow 0 119) (- 0 121)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 119) (- 0 120)) (= (select sx.R@0 x@@3) SHARED)) (=> (= (select sx.R@0 x@@3) SHARED) (=> (= (ControlFlow 0 119) 118) inline$AtomicVCGetElemShared$0$anon0_correct))))))))
(let ((inline$AtomicVarStateGetRShared$0$anon0_correct  (=> (and (= (select sx.R@0 x@@3) SHARED) (= (ControlFlow 0 122) 119)) anon12_Else$1_correct)))
(let ((anon12_Else_correct  (and (=> (= (ControlFlow 0 123) (- 0 124)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 123) 122) inline$AtomicVarStateGetRShared$0$anon0_correct)))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid tid@@3)) tid@@3)) (and (=> (= (ControlFlow 0 134) 132) anon12_Then_correct) (=> (= (ControlFlow 0 134) 123) anon12_Else_correct)))))
(let ((anon0_correct  (=> (ValidTid tid@@3) (=> (and (and (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (and (ValidTid tid@@3) (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock@0 shadow.VC@0 sx.W@0 sx.R@0))) (=> (and (and (and (and (not (= tid@@3 nil)) (>= tid@@3 0)) (>= tid@@3 0)) (ValidTid tid@@3)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 135) (- 0 137)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 135) (- 0 136)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 135) 134) inline$AtomicThreadStateGetE$0$anon0_correct))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (ValidTid tid@@3) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (=> (and (and (FTRepOk shadow.VC@@0 sx.W sx.R) (ValidTid tid@@3)) (and (FTPreserved tid@@3 shadow.Lock shadow.VC@@0 sx.W sx.R shadow.Lock shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 138) 135))) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock@14 () (Array T@Shadowable Int))
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@8 () (Array T@Var T@Epoch))
(declare-fun sx.R@8 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@2 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@9 () (Array T@Var T@Epoch))
(declare-fun sx.R@9 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@10 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@15 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun ok@0 () Bool)
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@9 () (Array Int Bool))
(declare-fun shadow.Lock@11 () (Array T@Shadowable Int))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@6 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@1 () T@Lock)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@5 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToRelease$0$l@1 () T@Lock)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@4 () (Array Int Bool))
(declare-fun thread.State@5 () (Array Int Int))
(declare-fun thread.State@4 () (Array Int Int))
(declare-fun inline$AtomicAllocTid$0$uid@1 () Int)
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun thread.State@3 () (Array Int Int))
(declare-fun thread.ForkedBy@3 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@1 () Int)
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.VC@7 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@7 () (Array T@Var T@Epoch))
(declare-fun sx.R@7 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@13 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@8 () (Array Int Bool))
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@6 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@12 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@7 () (Array Int Bool))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Driver_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 92) (let ((Civl_ReturnChecker_correct true))
(let ((anon8_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 20) (- 0 21)) (= (select shadow.Lock@14 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@14 (ShadowableTid tid@@3)) tid@@3) (=> (= (ControlFlow 0 20) (- 0 19)) (FTRepOk shadow.VC@8 sx.W@8 sx.R@8))))))))
(let ((Civl_UnchangedChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (FTRepOk Civl_global_old_shadow.VC@2 Civl_global_old_sx.W@2 Civl_global_old_sx.R@2) (= (ControlFlow 0 14) (- 0 13))) (FTRepOk shadow.VC@9 sx.W@9 sx.R@9))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@15 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@2) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select Civl_global_old_shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 7) (- 0 9)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (and (=> (= (ControlFlow 0 7) (- 0 8)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@15)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 shadow.Lock@15) (=> (= (ControlFlow 0 7) (- 0 6)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@9 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 Civl_global_old_shadow.Lock@2 Civl_global_old_shadow.VC@2 Civl_global_old_sx.W@2 Civl_global_old_sx.R@2)) (and (=> (= (ControlFlow 0 3) (- 0 4)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (=> (= (ControlFlow 0 3) (- 0 2)) (FTPreserved inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 shadow.Lock@15 shadow.VC@9 sx.W@9 sx.R@9))))))))
(let ((anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 84) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 84) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 84) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 84) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 84) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon9_LoopDone_correct  (=> (not ok@0) (and (=> (= (ControlFlow 0 85) 83) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 85) 84) anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon12_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@10) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 78) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 78) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 78) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 78) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 78) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 65) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 65) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 65) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 65) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 65) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon14_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@5) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 47) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 47) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 47) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 47) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 47) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon14_Else$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@2) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 38) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 38) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 38) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 38) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 38) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon8_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@8) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@14) (= sx.W@9 sx.W@8)) (and (= sx.R@9 sx.R@8) (= Civl_global_old_shadow.VC@2 Civl_global_old_shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 Civl_global_old_shadow.Lock@1) (= Civl_global_old_sx.W@2 Civl_global_old_sx.W@1)) (and (= Civl_global_old_sx.R@2 Civl_global_old_sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@9)))) (and (and (and (and (=> (= (ControlFlow 0 23) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 23) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon8_correct  (and (=> (= (ControlFlow 0 24) (- 0 25)) (= (select shadow.Lock@14 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@14 (ShadowableTid tid@@3)) tid@@3) (and (and (=> (= (ControlFlow 0 24) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 24) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 24) 17) Civl_UnchangedChecker_correct))))))
(let ((anon12_Then_0_correct  (and (=> (= (ControlFlow 0 74) (- 0 77)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 74) (- 0 76)) (FTPreserved tid@@3 shadow.Lock@10 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@10 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@10 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@10 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 74) (- 0 75)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (ValidTid tid@@3) (=> (and (LocksPreserved tid@@3 shadow.Lock@10 shadow.Lock@11) (forall ((s@@1 T@Shadowable) ) (!  (=> (and (and (not (= s@@1 (ShadowableTid tid@@3))) (not (= s@@1 (ShadowableTid tid@@3)))) (= (select shadow.Lock@10 s@@1) tid@@3)) (= (select shadow.VC@1 s@@1) (select shadow.VC@5 s@@1)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
))) (=> (and (and (FTRepOk shadow.VC@5 sx.W@5 sx.R@5) (= Civl_linear_tid_available@6 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (= shadow.VC@8 shadow.VC@5) (= shadow.Lock@14 shadow.Lock@11))) (=> (and (and (and (= sx.W@8 sx.W@5) (= sx.R@8 sx.R@5)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@5) (= Civl_global_old_shadow.Lock@1 shadow.Lock@11))) (and (and (= Civl_global_old_sx.W@1 sx.W@5) (= Civl_global_old_sx.R@1 sx.R@5)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@6) (= (ControlFlow 0 74) 24)))) anon8_correct))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (and (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) nil) (= shadow.Lock@10 (store shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1) tid@@3))) (and (and (=> (= (ControlFlow 0 79) 74) anon12_Then_0_correct) (=> (= (ControlFlow 0 79) 78) anon12_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 79) 17) Civl_UnchangedChecker_correct)))))
(let ((anon12_Then_correct  (and (=> (= (ControlFlow 0 80) (- 0 81)) (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 80) 79)) inline$AtomicChooseLockToAcquire$0$anon0_correct)))))
(let ((anon13_Then_0$1_correct  (=> (and (= shadow.VC@8 shadow.VC@4) (= shadow.Lock@14 shadow.Lock@9)) (=> (and (and (and (= sx.W@8 sx.W@4) (= sx.R@8 sx.R@4)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@4) (= Civl_global_old_shadow.Lock@1 shadow.Lock@8))) (and (and (= Civl_global_old_sx.W@1 sx.W@4) (= Civl_global_old_sx.R@1 sx.R@4)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@5) (= (ControlFlow 0 66) 24)))) anon8_correct))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@9 (store shadow.Lock@8 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1) nil)) (= (ControlFlow 0 67) 66)) anon13_Then_0$1_correct)))
(let ((anon13_Then_0_correct  (and (=> (= (ControlFlow 0 68) (- 0 71)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 68) (- 0 70)) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 68) (- 0 69)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (and (and (and (ValidTid tid@@3) (LocksPreserved tid@@3 shadow.Lock@1 shadow.Lock@8)) (and (forall ((s@@2 T@Shadowable) ) (!  (=> (and (and (not (= s@@2 (ShadowableTid tid@@3))) (not (= s@@2 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)))) (= (select shadow.Lock@1 s@@2) tid@@3)) (= (select shadow.VC@1 s@@2) (select shadow.VC@4 s@@2)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
)) (FTRepOk shadow.VC@4 sx.W@4 sx.R@4))) (and (and (= Civl_linear_tid_available@5 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@8 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 68) 67)))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3) (and (and (=> (= (ControlFlow 0 72) 68) anon13_Then_0_correct) (=> (= (ControlFlow 0 72) 65) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 72) 17) Civl_UnchangedChecker_correct)))))
(let ((anon13_Then_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 73) 72)) inline$AtomicChooseLockToRelease$0$anon0_correct)))
(let ((anon14_Then_0$1_correct  (=> (and (= shadow.VC@8 shadow.VC@3) (= shadow.Lock@14 shadow.Lock@7)) (=> (and (and (and (= sx.W@8 sx.W@3) (= sx.R@8 sx.R@3)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@3) (= Civl_global_old_shadow.Lock@1 shadow.Lock@6))) (and (and (= Civl_global_old_sx.W@1 sx.W@3) (= Civl_global_old_sx.R@1 sx.R@3)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@4) (= (ControlFlow 0 48) 24)))) anon8_correct))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@5 (store thread.State@4 inline$AtomicAllocTid$0$uid@1 RUNNING)) (=> (and (= shadow.Lock@7 (store shadow.Lock@6 (ShadowableTid inline$AtomicAllocTid$0$uid@1) inline$AtomicAllocTid$0$uid@1)) (= (ControlFlow 0 49) 48)) anon14_Then_0$1_correct))))
(let ((anon14_Then_0_correct  (and (=> (= (ControlFlow 0 50) (- 0 53)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 50) (- 0 52)) (FTPreserved tid@@3 shadow.Lock@5 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@5 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@5 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@5 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 50) (- 0 51)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (ValidTid tid@@3) (=> (and (LocksPreserved tid@@3 shadow.Lock@5 shadow.Lock@6) (forall ((s@@3 T@Shadowable) ) (!  (=> (and (and (not (= s@@3 (ShadowableTid tid@@3))) (not (= s@@3 (ShadowableTid inline$AtomicAllocTid$0$uid@1)))) (= (select shadow.Lock@5 s@@3) tid@@3)) (= (select shadow.VC@1 s@@3) (select shadow.VC@3 s@@3)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
))) (=> (and (and (and (FTRepOk shadow.VC@3 sx.W@3 sx.R@3) (= Civl_linear_tid_available@4 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (= (select thread.State@4 inline$AtomicAllocTid$0$uid@1) NEW) (= (select shadow.Lock@6 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3))) (and (and (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (and (ValidTid tid@@3) (= (ControlFlow 0 50) 49)))) inline$AtomicStartThread$0$anon0_correct)))))))))))
(let ((anon14_Then$1_correct  (and (=> (= (ControlFlow 0 54) (- 0 62)) (= (select shadow.Lock@5 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@5 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 54) (- 0 61)) (= (select shadow.Lock@5 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3)) (=> (= (select shadow.Lock@5 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3) (and (=> (= (ControlFlow 0 54) (- 0 60)) (forall ((s@@4 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@4))
 :qid |verifiedftdefinebpl.976:37|
 :skolemid |38|
))) (=> (forall ((s@@5 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@5))
 :qid |verifiedftdefinebpl.976:37|
 :skolemid |38|
)) (and (=> (= (ControlFlow 0 54) (- 0 59)) (not (= tid@@3 inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 54) (- 0 58)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 54) (- 0 57)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (=> (ValidTid inline$AtomicAllocTid$0$uid@1) (and (=> (= (ControlFlow 0 54) (- 0 56)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 54) (- 0 55)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (=> (ValidTid inline$AtomicAllocTid$0$uid@1) (and (and (=> (= (ControlFlow 0 54) 50) anon14_Then_0_correct) (=> (= (ControlFlow 0 54) 47) anon14_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 54) 17) Civl_UnchangedChecker_correct))))))))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicAllocTid$0$uid@1) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@1)) (= thread.State@3 (store thread.State@1 inline$AtomicAllocTid$0$uid@1 NEW))) (and (and (= thread.ForkedBy@3 (store thread.ForkedBy@1 inline$AtomicAllocTid$0$uid@1 tid@@3)) (= shadow.Lock@5 (store shadow.Lock@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1) tid@@3))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1))) (= (ControlFlow 0 63) 54)))) anon14_Then$1_correct))))
(let ((anon14_Then_correct  (=> (forall ((t Int) ) (!  (=> (= (select thread.State@1 t) UNUSED) (= (select shadow.Lock@1 (ShadowableTid t)) nil))
 :qid |verifiedftdefinebpl.1025:20|
 :skolemid |39|
)) (=> (and (and (= (select thread.State@1 tid@@3) RUNNING) (ValidTid tid@@3)) (= (ControlFlow 0 64) 63)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((anon14_Else_0$1_correct  (=> (and (= shadow.VC@8 shadow.VC@2) (= shadow.Lock@14 shadow.Lock@4)) (=> (and (and (and (= sx.W@8 sx.W@2) (= sx.R@8 sx.R@2)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@2) (= Civl_global_old_shadow.Lock@1 shadow.Lock@3))) (and (and (= Civl_global_old_sx.W@1 sx.W@2) (= Civl_global_old_sx.R@1 sx.R@2)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@3) (= (ControlFlow 0 39) 24)))) anon8_correct))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@4 (store shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) nil)) (= (ControlFlow 0 40) 39)) anon14_Else_0$1_correct)))
(let ((anon14_Else_0_correct  (and (=> (= (ControlFlow 0 41) (- 0 44)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 41) (- 0 43)) (FTPreserved tid@@3 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@2 shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 41) (- 0 42)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (=> (and (ValidTid tid@@3) (LocksPreserved tid@@3 shadow.Lock@2 shadow.Lock@3)) (=> (and (and (and (forall ((s@@6 T@Shadowable) ) (!  (=> (and (and (not (= s@@6 (ShadowableTid tid@@3))) (not (= s@@6 (ShadowableTid tid@@3)))) (= (select shadow.Lock@2 s@@6) tid@@3)) (= (select shadow.VC@1 s@@6) (select shadow.VC@2 s@@6)))
 :qid |verifiedftdefinebpl.523:18|
 :skolemid |27|
)) (FTRepOk shadow.VC@2 sx.W@2 sx.R@2)) (and (= Civl_linear_tid_available@3 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid@@3))) (and (and (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1)) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1)) (and (ValidTid tid@@3) (= (ControlFlow 0 41) 40)))) inline$AtomicReleaseJoinLock$0$anon0_correct))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicChooseThreadToJoin$0$uid@1) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1)) (= (select shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) nil)) (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) tid@@3)) (= thread.HasJoined@2 (store thread.HasJoined@1 tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1 true)))) (and (and (=> (= (ControlFlow 0 45) 41) anon14_Else_0_correct) (=> (= (ControlFlow 0 45) 38) anon14_Else$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 45) 17) Civl_UnchangedChecker_correct))))))
(let ((anon14_Else_correct  (=> (and (and (= (select thread.State@1 tid@@3) RUNNING) (ValidTid tid@@3)) (= (ControlFlow 0 46) 45)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
(let ((anon10_Then_0_correct  (and (=> (= (ControlFlow 0 32) (- 0 37)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 32) (- 0 36)) (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 32) (- 0 35)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 32) (- 0 34)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 32) (- 0 33)) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (=> (and (FTRepOk shadow.VC@7 sx.W@7 sx.R@7) (ValidTid tid@@3)) (=> (and (and (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@13 shadow.VC@7 sx.W@7 sx.R@7) (= Civl_linear_tid_available@8 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (= shadow.VC@8 shadow.VC@7) (= shadow.Lock@14 shadow.Lock@13))) (=> (and (and (and (= sx.W@8 sx.W@7) (= sx.R@8 sx.R@7)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@7) (= Civl_global_old_shadow.Lock@1 shadow.Lock@13))) (and (and (= Civl_global_old_sx.W@1 sx.W@7) (= Civl_global_old_sx.R@1 sx.R@7)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@8) (= (ControlFlow 0 32) 24)))) anon8_correct)))))))))))))))
(let ((anon11_Then_0_correct  (and (=> (= (ControlFlow 0 26) (- 0 31)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 26) (- 0 30)) (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 26) (- 0 29)) (FTRepOk shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (and (=> (= (ControlFlow 0 26) (- 0 28)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 26) (- 0 27)) (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1)) (=> (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1) (=> (and (FTRepOk shadow.VC@6 sx.W@6 sx.R@6) (ValidTid tid@@3)) (=> (and (and (FTPreserved tid@@3 shadow.Lock@1 shadow.VC@1 sx.W@1 sx.R@1 shadow.Lock@12 shadow.VC@6 sx.W@6 sx.R@6) (= Civl_linear_tid_available@7 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))) (and (= shadow.VC@8 shadow.VC@6) (= shadow.Lock@14 shadow.Lock@12))) (=> (and (and (and (= sx.W@8 sx.W@6) (= sx.R@8 sx.R@6)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@6) (= Civl_global_old_shadow.Lock@1 shadow.Lock@12))) (and (and (= Civl_global_old_sx.W@1 sx.W@6) (= Civl_global_old_sx.R@1 sx.R@6)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@7) (= (ControlFlow 0 26) 24)))) anon8_correct)))))))))))))))
(let ((anon10_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 18) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 18) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon11_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 16) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon9_LoopBody_correct  (=> ok@0 (and (and (and (and (and (and (and (and (=> (= (ControlFlow 0 82) 80) anon12_Then_correct) (=> (= (ControlFlow 0 82) 73) anon13_Then_correct)) (=> (= (ControlFlow 0 82) 64) anon14_Then_correct)) (=> (= (ControlFlow 0 82) 46) anon14_Else_correct)) (=> (= (ControlFlow 0 82) 26) anon11_Then_0_correct)) (=> (= (ControlFlow 0 82) 16) anon11_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 82) 17) Civl_UnchangedChecker_correct)) (=> (= (ControlFlow 0 82) 32) anon10_Then_0_correct)) (=> (= (ControlFlow 0 82) 18) anon10_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon9_LoopHead_correct  (=> (and (and (ValidTid tid@@3) (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3)) (and (FTRepOk shadow.VC@1 sx.W@1 sx.R@1) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 86) 85) anon9_LoopDone_correct) (=> (= (ControlFlow 0 86) 82) anon9_LoopBody_correct)))))
(let ((anon0_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 87) (- 0 90)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 87) (- 0 89)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 87) (- 0 88)) (FTRepOk shadow.VC@0 sx.W@0 sx.R@0)) (=> (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (=> (= (ControlFlow 0 87) 86) anon9_LoopHead_correct)))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@0) (= sx.W@9 sx.W@0)) (and (= sx.R@9 sx.R@0) (= Civl_global_old_shadow.VC@2 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@0) (= Civl_global_old_sx.W@2 sx.W@0)) (and (= Civl_global_old_sx.R@2 sx.R@0) (= Civl_linear_tid_available@10 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 15) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_correct  (=> (and (and (ValidTid tid@@3) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (and (FTRepOk shadow.VC@0 sx.W@0 sx.R@0) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 91) 87) anon0_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 91) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 91) 1) Civl_RefinementChecker_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (ValidTid tid@@3) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (and (FTRepOk shadow.VC@@0 sx.W sx.R) (= (ControlFlow 0 92) 91))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun ok@0 () Bool)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock@15 () (Array T@Shadowable Int))
(declare-fun thread.State@11 () (Array Int Int))
(declare-fun ok@2 () Bool)
(declare-fun ok@1 () Bool)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@11 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@16 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 () Int)
(declare-fun Civl_global_old_thread.State@2 () (Array Int Int))
(declare-fun thread.State@12 () (Array Int Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.thread.State@0 () (Array Int Int))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun shadow.Lock@13 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun thread.State@8 () (Array Int Int))
(declare-fun Civl_linear_tid_available@7 () (Array Int Bool))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun thread.State@5 () (Array Int Int))
(declare-fun Civl_linear_tid_available@5 () (Array Int Bool))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun thread.State@4 () (Array Int Int))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_thread.State@1 () (Array Int Int))
(declare-fun Civl_linear_tid_available@10 () (Array Int Bool))
(declare-fun inline$AtomicWrite$0$ok@2 () Bool)
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun x@1 () T@Var)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicWrite$0$st@2 () T@Shadowable)
(declare-fun inline$AtomicWrite$0$sx@2 () T@Shadowable)
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@10 () (Array T@Var T@Epoch))
(declare-fun sx.W@9 () (Array T@Var T@Epoch))
(declare-fun Trigger_AtomicWrite_sx (T@Shadowable) Bool)
(declare-fun inline$AtomicWrite$0$sx@1 () T@Shadowable)
(declare-fun Trigger_AtomicWrite_st (T@Shadowable) Bool)
(declare-fun inline$AtomicWrite$0$st@1 () T@Shadowable)
(declare-fun inline$AtomicRead$0$ok@2 () Bool)
(declare-fun x@2 () T@Var)
(declare-fun inline$AtomicRead$0$st@2 () T@Shadowable)
(declare-fun shadow.VC@15 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRead$0$sx@2 () T@Shadowable)
(declare-fun shadow.VC@16 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@17 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@18 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@10 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@13 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@14 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@9 () (Array T@Var T@Epoch))
(declare-fun Trigger_AtomicRead_sx (T@Shadowable) Bool)
(declare-fun inline$AtomicRead$0$sx@1 () T@Shadowable)
(declare-fun Trigger_AtomicRead_st (T@Shadowable) Bool)
(declare-fun inline$AtomicRead$0$st@1 () T@Shadowable)
(declare-fun shadow.Lock@14 () (Array T@Shadowable Int))
(declare-fun thread.State@10 () (Array Int Int))
(declare-fun Civl_linear_tid_available@9 () (Array Int Bool))
(declare-fun Trigger_AtomicAcquire_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicAcquire$0$v2@1 () T@Shadowable)
(declare-fun Trigger_AtomicAcquire_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicAcquire$0$v1@1 () T@Shadowable)
(declare-fun inline$AtomicAcquire$0$v1@2 () T@Shadowable)
(declare-fun inline$AtomicAcquire$0$v2@2 () T@Shadowable)
(declare-fun inline$AtomicChooseLockToAcquire$0$l@1 () T@Lock)
(declare-fun shadow.VC@12 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@11 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@12 () (Array T@Shadowable Int))
(declare-fun thread.State@9 () (Array Int Int))
(declare-fun shadow.Lock@11 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@8 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToRelease$0$l@1 () T@Lock)
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRelease$0$v2@2 () T@Shadowable)
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRelease$0$v1@2 () T@Shadowable)
(declare-fun Trigger_AtomicRelease_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicRelease$0$v2@1 () T@Shadowable)
(declare-fun Trigger_AtomicRelease_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicRelease$0$v1@1 () T@Shadowable)
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun thread.State@7 () (Array Int Int))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun thread.State@6 () (Array Int Int))
(declare-fun Civl_linear_tid_available@6 () (Array Int Bool))
(declare-fun inline$AtomicAllocTid$0$uid@1 () Int)
(declare-fun Trigger_AtomicFork_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicFork$0$v2@1 () T@Shadowable)
(declare-fun Trigger_AtomicFork_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicFork$0$v1@1 () T@Shadowable)
(declare-fun inline$AtomicFork$0$v1@2 () T@Shadowable)
(declare-fun inline$AtomicFork$0$v2@2 () T@Shadowable)
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.ForkedBy@4 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun thread.State@3 () (Array Int Int))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@4 () (Array Int Bool))
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@1 () Int)
(declare-fun thread.State@2 () (Array Int Int))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun Trigger_AtomicJoin_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicJoin$0$v2@1 () T@Shadowable)
(declare-fun Trigger_AtomicJoin_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicJoin$0$v1@1 () T@Shadowable)
(declare-fun inline$AtomicJoin$0$v1@2 () T@Shadowable)
(declare-fun inline$AtomicJoin$0$v2@2 () T@Shadowable)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun ok () Bool)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.State () (Array Int Int))
(set-info :boogie-vc-id Civl_Driver_30)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 187) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 174) (- 0 176)) true) (and (=> (= (ControlFlow 0 174) (- 0 175)) (=> false (= ok@0 ok@0))) (=> (=> false (= ok@0 ok@0)) (=> (and (and (= Civl_pc@0  (=> true false)) (= Civl_ok@0  (or true (and (= ok@0 ok@0) false)))) (= (ControlFlow 0 174) (- 0 173))) Civl_ok@0))))))
(let ((anon8_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 25) (- 0 29)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@15 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@15 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 27)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 25) (- 0 26)) (= (select thread.State@11 tid@@3) RUNNING)) (=> (= (select thread.State@11 tid@@3) RUNNING) (=> (= (ControlFlow 0 25) (- 0 24)) (forall ((t Int) ) (!  (=> (= (select thread.State@11 t) UNUSED) (= (select shadow.Lock@15 (ShadowableTid t)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)))))))))))))
(let ((Civl_UnchangedChecker_correct  (and (=> (= (ControlFlow 0 19) (- 0 20)) true) (=> (= (ControlFlow 0 19) (- 0 18)) (=> false (= ok@2 ok@0))))))
(let ((anon12_Then$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 135) 19)) Civl_UnchangedChecker_correct)))
(let ((anon13_Then_1$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 105) 19)) Civl_UnchangedChecker_correct)))
(let ((anon13_Then$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 103) 19)) Civl_UnchangedChecker_correct)))
(let ((anon14_Then_1$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 64) 19)) Civl_UnchangedChecker_correct)))
(let ((anon14_Then$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 62) 19)) Civl_UnchangedChecker_correct)))
(let ((anon8_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@1) (= (ControlFlow 0 31) 19)) Civl_UnchangedChecker_correct)))
(let ((anon14_Else_1$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 23) 19)) Civl_UnchangedChecker_correct)))
(let ((anon14_Else$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 21) 19)) Civl_UnchangedChecker_correct)))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@11 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |335|
)) (=> (and (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0) (= (select Civl_global_old_shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@16 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@11 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |336|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0)) (and (= (select Civl_global_old_thread.State@2 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0) RUNNING) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t Int) ) (!  (=> (= (select Civl_global_old_thread.State@2 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t) UNUSED) (= (select Civl_global_old_shadow.Lock@2 (ShadowableTid inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t)) nil))
 :qid |unknown.0:0|
 :skolemid |36|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0) (and (=> (= (ControlFlow 0 10) (- 0 11)) (= (select thread.State@12 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0) RUNNING)) (=> (= (select thread.State@12 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0) RUNNING) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t@@0 Int) ) (!  (=> (= (select thread.State@12 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t@@0) UNUSED) (= (select shadow.Lock@16 (ShadowableTid inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t@@0)) nil))
 :qid |unknown.0:0|
 :skolemid |36|
))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct  (=> (and (and (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@11 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |337|
)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0)) (and (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 Civl_global_old_shadow.Lock@2) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t Int) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 (ShadowableTid inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t)) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0) (= (select Civl_global_old_thread.State@2 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t) (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.thread.State@0 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t)))
 :qid |unknown.0:0|
 :skolemid |37|
)))) (and (=> (= (ControlFlow 0 5) (- 0 7)) (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0)) (=> (ValidTid inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0) (and (=> (= (ControlFlow 0 5) (- 0 6)) (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 shadow.Lock@16)) (=> (LocksPreserved inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 shadow.Lock@16) (=> (= (ControlFlow 0 5) (- 0 4)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t@@0 Int) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 (ShadowableTid inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t@@0)) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0) (= (select thread.State@12 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t@@0) (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.thread.State@0 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t@@0)))
 :qid |unknown.0:0|
 :skolemid |37|
))))))))))
(let ((anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@1) (=> (and (and (= thread.State@12 thread.State@1) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 177) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 177) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 177) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 177) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon9_LoopDone_correct  (=> (not ok@0) (and (=> (= (ControlFlow 0 178) 174) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 178) 177) anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon12_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@13) (=> (and (and (= thread.State@12 thread.State@1) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 134) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 134) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 134) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 134) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon13_Then_1$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@10) (=> (and (and (= thread.State@12 thread.State@8) (= Civl_global_old_shadow.Lock@2 shadow.Lock@10)) (and (= Civl_global_old_thread.State@2 thread.State@8) (= Civl_linear_tid_available@11 Civl_linear_tid_available@7))) (and (and (and (=> (= (ControlFlow 0 104) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 104) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 104) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 104) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@1) (=> (and (and (= thread.State@12 thread.State@1) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 102) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 102) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 102) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 102) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon14_Then_1$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@7) (=> (and (and (= thread.State@12 thread.State@5) (= Civl_global_old_shadow.Lock@2 shadow.Lock@7)) (and (= Civl_global_old_thread.State@2 thread.State@5) (= Civl_linear_tid_available@11 Civl_linear_tid_available@5))) (and (and (and (=> (= (ControlFlow 0 63) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 63) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 63) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 63) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon14_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@6) (=> (and (and (= thread.State@12 thread.State@4) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 61) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 61) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 61) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 61) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon8_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@15) (=> (and (and (= thread.State@12 thread.State@11) (= Civl_global_old_shadow.Lock@2 Civl_global_old_shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 Civl_global_old_thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@10))) (and (and (and (=> (= (ControlFlow 0 30) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 30) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 30) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 30) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon10_Then$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@1) (= thread.State@11 thread.State@1)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_thread.State@1 thread.State@1)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@2) (= ok@1 inline$AtomicWrite$0$ok@2))) (and (and (=> (= (ControlFlow 0 162) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 162) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 162) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicWrite$0$SharedWriteRace_correct  (=> (and (and (= (select sx.R@1 x@1) SHARED) (not (forall ((inline$AtomicWrite$0$j Int) ) (!  (=> (and (and (<= 0 inline$AtomicWrite$0$j) (< inline$AtomicWrite$0$j (q@max (VCArrayLen (select shadow.VC@1 inline$AtomicWrite$0$st@2)) (VCArrayLen (select shadow.VC@1 inline$AtomicWrite$0$sx@2))))) (f inline$AtomicWrite$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$sx@2) inline$AtomicWrite$0$j) (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) inline$AtomicWrite$0$j)))
 :qid |unknown.0:0|
 :skolemid |35|
 :pattern ( (f inline$AtomicWrite$0$j))
)))) (and (= inline$AtomicWrite$0$ok@2 false) (= (ControlFlow 0 168) 162))) anon10_Then$1_correct)))
(let ((inline$AtomicWrite$0$ReadWriteRace_correct  (=> (and (and (not (= (select sx.R@1 x@1) SHARED)) (not (EpochLeq (select sx.R@1 x@1) (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.R@1 x@1)))))) (and (= inline$AtomicWrite$0$ok@2 false) (= (ControlFlow 0 167) 162))) anon10_Then$1_correct)))
(let ((inline$AtomicWrite$0$WriteWriteRace_correct  (=> (not (EpochLeq (select sx.W@1 x@1) (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1))))) (=> (and (= inline$AtomicWrite$0$ok@2 false) (= (ControlFlow 0 166) 162)) anon10_Then$1_correct))))
(let ((inline$AtomicWrite$0$WritedShared_correct  (=> (and (EpochLeq (select sx.W@1 x@1) (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1)))) (= (select sx.R@1 x@1) SHARED)) (=> (and (and (forall ((inline$AtomicWrite$0$j@@0 Int) ) (!  (=> (and (and (<= 0 inline$AtomicWrite$0$j@@0) (< inline$AtomicWrite$0$j@@0 (q@max (VCArrayLen (select shadow.VC@1 inline$AtomicWrite$0$sx@2)) (VCArrayLen (select shadow.VC@1 inline$AtomicWrite$0$st@2))))) (f inline$AtomicWrite$0$j@@0)) (EpochLeq (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$sx@2) inline$AtomicWrite$0$j@@0) (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) inline$AtomicWrite$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |34|
 :pattern ( (f inline$AtomicWrite$0$j@@0))
)) (= sx.W@10 (store sx.W@1 x@1 (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) tid@@3)))) (and (= inline$AtomicWrite$0$ok@2 true) (= (ControlFlow 0 165) 162))) anon10_Then$1_correct))))
(let ((inline$AtomicWrite$0$WriteExclusive_correct  (=> (and (EpochLeq (select sx.W@1 x@1) (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1)))) (not (= (select sx.R@1 x@1) SHARED))) (=> (and (and (EpochLeq (select sx.R@1 x@1) (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.R@1 x@1)))) (= sx.W@9 (store sx.W@1 x@1 (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) tid@@3)))) (and (= inline$AtomicWrite$0$ok@2 true) (= (ControlFlow 0 164) 162))) anon10_Then$1_correct))))
(let ((inline$AtomicWrite$0$WriteFastPath_correct  (=> (= (select sx.W@1 x@1) (VCArrayGet (select shadow.VC@1 inline$AtomicWrite$0$st@2) tid@@3)) (=> (and (= inline$AtomicWrite$0$ok@2 true) (= (ControlFlow 0 163) 162)) anon10_Then$1_correct))))
(let ((inline$AtomicWrite$0$anon0_correct  (=> (and (and (Trigger_AtomicWrite_sx inline$AtomicWrite$0$sx@1) (Trigger_AtomicWrite_st inline$AtomicWrite$0$st@1)) (and (= inline$AtomicWrite$0$st@2 (ShadowableTid tid@@3)) (= inline$AtomicWrite$0$sx@2 (ShadowableVar x@1)))) (and (and (and (and (and (=> (= (ControlFlow 0 169) 163) inline$AtomicWrite$0$WriteFastPath_correct) (=> (= (ControlFlow 0 169) 164) inline$AtomicWrite$0$WriteExclusive_correct)) (=> (= (ControlFlow 0 169) 165) inline$AtomicWrite$0$WritedShared_correct)) (=> (= (ControlFlow 0 169) 166) inline$AtomicWrite$0$WriteWriteRace_correct)) (=> (= (ControlFlow 0 169) 167) inline$AtomicWrite$0$ReadWriteRace_correct)) (=> (= (ControlFlow 0 169) 168) inline$AtomicWrite$0$SharedWriteRace_correct)))))
(let ((anon10_Then_correct  (and (=> (= (ControlFlow 0 170) (- 0 171)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 170) 169) inline$AtomicWrite$0$anon0_correct)))))
(let ((anon11_Then$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@1) (= thread.State@11 thread.State@1)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_thread.State@1 thread.State@1)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@2) (= ok@1 inline$AtomicRead$0$ok@2))) (and (and (=> (= (ControlFlow 0 151) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 151) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 151) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicRead$0$WriteReadRace_correct  (=> (not (EpochLeq (select sx.W@1 x@2) (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2))))) (=> (and (= inline$AtomicRead$0$ok@2 false) (= (ControlFlow 0 157) 151)) anon11_Then$1_correct))))
(let ((inline$AtomicRead$0$ReadShare_correct  (=> (not (= (select sx.R@1 x@2) SHARED)) (=> (and (and (and (EpochLeq (select sx.W@1 x@2) (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2)))) (= shadow.VC@15 (store shadow.VC@1 inline$AtomicRead$0$sx@2 VC.bottom))) (and (= shadow.VC@16 (store shadow.VC@15 inline$AtomicRead$0$sx@2 (store (select shadow.VC@15 inline$AtomicRead$0$sx@2) (|tid#epoch| (select sx.R@1 x@2)) (select sx.R@1 x@2)))) (= shadow.VC@17 (store shadow.VC@16 inline$AtomicRead$0$sx@2 (store (select shadow.VC@16 inline$AtomicRead$0$sx@2) tid@@3 (VCArrayGet (select shadow.VC@16 inline$AtomicRead$0$st@2) tid@@3)))))) (and (and (= shadow.VC@18 (store shadow.VC@17 inline$AtomicRead$0$sx@2 (VCArraySetLen (select shadow.VC@17 inline$AtomicRead$0$sx@2) (q@max (+ (|tid#epoch| (select sx.R@1 x@2)) 1) (+ tid@@3 1))))) (= sx.R@10 (store sx.R@1 x@2 SHARED))) (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 156) 151)))) anon11_Then$1_correct))))
(let ((inline$AtomicRead$0$ReadShared_correct  (=> (and (= (select sx.R@1 x@2) SHARED) (EpochLeq (select sx.W@1 x@2) (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2))))) (=> (and (and (= shadow.VC@13 (store shadow.VC@1 inline$AtomicRead$0$sx@2 (store (select shadow.VC@1 inline$AtomicRead$0$sx@2) tid@@3 (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) tid@@3)))) (= shadow.VC@14 (store shadow.VC@13 inline$AtomicRead$0$sx@2 (VCArraySetLen (select shadow.VC@13 inline$AtomicRead$0$sx@2) (q@max (VCArrayLen (select shadow.VC@13 inline$AtomicRead$0$sx@2)) (+ tid@@3 1)))))) (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 155) 151))) anon11_Then$1_correct))))
(let ((inline$AtomicRead$0$ReadExclusive_correct  (=> (and (not (= (select sx.R@1 x@2) SHARED)) (EpochLeq (select sx.W@1 x@2) (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2))))) (=> (and (and (EpochLeq (select sx.R@1 x@2) (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.R@1 x@2)))) (= sx.R@9 (store sx.R@1 x@2 (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) tid@@3)))) (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 154) 151))) anon11_Then$1_correct))))
(let ((inline$AtomicRead$0$ReadSharedSameEpoch_correct  (=> (and (and (= (select sx.R@1 x@2) SHARED) (= (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$sx@2) tid@@3) (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) tid@@3))) (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 153) 151))) anon11_Then$1_correct)))
(let ((inline$AtomicRead$0$ReadSameEpoch_correct  (=> (= (select sx.R@1 x@2) (VCArrayGet (select shadow.VC@1 inline$AtomicRead$0$st@2) tid@@3)) (=> (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 152) 151)) anon11_Then$1_correct))))
(let ((inline$AtomicRead$0$anon0_correct  (=> (and (and (Trigger_AtomicRead_sx inline$AtomicRead$0$sx@1) (Trigger_AtomicRead_st inline$AtomicRead$0$st@1)) (and (= inline$AtomicRead$0$st@2 (ShadowableTid tid@@3)) (= inline$AtomicRead$0$sx@2 (ShadowableVar x@2)))) (and (and (and (and (and (=> (= (ControlFlow 0 158) 152) inline$AtomicRead$0$ReadSameEpoch_correct) (=> (= (ControlFlow 0 158) 153) inline$AtomicRead$0$ReadSharedSameEpoch_correct)) (=> (= (ControlFlow 0 158) 154) inline$AtomicRead$0$ReadExclusive_correct)) (=> (= (ControlFlow 0 158) 155) inline$AtomicRead$0$ReadShared_correct)) (=> (= (ControlFlow 0 158) 156) inline$AtomicRead$0$ReadShare_correct)) (=> (= (ControlFlow 0 158) 157) inline$AtomicRead$0$WriteReadRace_correct)))))
(let ((anon11_Then_correct  (and (=> (= (ControlFlow 0 159) (- 0 161)) (and (and (not (= tid@@3 nil)) (>= tid@@3 0)) (>= tid@@3 0))) (=> (and (and (not (= tid@@3 nil)) (>= tid@@3 0)) (>= tid@@3 0)) (and (=> (= (ControlFlow 0 159) (- 0 160)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 159) 158) inline$AtomicRead$0$anon0_correct)))))))
(let ((anon12_Then_0$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@14) (= thread.State@11 thread.State@10)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@14) (= Civl_global_old_thread.State@1 thread.State@10)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@9) (= ok@1 ok@0))) (and (and (=> (= (ControlFlow 0 136) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 136) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 136) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicAcquire$0$anon0_correct  (=> (Trigger_AtomicAcquire_v2 inline$AtomicAcquire$0$v2@1) (=> (and (and (and (Trigger_AtomicAcquire_v1 inline$AtomicAcquire$0$v1@1) (= inline$AtomicAcquire$0$v1@2 (ShadowableTid tid@@3))) (and (= inline$AtomicAcquire$0$v2@2 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) (VCRepOk (select shadow.VC@12 inline$AtomicAcquire$0$v1@2)))) (and (and (= (VCArrayLen (select shadow.VC@12 inline$AtomicAcquire$0$v1@2)) (q@max (VCArrayLen (select shadow.VC@11 inline$AtomicAcquire$0$v1@2)) (VCArrayLen (select shadow.VC@11 inline$AtomicAcquire$0$v2@2)))) (forall ((inline$AtomicAcquire$0$j Int) ) (!  (=> (<= 0 inline$AtomicAcquire$0$j) (= (VCArrayGet (select shadow.VC@12 inline$AtomicAcquire$0$v1@2) inline$AtomicAcquire$0$j) (EpochMax (VCArrayGet (select shadow.VC@11 inline$AtomicAcquire$0$v1@2) inline$AtomicAcquire$0$j) (VCArrayGet (select shadow.VC@11 inline$AtomicAcquire$0$v2@2) inline$AtomicAcquire$0$j))))
 :qid |unknown.0:0|
 :skolemid |31|
))) (and (= shadow.VC@12 (store shadow.VC@11 inline$AtomicAcquire$0$v1@2 (select shadow.VC@12 inline$AtomicAcquire$0$v1@2))) (= (ControlFlow 0 137) 136)))) anon12_Then_0$1_correct))))
(let ((anon12_Then_0_correct  (and (=> (= (ControlFlow 0 138) (- 0 147)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 138) (- 0 146)) (= (select thread.State@1 tid@@3) RUNNING)) (=> (= (select thread.State@1 tid@@3) RUNNING) (and (=> (= (ControlFlow 0 138) (- 0 145)) (forall ((t@@0 Int) ) (!  (=> (= (select thread.State@1 t@@0) UNUSED) (= (select shadow.Lock@13 (ShadowableTid t@@0)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@1 Int) ) (!  (=> (= (select thread.State@1 t@@1) UNUSED) (= (select shadow.Lock@13 (ShadowableTid t@@1)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 138) (- 0 144)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 138) (- 0 143)) (LocksPreserved tid@@3 shadow.Lock@13 shadow.Lock@13)) (=> (LocksPreserved tid@@3 shadow.Lock@13 shadow.Lock@13) (and (=> (= (ControlFlow 0 138) (- 0 142)) (forall ((t@@2 Int) ) (!  (=> (= (select shadow.Lock@13 (ShadowableTid t@@2)) tid@@3) (= (select thread.State@1 t@@2) (select thread.State@1 t@@2)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@3 Int) ) (!  (=> (= (select shadow.Lock@13 (ShadowableTid t@@3)) tid@@3) (= (select thread.State@1 t@@3) (select thread.State@1 t@@3)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
)) (=> (and (and (and (ValidTid tid@@3) (= (select thread.State@10 tid@@3) RUNNING)) (and (forall ((t@@4 Int) ) (!  (=> (= (select thread.State@10 t@@4) UNUSED) (= (select shadow.Lock@14 (ShadowableTid t@@4)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (ValidTid tid@@3))) (and (and (LocksPreserved tid@@3 shadow.Lock@13 shadow.Lock@14) (forall ((t@@5 Int) ) (!  (=> (= (select shadow.Lock@13 (ShadowableTid t@@5)) tid@@3) (= (select thread.State@10 t@@5) (select thread.State@1 t@@5)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@9 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 138) (- 0 141)) (= (select shadow.Lock@14 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@14 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 138) (- 0 140)) (= (select shadow.Lock@14 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) tid@@3)) (=> (= (select shadow.Lock@14 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) tid@@3) (and (=> (= (ControlFlow 0 138) (- 0 139)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 138) 137) inline$AtomicAcquire$0$anon0_correct))))))))))))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (and (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) nil) (= shadow.Lock@13 (store shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1) tid@@3))) (and (and (=> (= (ControlFlow 0 148) 138) anon12_Then_0_correct) (=> (= (ControlFlow 0 148) 134) anon12_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 148) 135) anon12_Then$1_@2_Civl_UnchangedChecker_correct)))))
(let ((anon12_Then_correct  (and (=> (= (ControlFlow 0 149) (- 0 150)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 149) 148) inline$AtomicChooseLockToAcquire$0$anon0_correct)))))
(let ((anon13_Then_0$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@12) (= thread.State@11 thread.State@9)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@11) (= Civl_global_old_thread.State@1 thread.State@9)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@8) (= ok@1 ok@0))) (and (and (=> (= (ControlFlow 0 106) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 106) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 106) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@12 (store shadow.Lock@11 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1) nil)) (= (ControlFlow 0 107) 106)) anon13_Then_0$1_correct)))
(let ((anon13_Then_0_correct  (and (=> (= (ControlFlow 0 108) (- 0 116)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 108) (- 0 115)) (= (select thread.State@8 tid@@3) RUNNING)) (=> (= (select thread.State@8 tid@@3) RUNNING) (and (=> (= (ControlFlow 0 108) (- 0 114)) (forall ((t@@6 Int) ) (!  (=> (= (select thread.State@8 t@@6) UNUSED) (= (select shadow.Lock@10 (ShadowableTid t@@6)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@7 Int) ) (!  (=> (= (select thread.State@8 t@@7) UNUSED) (= (select shadow.Lock@10 (ShadowableTid t@@7)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 108) (- 0 113)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 108) (- 0 112)) (LocksPreserved tid@@3 shadow.Lock@10 shadow.Lock@10)) (=> (LocksPreserved tid@@3 shadow.Lock@10 shadow.Lock@10) (and (=> (= (ControlFlow 0 108) (- 0 111)) (forall ((t@@8 Int) ) (!  (=> (= (select shadow.Lock@10 (ShadowableTid t@@8)) tid@@3) (= (select thread.State@8 t@@8) (select thread.State@8 t@@8)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@9 Int) ) (!  (=> (= (select shadow.Lock@10 (ShadowableTid t@@9)) tid@@3) (= (select thread.State@8 t@@9) (select thread.State@8 t@@9)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
)) (=> (and (and (and (ValidTid tid@@3) (= (select thread.State@9 tid@@3) RUNNING)) (and (forall ((t@@10 Int) ) (!  (=> (= (select thread.State@9 t@@10) UNUSED) (= (select shadow.Lock@11 (ShadowableTid t@@10)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (ValidTid tid@@3))) (and (and (LocksPreserved tid@@3 shadow.Lock@10 shadow.Lock@11) (forall ((t@@11 Int) ) (!  (=> (= (select shadow.Lock@10 (ShadowableTid t@@11)) tid@@3) (= (select thread.State@9 t@@11) (select thread.State@8 t@@11)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@8 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 108) (- 0 110)) (= (select shadow.Lock@11 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3)) (=> (= (select shadow.Lock@11 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3) (and (=> (= (ControlFlow 0 108) (- 0 109)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 108) 107) inline$AtomicReleaseChosenLock$0$anon0_correct))))))))))))))))))))
(let ((inline$AtomicRelease$0$anon3_correct  (=> (VCRepOk (select shadow.VC@9 inline$AtomicRelease$0$v2@2)) (=> (and (and (= (VCArrayLen (select shadow.VC@9 inline$AtomicRelease$0$v2@2)) (q@max (VCArrayLen (select shadow.VC@9 inline$AtomicRelease$0$v2@2)) (+ tid@@3 1))) (forall ((inline$AtomicRelease$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicRelease$0$j) (not (= inline$AtomicRelease$0$j tid@@3))) (= (VCArrayGet (select shadow.VC@9 inline$AtomicRelease$0$v2@2) inline$AtomicRelease$0$j) (VCArrayGet (select shadow.VC@8 inline$AtomicRelease$0$v2@2) inline$AtomicRelease$0$j)))
 :qid |unknown.0:0|
 :skolemid |33|
))) (and (= (VCArrayGet (select shadow.VC@9 inline$AtomicRelease$0$v2@2) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@8 inline$AtomicRelease$0$v2@2) tid@@3))) (= shadow.VC@9 (store (store shadow.VC@8 inline$AtomicRelease$0$v1@2 (select shadow.VC@9 inline$AtomicRelease$0$v1@2)) inline$AtomicRelease$0$v2@2 (select shadow.VC@9 inline$AtomicRelease$0$v2@2))))) (and (and (=> (= (ControlFlow 0 117) 108) anon13_Then_0_correct) (=> (= (ControlFlow 0 117) 104) anon13_Then_1$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 117) 105) anon13_Then_1$1_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicRelease$0$anon4_Else_correct  (=> (and (= (select shadow.VC@9 inline$AtomicRelease$0$v1@2) (select shadow.VC@8 inline$AtomicRelease$0$v2@2)) (= (ControlFlow 0 119) 117)) inline$AtomicRelease$0$anon3_correct)))
(let ((inline$AtomicRelease$0$anon4_Then_correct  (=> (and (and (VCRepOk (select shadow.VC@9 inline$AtomicRelease$0$v1@2)) (= (VCArrayLen (select shadow.VC@9 inline$AtomicRelease$0$v1@2)) (q@max (VCArrayLen (select shadow.VC@8 inline$AtomicRelease$0$v1@2)) (VCArrayLen (select shadow.VC@8 inline$AtomicRelease$0$v2@2))))) (and (forall ((inline$AtomicRelease$0$j@@0 Int) ) (!  (=> (<= 0 inline$AtomicRelease$0$j@@0) (= (VCArrayGet (select shadow.VC@9 inline$AtomicRelease$0$v1@2) inline$AtomicRelease$0$j@@0) (VCArrayGet (select shadow.VC@8 inline$AtomicRelease$0$v2@2) inline$AtomicRelease$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |32|
)) (= (ControlFlow 0 118) 117))) inline$AtomicRelease$0$anon3_correct)))
(let ((inline$AtomicRelease$0$anon0_correct  (=> (and (and (Trigger_AtomicRelease_v2 inline$AtomicRelease$0$v2@1) (Trigger_AtomicRelease_v1 inline$AtomicRelease$0$v1@1)) (and (= inline$AtomicRelease$0$v1@2 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) (= inline$AtomicRelease$0$v2@2 (ShadowableTid tid@@3)))) (and (=> (= (ControlFlow 0 120) 118) inline$AtomicRelease$0$anon4_Then_correct) (=> (= (ControlFlow 0 120) 119) inline$AtomicRelease$0$anon4_Else_correct)))))
(let ((anon13_Then_1_correct  (and (=> (= (ControlFlow 0 121) (- 0 130)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 121) (- 0 129)) (= (select thread.State@1 tid@@3) RUNNING)) (=> (= (select thread.State@1 tid@@3) RUNNING) (and (=> (= (ControlFlow 0 121) (- 0 128)) (forall ((t@@12 Int) ) (!  (=> (= (select thread.State@1 t@@12) UNUSED) (= (select shadow.Lock@1 (ShadowableTid t@@12)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@13 Int) ) (!  (=> (= (select thread.State@1 t@@13) UNUSED) (= (select shadow.Lock@1 (ShadowableTid t@@13)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 121) (- 0 127)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 121) (- 0 126)) (LocksPreserved tid@@3 shadow.Lock@1 shadow.Lock@1)) (=> (LocksPreserved tid@@3 shadow.Lock@1 shadow.Lock@1) (and (=> (= (ControlFlow 0 121) (- 0 125)) (forall ((t@@14 Int) ) (!  (=> (= (select shadow.Lock@1 (ShadowableTid t@@14)) tid@@3) (= (select thread.State@1 t@@14) (select thread.State@1 t@@14)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@15 Int) ) (!  (=> (= (select shadow.Lock@1 (ShadowableTid t@@15)) tid@@3) (= (select thread.State@1 t@@15) (select thread.State@1 t@@15)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
)) (=> (and (and (and (ValidTid tid@@3) (= (select thread.State@8 tid@@3) RUNNING)) (and (forall ((t@@16 Int) ) (!  (=> (= (select thread.State@8 t@@16) UNUSED) (= (select shadow.Lock@10 (ShadowableTid t@@16)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (ValidTid tid@@3))) (and (and (LocksPreserved tid@@3 shadow.Lock@1 shadow.Lock@10) (forall ((t@@17 Int) ) (!  (=> (= (select shadow.Lock@1 (ShadowableTid t@@17)) tid@@3) (= (select thread.State@8 t@@17) (select thread.State@1 t@@17)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@7 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 121) (- 0 124)) (= (select shadow.Lock@10 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3)) (=> (= (select shadow.Lock@10 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3) (and (=> (= (ControlFlow 0 121) (- 0 123)) (= (select shadow.Lock@10 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@10 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 121) (- 0 122)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 121) 120) inline$AtomicRelease$0$anon0_correct))))))))))))))))))))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid@@3) (and (and (=> (= (ControlFlow 0 131) 121) anon13_Then_1_correct) (=> (= (ControlFlow 0 131) 102) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 131) 103) anon13_Then$1_@2_Civl_UnchangedChecker_correct)))))
(let ((anon13_Then_correct  (and (=> (= (ControlFlow 0 132) (- 0 133)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 132) 131) inline$AtomicChooseLockToRelease$0$anon0_correct)))))
(let ((anon14_Then_0$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@9) (= thread.State@11 thread.State@7)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@8) (= Civl_global_old_thread.State@1 thread.State@6)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@6) (= ok@1 ok@0))) (and (and (=> (= (ControlFlow 0 65) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 65) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 65) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@7 (store thread.State@6 inline$AtomicAllocTid$0$uid@1 RUNNING)) (=> (and (= shadow.Lock@9 (store shadow.Lock@8 (ShadowableTid inline$AtomicAllocTid$0$uid@1) inline$AtomicAllocTid$0$uid@1)) (= (ControlFlow 0 66) 65)) anon14_Then_0$1_correct))))
(let ((anon14_Then_0_correct  (and (=> (= (ControlFlow 0 67) (- 0 78)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 67) (- 0 77)) (= (select thread.State@5 tid@@3) RUNNING)) (=> (= (select thread.State@5 tid@@3) RUNNING) (and (=> (= (ControlFlow 0 67) (- 0 76)) (forall ((t@@18 Int) ) (!  (=> (= (select thread.State@5 t@@18) UNUSED) (= (select shadow.Lock@7 (ShadowableTid t@@18)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@19 Int) ) (!  (=> (= (select thread.State@5 t@@19) UNUSED) (= (select shadow.Lock@7 (ShadowableTid t@@19)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 67) (- 0 75)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 67) (- 0 74)) (LocksPreserved tid@@3 shadow.Lock@7 shadow.Lock@7)) (=> (LocksPreserved tid@@3 shadow.Lock@7 shadow.Lock@7) (and (=> (= (ControlFlow 0 67) (- 0 73)) (forall ((t@@20 Int) ) (!  (=> (= (select shadow.Lock@7 (ShadowableTid t@@20)) tid@@3) (= (select thread.State@5 t@@20) (select thread.State@5 t@@20)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@21 Int) ) (!  (=> (= (select shadow.Lock@7 (ShadowableTid t@@21)) tid@@3) (= (select thread.State@5 t@@21) (select thread.State@5 t@@21)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
)) (=> (and (and (and (ValidTid tid@@3) (= (select thread.State@6 tid@@3) RUNNING)) (and (forall ((t@@22 Int) ) (!  (=> (= (select thread.State@6 t@@22) UNUSED) (= (select shadow.Lock@8 (ShadowableTid t@@22)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (ValidTid tid@@3))) (and (and (LocksPreserved tid@@3 shadow.Lock@7 shadow.Lock@8) (forall ((t@@23 Int) ) (!  (=> (= (select shadow.Lock@7 (ShadowableTid t@@23)) tid@@3) (= (select thread.State@6 t@@23) (select thread.State@5 t@@23)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@6 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 67) (- 0 72)) (= (select thread.State@6 inline$AtomicAllocTid$0$uid@1) NEW)) (=> (= (select thread.State@6 inline$AtomicAllocTid$0$uid@1) NEW) (and (=> (= (ControlFlow 0 67) (- 0 71)) (= (select shadow.Lock@8 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3)) (=> (= (select shadow.Lock@8 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3) (and (=> (= (ControlFlow 0 67) (- 0 70)) (not (= tid@@3 inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 67) (- 0 69)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (=> (ValidTid inline$AtomicAllocTid$0$uid@1) (and (=> (= (ControlFlow 0 67) (- 0 68)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 67) 66) inline$AtomicStartThread$0$anon0_correct))))))))))))))))))))))))))
(let ((inline$AtomicFork$0$anon0_correct  (=> (and (and (Trigger_AtomicFork_v2 inline$AtomicFork$0$v2@1) (Trigger_AtomicFork_v1 inline$AtomicFork$0$v1@1)) (and (= inline$AtomicFork$0$v1@2 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) (= inline$AtomicFork$0$v2@2 (ShadowableTid tid@@3)))) (=> (and (and (and (= (VCArrayLen (select shadow.VC@6 inline$AtomicFork$0$v1@2)) (q@max (VCArrayLen (select shadow.VC@5 inline$AtomicFork$0$v1@2)) (VCArrayLen (select shadow.VC@5 inline$AtomicFork$0$v2@2)))) (VCRepOk (select shadow.VC@6 inline$AtomicFork$0$v1@2))) (and (forall ((inline$AtomicFork$0$j Int) ) (!  (=> (<= 0 inline$AtomicFork$0$j) (= (VCArrayGet (select shadow.VC@6 inline$AtomicFork$0$v1@2) inline$AtomicFork$0$j) (EpochMax (VCArrayGet (select shadow.VC@5 inline$AtomicFork$0$v1@2) inline$AtomicFork$0$j) (VCArrayGet (select shadow.VC@5 inline$AtomicFork$0$v2@2) inline$AtomicFork$0$j))))
 :qid |unknown.0:0|
 :skolemid |28|
)) (VCRepOk (select shadow.VC@6 inline$AtomicFork$0$v2@2)))) (and (and (= (VCArrayLen (select shadow.VC@6 inline$AtomicFork$0$v2@2)) (q@max (VCArrayLen (select shadow.VC@6 inline$AtomicFork$0$v2@2)) (+ tid@@3 1))) (forall ((inline$AtomicFork$0$j@@0 Int) ) (!  (=> (and (<= 0 inline$AtomicFork$0$j@@0) (not (= inline$AtomicFork$0$j@@0 tid@@3))) (= (VCArrayGet (select shadow.VC@6 inline$AtomicFork$0$v2@2) inline$AtomicFork$0$j@@0) (VCArrayGet (select shadow.VC@5 inline$AtomicFork$0$v2@2) inline$AtomicFork$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |29|
))) (and (= (VCArrayGet (select shadow.VC@6 inline$AtomicFork$0$v2@2) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@5 inline$AtomicFork$0$v2@2) tid@@3))) (= shadow.VC@6 (store (store shadow.VC@5 inline$AtomicFork$0$v1@2 (select shadow.VC@6 inline$AtomicFork$0$v1@2)) inline$AtomicFork$0$v2@2 (select shadow.VC@6 inline$AtomicFork$0$v2@2)))))) (and (and (=> (= (ControlFlow 0 79) 67) anon14_Then_0_correct) (=> (= (ControlFlow 0 79) 63) anon14_Then_1$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 79) 64) anon14_Then_1$1_@2_Civl_UnchangedChecker_correct))))))
(let ((anon14_Then_1_correct  (and (=> (= (ControlFlow 0 80) (- 0 93)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 80) (- 0 92)) (= (select thread.State@4 tid@@3) RUNNING)) (=> (= (select thread.State@4 tid@@3) RUNNING) (and (=> (= (ControlFlow 0 80) (- 0 91)) (forall ((t@@24 Int) ) (!  (=> (= (select thread.State@4 t@@24) UNUSED) (= (select shadow.Lock@6 (ShadowableTid t@@24)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@25 Int) ) (!  (=> (= (select thread.State@4 t@@25) UNUSED) (= (select shadow.Lock@6 (ShadowableTid t@@25)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 80) (- 0 90)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 80) (- 0 89)) (LocksPreserved tid@@3 shadow.Lock@6 shadow.Lock@6)) (=> (LocksPreserved tid@@3 shadow.Lock@6 shadow.Lock@6) (and (=> (= (ControlFlow 0 80) (- 0 88)) (forall ((t@@26 Int) ) (!  (=> (= (select shadow.Lock@6 (ShadowableTid t@@26)) tid@@3) (= (select thread.State@4 t@@26) (select thread.State@4 t@@26)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@27 Int) ) (!  (=> (= (select shadow.Lock@6 (ShadowableTid t@@27)) tid@@3) (= (select thread.State@4 t@@27) (select thread.State@4 t@@27)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
)) (=> (and (and (and (ValidTid tid@@3) (= (select thread.State@5 tid@@3) RUNNING)) (and (forall ((t@@28 Int) ) (!  (=> (= (select thread.State@5 t@@28) UNUSED) (= (select shadow.Lock@7 (ShadowableTid t@@28)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (ValidTid tid@@3))) (and (and (LocksPreserved tid@@3 shadow.Lock@6 shadow.Lock@7) (forall ((t@@29 Int) ) (!  (=> (= (select shadow.Lock@6 (ShadowableTid t@@29)) tid@@3) (= (select thread.State@5 t@@29) (select thread.State@4 t@@29)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@5 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 80) (- 0 87)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 80) (- 0 86)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (=> (ValidTid inline$AtomicAllocTid$0$uid@1) (and (=> (= (ControlFlow 0 80) (- 0 85)) (not (= tid@@3 inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 80) (- 0 84)) (= (select shadow.Lock@7 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3)) (=> (= (select shadow.Lock@7 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid@@3) (and (=> (= (ControlFlow 0 80) (- 0 83)) (= (select shadow.Lock@7 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@7 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 80) (- 0 82)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (=> (ValidTid inline$AtomicAllocTid$0$uid@1) (and (=> (= (ControlFlow 0 80) (- 0 81)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 80) 79) inline$AtomicFork$0$anon0_correct))))))))))))))))))))))))))))))
(let ((anon14_Then$1_correct  (and (=> (= (ControlFlow 0 94) (- 0 97)) (not (= tid@@3 inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 94) (- 0 96)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 94) (- 0 95)) (ValidTid inline$AtomicAllocTid$0$uid@1)) (=> (ValidTid inline$AtomicAllocTid$0$uid@1) (and (and (=> (= (ControlFlow 0 94) 80) anon14_Then_1_correct) (=> (= (ControlFlow 0 94) 61) anon14_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 94) 62) anon14_Then$1_@2_Civl_UnchangedChecker_correct))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicAllocTid$0$uid@1) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@1)) (= thread.State@4 (store thread.State@1 inline$AtomicAllocTid$0$uid@1 NEW))) (and (and (= thread.ForkedBy@4 (store thread.ForkedBy@1 inline$AtomicAllocTid$0$uid@1 tid@@3)) (= shadow.Lock@6 (store shadow.Lock@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1) tid@@3))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1))) (= (ControlFlow 0 98) 94)))) anon14_Then$1_correct))))
(let ((anon14_Then_correct  (and (=> (= (ControlFlow 0 99) (- 0 101)) (forall ((t@@30 Int) ) (!  (=> (= (select thread.State@1 t@@30) UNUSED) (= (select shadow.Lock@1 (ShadowableTid t@@30)) nil))
 :qid |verifiedftdefinebpl.1025:20|
 :skolemid |39|
))) (=> (forall ((t@@31 Int) ) (!  (=> (= (select thread.State@1 t@@31) UNUSED) (= (select shadow.Lock@1 (ShadowableTid t@@31)) nil))
 :qid |verifiedftdefinebpl.1025:20|
 :skolemid |39|
)) (and (=> (= (ControlFlow 0 99) (- 0 100)) (and (= (select thread.State@1 tid@@3) RUNNING) (ValidTid tid@@3))) (=> (and (= (select thread.State@1 tid@@3) RUNNING) (ValidTid tid@@3)) (=> (= (ControlFlow 0 99) 98) inline$AtomicAllocTid$0$anon0_correct)))))))
(let ((anon14_Else_0$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@5) (= thread.State@11 thread.State@3)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@4) (= Civl_global_old_thread.State@1 thread.State@3)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@4) (= ok@1 ok@0))) (and (and (=> (= (ControlFlow 0 32) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 32) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 32) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@5 (store shadow.Lock@4 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) nil)) (= (ControlFlow 0 33) 32)) anon14_Else_0$1_correct)))
(let ((anon14_Else_0_correct  (and (=> (= (ControlFlow 0 34) (- 0 44)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 34) (- 0 43)) (= (select thread.State@2 tid@@3) RUNNING)) (=> (= (select thread.State@2 tid@@3) RUNNING) (and (=> (= (ControlFlow 0 34) (- 0 42)) (forall ((t@@32 Int) ) (!  (=> (= (select thread.State@2 t@@32) UNUSED) (= (select shadow.Lock@3 (ShadowableTid t@@32)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@33 Int) ) (!  (=> (= (select thread.State@2 t@@33) UNUSED) (= (select shadow.Lock@3 (ShadowableTid t@@33)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 34) (- 0 41)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 34) (- 0 40)) (LocksPreserved tid@@3 shadow.Lock@3 shadow.Lock@3)) (=> (LocksPreserved tid@@3 shadow.Lock@3 shadow.Lock@3) (and (=> (= (ControlFlow 0 34) (- 0 39)) (forall ((t@@34 Int) ) (!  (=> (= (select shadow.Lock@3 (ShadowableTid t@@34)) tid@@3) (= (select thread.State@2 t@@34) (select thread.State@2 t@@34)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@35 Int) ) (!  (=> (= (select shadow.Lock@3 (ShadowableTid t@@35)) tid@@3) (= (select thread.State@2 t@@35) (select thread.State@2 t@@35)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
)) (=> (and (and (and (ValidTid tid@@3) (= (select thread.State@3 tid@@3) RUNNING)) (and (forall ((t@@36 Int) ) (!  (=> (= (select thread.State@3 t@@36) UNUSED) (= (select shadow.Lock@4 (ShadowableTid t@@36)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (ValidTid tid@@3))) (and (and (LocksPreserved tid@@3 shadow.Lock@3 shadow.Lock@4) (forall ((t@@37 Int) ) (!  (=> (= (select shadow.Lock@3 (ShadowableTid t@@37)) tid@@3) (= (select thread.State@3 t@@37) (select thread.State@2 t@@37)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@4 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 34) (- 0 38)) (= (select shadow.Lock@4 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid@@3)) (=> (= (select shadow.Lock@4 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid@@3) (and (=> (= (ControlFlow 0 34) (- 0 37)) (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1))) (=> (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1)) (and (=> (= (ControlFlow 0 34) (- 0 36)) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1)) (=> (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1) (and (=> (= (ControlFlow 0 34) (- 0 35)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 34) 33) inline$AtomicReleaseJoinLock$0$anon0_correct))))))))))))))))))))))))
(let ((anon14_Else_1$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@3) (=> (and (and (= thread.State@12 thread.State@2) (= Civl_global_old_shadow.Lock@2 shadow.Lock@3)) (and (= Civl_global_old_thread.State@2 thread.State@2) (= Civl_linear_tid_available@11 Civl_linear_tid_available@3))) (and (and (and (=> (= (ControlFlow 0 22) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 22) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 22) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 22) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((inline$AtomicJoin$0$anon0_correct  (=> (and (and (and (Trigger_AtomicJoin_v2 inline$AtomicJoin$0$v2@1) (Trigger_AtomicJoin_v1 inline$AtomicJoin$0$v1@1)) (and (= inline$AtomicJoin$0$v1@2 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) (= inline$AtomicJoin$0$v2@2 (ShadowableTid tid@@3)))) (and (and (= (VCArrayLen (select shadow.VC@3 inline$AtomicJoin$0$v2@2)) (q@max (VCArrayLen (select shadow.VC@2 inline$AtomicJoin$0$v1@2)) (VCArrayLen (select shadow.VC@2 inline$AtomicJoin$0$v2@2)))) (VCRepOk (select shadow.VC@3 inline$AtomicJoin$0$v2@2))) (and (forall ((inline$AtomicJoin$0$j Int) ) (!  (=> (<= 0 inline$AtomicJoin$0$j) (= (VCArrayGet (select shadow.VC@3 inline$AtomicJoin$0$v2@2) inline$AtomicJoin$0$j) (EpochMax (VCArrayGet (select shadow.VC@2 inline$AtomicJoin$0$v2@2) inline$AtomicJoin$0$j) (VCArrayGet (select shadow.VC@2 inline$AtomicJoin$0$v1@2) inline$AtomicJoin$0$j))))
 :qid |unknown.0:0|
 :skolemid |30|
)) (= shadow.VC@3 (store shadow.VC@2 inline$AtomicJoin$0$v2@2 (select shadow.VC@3 inline$AtomicJoin$0$v2@2)))))) (and (and (=> (= (ControlFlow 0 45) 34) anon14_Else_0_correct) (=> (= (ControlFlow 0 45) 22) anon14_Else_1$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 45) 23) anon14_Else_1$1_@2_Civl_UnchangedChecker_correct)))))
(let ((anon14_Else_1_correct  (and (=> (= (ControlFlow 0 46) (- 0 57)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 46) (- 0 56)) (= (select thread.State@1 tid@@3) RUNNING)) (=> (= (select thread.State@1 tid@@3) RUNNING) (and (=> (= (ControlFlow 0 46) (- 0 55)) (forall ((t@@38 Int) ) (!  (=> (= (select thread.State@1 t@@38) UNUSED) (= (select shadow.Lock@2 (ShadowableTid t@@38)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@39 Int) ) (!  (=> (= (select thread.State@1 t@@39) UNUSED) (= (select shadow.Lock@2 (ShadowableTid t@@39)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 46) (- 0 54)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 46) (- 0 53)) (LocksPreserved tid@@3 shadow.Lock@2 shadow.Lock@2)) (=> (LocksPreserved tid@@3 shadow.Lock@2 shadow.Lock@2) (and (=> (= (ControlFlow 0 46) (- 0 52)) (forall ((t@@40 Int) ) (!  (=> (= (select shadow.Lock@2 (ShadowableTid t@@40)) tid@@3) (= (select thread.State@1 t@@40) (select thread.State@1 t@@40)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@41 Int) ) (!  (=> (= (select shadow.Lock@2 (ShadowableTid t@@41)) tid@@3) (= (select thread.State@1 t@@41) (select thread.State@1 t@@41)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
)) (=> (and (and (and (ValidTid tid@@3) (= (select thread.State@2 tid@@3) RUNNING)) (and (forall ((t@@42 Int) ) (!  (=> (= (select thread.State@2 t@@42) UNUSED) (= (select shadow.Lock@3 (ShadowableTid t@@42)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (ValidTid tid@@3))) (and (and (LocksPreserved tid@@3 shadow.Lock@2 shadow.Lock@3) (forall ((t@@43 Int) ) (!  (=> (= (select shadow.Lock@2 (ShadowableTid t@@43)) tid@@3) (= (select thread.State@2 t@@43) (select thread.State@1 t@@43)))
 :qid |verifiedftdefinebpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@3 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 46) (- 0 51)) (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1))) (=> (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1)) (and (=> (= (ControlFlow 0 46) (- 0 50)) (= (select shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid@@3)) (=> (= (select shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid@@3) (and (=> (= (ControlFlow 0 46) (- 0 49)) (= (select shadow.Lock@3 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@3 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 46) (- 0 48)) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1)) (=> (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1) (and (=> (= (ControlFlow 0 46) (- 0 47)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (=> (= (ControlFlow 0 46) 45) inline$AtomicJoin$0$anon0_correct))))))))))))))))))))))))))
(let ((anon14_Else$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@2) (=> (and (and (= thread.State@12 thread.State@1) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 17) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 17) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 17) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicChooseThreadToJoin$0$uid@1) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@1)) (= (select shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) nil)) (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) tid@@3)) (= thread.HasJoined@2 (store thread.HasJoined@1 tid@@3 inline$AtomicChooseThreadToJoin$0$uid@1 true)))) (and (and (=> (= (ControlFlow 0 58) 46) anon14_Else_1_correct) (=> (= (ControlFlow 0 58) 17) anon14_Else$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 58) 21) anon14_Else$1_@2_Civl_UnchangedChecker_correct))))))
(let ((anon14_Else_correct  (and (=> (= (ControlFlow 0 59) (- 0 60)) (and (= (select thread.State@1 tid@@3) RUNNING) (ValidTid tid@@3))) (=> (and (= (select thread.State@1 tid@@3) RUNNING) (ValidTid tid@@3)) (=> (= (ControlFlow 0 59) 58) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
(let ((anon9_LoopBody_correct  (=> ok@0 (and (and (and (and (and (=> (= (ControlFlow 0 172) 170) anon10_Then_correct) (=> (= (ControlFlow 0 172) 159) anon11_Then_correct)) (=> (= (ControlFlow 0 172) 149) anon12_Then_correct)) (=> (= (ControlFlow 0 172) 132) anon13_Then_correct)) (=> (= (ControlFlow 0 172) 99) anon14_Then_correct)) (=> (= (ControlFlow 0 172) 59) anon14_Else_correct)))))
(let ((anon9_LoopHead_correct  (=> (or false true) (=> (and (ValidTid tid@@3) (= (select shadow.Lock@1 (ShadowableTid tid@@3)) tid@@3)) (=> (and (and (ValidTid tid@@3) (= (select thread.State@1 tid@@3) RUNNING)) (and (forall ((t@@44 Int) ) (!  (=> (= (select thread.State@1 t@@44) UNUSED) (= (select shadow.Lock@1 (ShadowableTid t@@44)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 179) 178) anon9_LoopDone_correct) (=> (= (ControlFlow 0 179) 172) anon9_LoopBody_correct)))))))
(let ((anon0_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 180) (- 0 185)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 180) (- 0 184)) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3) (and (=> (= (ControlFlow 0 180) (- 0 183)) (ValidTid tid@@3)) (=> (ValidTid tid@@3) (and (=> (= (ControlFlow 0 180) (- 0 182)) (= (select thread.State@0 tid@@3) RUNNING)) (=> (= (select thread.State@0 tid@@3) RUNNING) (and (=> (= (ControlFlow 0 180) (- 0 181)) (forall ((t@@45 Int) ) (!  (=> (= (select thread.State@0 t@@45) UNUSED) (= (select shadow.Lock@0 (ShadowableTid t@@45)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@46 Int) ) (!  (=> (= (select thread.State@0 t@@46) UNUSED) (= (select shadow.Lock@0 (ShadowableTid t@@46)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (=> (= (ControlFlow 0 180) 179) anon9_LoopHead_correct)))))))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@0) (=> (and (and (= thread.State@12 thread.State@0) (= Civl_global_old_shadow.Lock@2 shadow.Lock@0)) (and (= Civl_global_old_thread.State@2 thread.State@0) (= Civl_linear_tid_available@11 Civl_linear_tid_available@0))) (and (and (and (=> (= (ControlFlow 0 16) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 16) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) true) (=> (= (ControlFlow 0 2) (- 0 1)) (=> false (= true ok))))))
(let ((anon0_correct  (=> (and (ValidTid tid@@3) (= (select shadow.Lock@0 (ShadowableTid tid@@3)) tid@@3)) (=> (and (and (ValidTid tid@@3) (= (select thread.State@0 tid@@3) RUNNING)) (and (forall ((t@@47 Int) ) (!  (=> (= (select thread.State@0 t@@47) UNUSED) (= (select shadow.Lock@0 (ShadowableTid t@@47)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 186) 180) anon0_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 186) 16) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 186) 2) Civl_RefinementChecker_correct))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (ValidTid tid@@3) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (=> (and (and (ValidTid tid@@3) (= (select thread.State tid@@3) RUNNING)) (and (forall ((t@@48 Int) ) (!  (=> (= (select thread.State t@@48) UNUSED) (= (select shadow.Lock (ShadowableTid t@@48)) nil))
 :qid |verifiedftdefinebpl.924:20|
 :skolemid |36|
)) (= (ControlFlow 0 187) 186))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun x@@3 () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar x@@3)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar x@@3) tid@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun x@@3 () T@Var)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar x@@3) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid tid@@3)) tid@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
inline$AtomicThreadStateGetE$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(declare-fun e@@1 () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateSetW)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateSetW$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@0 (store sx.W x@@3 e@@1)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetW$0$Return_correct)))
(let ((inline$AtomicVarStateSetW$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetW$0$anon0_correct))))
inline$AtomicVarStateSetW$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetW)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetW$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W x@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetW$0$Return_correct)))
(let ((inline$AtomicVarStateGetW$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetW$0$anon0_correct))))
inline$AtomicVarStateGetW$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicVarStateGetWNoLock$0$e@1 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetWNoLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetWNoLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetWNoLock$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetWNoLock$0$e@1 (select sx.W x@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetWNoLock$0$Return_correct)))
(let ((inline$AtomicVarStateGetWNoLock$0$Entry_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetWNoLock$0$anon0_correct)))
inline$AtomicVarStateGetWNoLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(declare-fun e@@1 () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateSetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R x@@3 e@@1)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (and (and (not (= (select sx.R x@@3) SHARED)) (= (select shadow.Lock (ShadowableVar x@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicVarStateSetR$0$anon0_correct)))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicVarStateGetRNoLock$0$e@1 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetRNoLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetRNoLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetRNoLock$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetRNoLock$0$e@1 (select sx.R x@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetRNoLock$0$Return_correct)))
(let ((inline$AtomicVarStateGetRNoLock$0$Entry_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetRNoLock$0$anon0_correct)))
inline$AtomicVarStateGetRNoLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetR$0$e@1 (select sx.R x@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetR$0$Return_correct)))
(let ((inline$AtomicVarStateGetR$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@3)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetR$0$anon0_correct))))
inline$AtomicVarStateGetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetRShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetRShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetRShared$0$anon0_correct  (=> (and (= (select sx.R x@@3) SHARED) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetRShared$0$Return_correct)))
(let ((inline$AtomicVarStateGetRShared$0$Entry_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetRShared$0$anon0_correct)))
inline$AtomicVarStateGetRShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun r@@3 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCGetSize)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCGetSize$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (VCArrayLen (select shadow.VC@@0 r@@3))) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetSize$0$Return_correct)))
(let ((inline$AtomicVCGetSize$0$Entry_correct  (=> (= (select shadow.Lock r@@3) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetSize$0$anon0_correct))))
inline$AtomicVCGetSize$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun r@@3 () T@Shadowable)
(declare-fun i@@2 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (VCArrayGet (select shadow.VC@@0 r@@3) i@@2)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= (select shadow.Lock r@@3) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
inline$AtomicVCGetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun x@@3 () T@Var)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (VCArrayGet (select shadow.VC@@0 (ShadowableVar x@@3)) tid@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (ValidTid tid@@3) (=> (and (= (select sx.R x@@3) SHARED) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
inline$AtomicVCGetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun x@@3 () T@Var)
(declare-fun e@@1 () T@Epoch)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar x@@3) (store (select shadow.VC@@0 (ShadowableVar x@@3)) tid@@3 e@@1))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar x@@3) (VCArraySetLen (select shadow.VC@0 (ShadowableVar x@@3)) (q@max (VCArrayLen (select shadow.VC@0 (ShadowableVar x@@3))) (+ tid@@3 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (and (= (select shadow.Lock (ShadowableVar x@@3)) tid@@3) (ValidTid tid@@3)) (and (= (select sx.R x@@3) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct)))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun r@@3 () T@Shadowable)
(declare-fun i@@2 () Int)
(declare-fun e@@1 () T@Epoch)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 r@@3 (store (select shadow.VC@@0 r@@3) i@@2 e@@1))) (=> (and (= shadow.VC@1 (store shadow.VC@0 r@@3 (VCArraySetLen (select shadow.VC@0 r@@3) (q@max (VCArrayLen (select shadow.VC@0 r@@3)) (+ i@@2 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (and (= (select shadow.Lock r@@3) tid@@3) (ValidTid tid@@3)) (and (=> (is-ShadowableVar r@@3) (not (= (select sx.R (|x#ShadowableVar| r@@3)) SHARED))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct)))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun r@@3 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 r@@3 VC.bottom)) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (and (= (select shadow.Lock r@@3) tid@@3) (=> (is-ShadowableVar r@@3) (not (= (select sx.R (|x#ShadowableVar| r@@3)) SHARED)))) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct)))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v1 () T@Shadowable)
(declare-fun v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 v1) inline$AtomicVC.Leq$0$j) (VCArrayGet (select shadow.VC@@0 v2) inline$AtomicVC.Leq$0$j)))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (not (is-ShadowableVar v2)) (=> (and (=> (is-ShadowableVar v1) (= (select sx.R (|x#ShadowableVar| v1)) SHARED)) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (=> (and (and (= (select shadow.Lock v2) tid@@3) (= (select shadow.Lock v1) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v1 () T@Shadowable)
(declare-fun v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (and (= shadow.VC@1 (store shadow.VC@@0 v1 (select shadow.VC@@0 v2))) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (VCRepOk (select shadow.VC@0 v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 v1)) (q@max (VCArrayLen (select shadow.VC@@0 v1)) (VCArrayLen (select shadow.VC@@0 v2)))) (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (VCArrayGet (select shadow.VC@0 v1) inline$AtomicVC.Copy$0$j) (VCArrayGet (select shadow.VC@@0 v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (and (= shadow.VC@0 (store shadow.VC@@0 v1 (select shadow.VC@0 v1))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (VCRepOk (select shadow.VC@@0 v1)) (=> (and (and (and (VCRepOk (select shadow.VC@@0 v2)) (not (is-ShadowableVar v2))) (and (not (is-ShadowableVar v1)) (= (select shadow.Lock v2) tid@@3))) (and (and (= (select shadow.Lock v1) tid@@3) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (and (not (= v1 v2)) (ValidTid tid@@3)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 v1)) (=> (and (and (= (VCArrayLen (select shadow.VC@0 v1)) (q@max (VCArrayLen (select shadow.VC@@0 v1)) (VCArrayLen (select shadow.VC@@0 v2)))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (VCArrayGet (select shadow.VC@0 v1) inline$AtomicVC.Join$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 v1) inline$AtomicVC.Join$0$j) (VCArrayGet (select shadow.VC@@0 v2) inline$AtomicVC.Join$0$j))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 v1 (select shadow.VC@0 v1))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (VCRepOk (select shadow.VC@@0 v2)) (=> (and (and (and (not (is-ShadowableVar v2)) (not (is-ShadowableVar v1))) (and (= (select shadow.Lock v2) tid@@3) (= (select shadow.Lock v1) tid@@3))) (and (and (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3) (not (= v1 v2))) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v@@2 () T@Shadowable)
(declare-fun i@@2 () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 v@@2 (VCArraySetLen (select shadow.VC@@0 v@@2) (q@max (VCArrayLen (select shadow.VC@@0 v@@2)) (+ i@@2 1))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 v@@2 (store (select shadow.VC@0 v@@2) i@@2 (EpochInc (select (select shadow.VC@0 v@@2) i@@2))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (VCRepOk (select shadow.VC@@0 v@@2)) (=> (and (>= i@@2 0) (not (is-ShadowableVar v@@2))) (=> (and (and (= (select shadow.Lock v@@2) tid@@3) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun Trigger_AtomicFork_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicFork$0$v2@0 () T@Shadowable)
(declare-fun Trigger_AtomicFork_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicFork$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicFork$0$v1@1 () T@Shadowable)
(declare-fun uid () Int)
(declare-fun inline$AtomicFork$0$v2@1 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicFork)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicFork$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicFork$0$anon0_correct  (=> (Trigger_AtomicFork_v2 inline$AtomicFork$0$v2@0) (=> (and (and (Trigger_AtomicFork_v1 inline$AtomicFork$0$v1@0) (= inline$AtomicFork$0$v1@1 (ShadowableTid uid))) (and (= inline$AtomicFork$0$v2@1 (ShadowableTid tid@@3)) (= (VCArrayLen (select shadow.VC@0 inline$AtomicFork$0$v1@1)) (q@max (VCArrayLen (select shadow.VC@@0 inline$AtomicFork$0$v1@1)) (VCArrayLen (select shadow.VC@@0 inline$AtomicFork$0$v2@1)))))) (=> (and (and (and (VCRepOk (select shadow.VC@0 inline$AtomicFork$0$v1@1)) (forall ((inline$AtomicFork$0$j Int) ) (!  (=> (<= 0 inline$AtomicFork$0$j) (= (VCArrayGet (select shadow.VC@0 inline$AtomicFork$0$v1@1) inline$AtomicFork$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 inline$AtomicFork$0$v1@1) inline$AtomicFork$0$j) (VCArrayGet (select shadow.VC@@0 inline$AtomicFork$0$v2@1) inline$AtomicFork$0$j))))
 :qid |unknown.0:0|
 :skolemid |28|
))) (and (VCRepOk (select shadow.VC@0 inline$AtomicFork$0$v2@1)) (= (VCArrayLen (select shadow.VC@0 inline$AtomicFork$0$v2@1)) (q@max (VCArrayLen (select shadow.VC@0 inline$AtomicFork$0$v2@1)) (+ tid@@3 1))))) (and (and (forall ((inline$AtomicFork$0$j@@0 Int) ) (!  (=> (and (<= 0 inline$AtomicFork$0$j@@0) (not (= inline$AtomicFork$0$j@@0 tid@@3))) (= (VCArrayGet (select shadow.VC@0 inline$AtomicFork$0$v2@1) inline$AtomicFork$0$j@@0) (VCArrayGet (select shadow.VC@@0 inline$AtomicFork$0$v2@1) inline$AtomicFork$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |29|
)) (= (VCArrayGet (select shadow.VC@0 inline$AtomicFork$0$v2@1) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@@0 inline$AtomicFork$0$v2@1) tid@@3)))) (and (= shadow.VC@0 (store (store shadow.VC@@0 inline$AtomicFork$0$v1@1 (select shadow.VC@0 inline$AtomicFork$0$v1@1)) inline$AtomicFork$0$v2@1 (select shadow.VC@0 inline$AtomicFork$0$v2@1))) (= (ControlFlow 0 3) 2)))) inline$AtomicFork$0$Return_correct)))))
(let ((inline$AtomicFork$0$Entry_correct  (=> (and (not (= tid@@3 uid)) (= (select shadow.Lock (ShadowableTid uid)) tid@@3)) (=> (and (and (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3) (ValidTid uid)) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicFork$0$anon0_correct))))
inline$AtomicFork$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun Trigger_AtomicJoin_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicJoin$0$v2@0 () T@Shadowable)
(declare-fun Trigger_AtomicJoin_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicJoin$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicJoin$0$v1@1 () T@Shadowable)
(declare-fun uid () Int)
(declare-fun inline$AtomicJoin$0$v2@1 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicJoin$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicJoin$0$anon0_correct  (=> (Trigger_AtomicJoin_v2 inline$AtomicJoin$0$v2@0) (=> (and (and (and (Trigger_AtomicJoin_v1 inline$AtomicJoin$0$v1@0) (= inline$AtomicJoin$0$v1@1 (ShadowableTid uid))) (and (= inline$AtomicJoin$0$v2@1 (ShadowableTid tid@@3)) (= (VCArrayLen (select shadow.VC@0 inline$AtomicJoin$0$v2@1)) (q@max (VCArrayLen (select shadow.VC@@0 inline$AtomicJoin$0$v1@1)) (VCArrayLen (select shadow.VC@@0 inline$AtomicJoin$0$v2@1)))))) (and (and (VCRepOk (select shadow.VC@0 inline$AtomicJoin$0$v2@1)) (forall ((inline$AtomicJoin$0$j Int) ) (!  (=> (<= 0 inline$AtomicJoin$0$j) (= (VCArrayGet (select shadow.VC@0 inline$AtomicJoin$0$v2@1) inline$AtomicJoin$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 inline$AtomicJoin$0$v2@1) inline$AtomicJoin$0$j) (VCArrayGet (select shadow.VC@@0 inline$AtomicJoin$0$v1@1) inline$AtomicJoin$0$j))))
 :qid |unknown.0:0|
 :skolemid |30|
))) (and (= shadow.VC@0 (store shadow.VC@@0 inline$AtomicJoin$0$v2@1 (select shadow.VC@0 inline$AtomicJoin$0$v2@1))) (= (ControlFlow 0 3) 2)))) inline$AtomicJoin$0$Return_correct))))
(let ((inline$AtomicJoin$0$Entry_correct  (=> (and (not (= tid@@3 uid)) (= (select shadow.Lock (ShadowableTid uid)) tid@@3)) (=> (and (and (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3) (ValidTid uid)) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicJoin$0$anon0_correct))))
inline$AtomicJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun Trigger_AtomicAcquire_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicAcquire$0$v2@0 () T@Shadowable)
(declare-fun Trigger_AtomicAcquire_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicAcquire$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicAcquire$0$v1@1 () T@Shadowable)
(declare-fun inline$AtomicAcquire$0$v2@1 () T@Shadowable)
(declare-fun l () T@Lock)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicAcquire$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicAcquire$0$anon0_correct  (=> (Trigger_AtomicAcquire_v2 inline$AtomicAcquire$0$v2@0) (=> (and (and (and (Trigger_AtomicAcquire_v1 inline$AtomicAcquire$0$v1@0) (= inline$AtomicAcquire$0$v1@1 (ShadowableTid tid@@3))) (and (= inline$AtomicAcquire$0$v2@1 (ShadowableLock l)) (VCRepOk (select shadow.VC@0 inline$AtomicAcquire$0$v1@1)))) (and (and (= (VCArrayLen (select shadow.VC@0 inline$AtomicAcquire$0$v1@1)) (q@max (VCArrayLen (select shadow.VC@@0 inline$AtomicAcquire$0$v1@1)) (VCArrayLen (select shadow.VC@@0 inline$AtomicAcquire$0$v2@1)))) (forall ((inline$AtomicAcquire$0$j Int) ) (!  (=> (<= 0 inline$AtomicAcquire$0$j) (= (VCArrayGet (select shadow.VC@0 inline$AtomicAcquire$0$v1@1) inline$AtomicAcquire$0$j) (EpochMax (VCArrayGet (select shadow.VC@@0 inline$AtomicAcquire$0$v1@1) inline$AtomicAcquire$0$j) (VCArrayGet (select shadow.VC@@0 inline$AtomicAcquire$0$v2@1) inline$AtomicAcquire$0$j))))
 :qid |unknown.0:0|
 :skolemid |31|
))) (and (= shadow.VC@0 (store shadow.VC@@0 inline$AtomicAcquire$0$v1@1 (select shadow.VC@0 inline$AtomicAcquire$0$v1@1))) (= (ControlFlow 0 3) 2)))) inline$AtomicAcquire$0$Return_correct))))
(let ((inline$AtomicAcquire$0$Entry_correct  (=> (and (and (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3) (= (select shadow.Lock (ShadowableLock l)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicAcquire$0$anon0_correct)))
inline$AtomicAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRelease$0$v2@1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRelease$0$v1@1 () T@Shadowable)
(declare-fun Trigger_AtomicRelease_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicRelease$0$v2@0 () T@Shadowable)
(declare-fun Trigger_AtomicRelease_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicRelease$0$v1@0 () T@Shadowable)
(declare-fun l () T@Lock)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicRelease)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 7) (let ((inline$AtomicRelease$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicRelease$0$anon3_correct  (=> (and (VCRepOk (select shadow.VC@0 inline$AtomicRelease$0$v2@1)) (= (VCArrayLen (select shadow.VC@0 inline$AtomicRelease$0$v2@1)) (q@max (VCArrayLen (select shadow.VC@0 inline$AtomicRelease$0$v2@1)) (+ tid@@3 1)))) (=> (and (and (forall ((inline$AtomicRelease$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicRelease$0$j) (not (= inline$AtomicRelease$0$j tid@@3))) (= (VCArrayGet (select shadow.VC@0 inline$AtomicRelease$0$v2@1) inline$AtomicRelease$0$j) (VCArrayGet (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) inline$AtomicRelease$0$j)))
 :qid |unknown.0:0|
 :skolemid |33|
)) (= (VCArrayGet (select shadow.VC@0 inline$AtomicRelease$0$v2@1) tid@@3) (EpochInc (VCArrayGet (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) tid@@3)))) (and (= shadow.VC@0 (store (store shadow.VC@@0 inline$AtomicRelease$0$v1@1 (select shadow.VC@0 inline$AtomicRelease$0$v1@1)) inline$AtomicRelease$0$v2@1 (select shadow.VC@0 inline$AtomicRelease$0$v2@1))) (= (ControlFlow 0 3) 2))) inline$AtomicRelease$0$Return_correct))))
(let ((inline$AtomicRelease$0$anon4_Else_correct  (=> (and (= (select shadow.VC@0 inline$AtomicRelease$0$v1@1) (select shadow.VC@@0 inline$AtomicRelease$0$v2@1)) (= (ControlFlow 0 5) 3)) inline$AtomicRelease$0$anon3_correct)))
(let ((inline$AtomicRelease$0$anon4_Then_correct  (=> (and (and (VCRepOk (select shadow.VC@0 inline$AtomicRelease$0$v1@1)) (= (VCArrayLen (select shadow.VC@0 inline$AtomicRelease$0$v1@1)) (q@max (VCArrayLen (select shadow.VC@@0 inline$AtomicRelease$0$v1@1)) (VCArrayLen (select shadow.VC@@0 inline$AtomicRelease$0$v2@1))))) (and (forall ((inline$AtomicRelease$0$j@@0 Int) ) (!  (=> (<= 0 inline$AtomicRelease$0$j@@0) (= (VCArrayGet (select shadow.VC@0 inline$AtomicRelease$0$v1@1) inline$AtomicRelease$0$j@@0) (VCArrayGet (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) inline$AtomicRelease$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |32|
)) (= (ControlFlow 0 4) 3))) inline$AtomicRelease$0$anon3_correct)))
(let ((inline$AtomicRelease$0$anon0_correct  (=> (and (and (Trigger_AtomicRelease_v2 inline$AtomicRelease$0$v2@0) (Trigger_AtomicRelease_v1 inline$AtomicRelease$0$v1@0)) (and (= inline$AtomicRelease$0$v1@1 (ShadowableLock l)) (= inline$AtomicRelease$0$v2@1 (ShadowableTid tid@@3)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicRelease$0$anon4_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicRelease$0$anon4_Else_correct)))))
(let ((inline$AtomicRelease$0$Entry_correct  (=> (and (and (= (select shadow.Lock (ShadowableLock l)) tid@@3) (= (select shadow.Lock (ShadowableTid tid@@3)) tid@@3)) (and (ValidTid tid@@3) (= (ControlFlow 0 7) 6))) inline$AtomicRelease$0$anon0_correct)))
inline$AtomicRelease$0$Entry_correct)))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicWrite$0$st@1 () T@Shadowable)
(declare-fun inline$AtomicWrite$0$sx@1 () T@Shadowable)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Trigger_AtomicWrite_sx (T@Shadowable) Bool)
(declare-fun inline$AtomicWrite$0$sx@0 () T@Shadowable)
(declare-fun Trigger_AtomicWrite_st (T@Shadowable) Bool)
(declare-fun inline$AtomicWrite$0$st@0 () T@Shadowable)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicWrite)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 10) (let ((inline$AtomicWrite$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicWrite$0$SharedWriteRace_correct  (=> (= (select sx.R x@@3) SHARED) (=> (and (not (forall ((inline$AtomicWrite$0$j Int) ) (!  (=> (and (and (<= 0 inline$AtomicWrite$0$j) (< inline$AtomicWrite$0$j (q@max (VCArrayLen (select shadow.VC@@0 inline$AtomicWrite$0$st@1)) (VCArrayLen (select shadow.VC@@0 inline$AtomicWrite$0$sx@1))))) (f inline$AtomicWrite$0$j)) (EpochLeq (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) inline$AtomicWrite$0$j) (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) inline$AtomicWrite$0$j)))
 :qid |unknown.0:0|
 :skolemid |35|
 :pattern ( (f inline$AtomicWrite$0$j))
))) (= (ControlFlow 0 8) 2)) inline$AtomicWrite$0$Return_correct))))
(let ((inline$AtomicWrite$0$ReadWriteRace_correct  (=> (not (= (select sx.R x@@3) SHARED)) (=> (and (not (EpochLeq (select sx.R x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.R x@@3))))) (= (ControlFlow 0 7) 2)) inline$AtomicWrite$0$Return_correct))))
(let ((inline$AtomicWrite$0$WriteWriteRace_correct  (=> (and (not (EpochLeq (select sx.W x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@3))))) (= (ControlFlow 0 6) 2)) inline$AtomicWrite$0$Return_correct)))
(let ((inline$AtomicWrite$0$WritedShared_correct  (=> (EpochLeq (select sx.W x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@3)))) (=> (and (and (= (select sx.R x@@3) SHARED) (forall ((inline$AtomicWrite$0$j@@0 Int) ) (!  (=> (and (and (<= 0 inline$AtomicWrite$0$j@@0) (< inline$AtomicWrite$0$j@@0 (q@max (VCArrayLen (select shadow.VC@@0 inline$AtomicWrite$0$sx@1)) (VCArrayLen (select shadow.VC@@0 inline$AtomicWrite$0$st@1))))) (f inline$AtomicWrite$0$j@@0)) (EpochLeq (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) inline$AtomicWrite$0$j@@0) (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) inline$AtomicWrite$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |34|
 :pattern ( (f inline$AtomicWrite$0$j@@0))
))) (and (= sx.W@1 (store sx.W x@@3 (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) tid@@3))) (= (ControlFlow 0 5) 2))) inline$AtomicWrite$0$Return_correct))))
(let ((inline$AtomicWrite$0$WriteExclusive_correct  (=> (EpochLeq (select sx.W x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@3)))) (=> (and (and (not (= (select sx.R x@@3) SHARED)) (EpochLeq (select sx.R x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.R x@@3))))) (and (= sx.W@0 (store sx.W x@@3 (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) tid@@3))) (= (ControlFlow 0 4) 2))) inline$AtomicWrite$0$Return_correct))))
(let ((inline$AtomicWrite$0$WriteFastPath_correct  (=> (and (= (select sx.W x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicWrite$0$st@1) tid@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicWrite$0$Return_correct)))
(let ((inline$AtomicWrite$0$anon0_correct  (=> (and (and (Trigger_AtomicWrite_sx inline$AtomicWrite$0$sx@0) (Trigger_AtomicWrite_st inline$AtomicWrite$0$st@0)) (and (= inline$AtomicWrite$0$st@1 (ShadowableTid tid@@3)) (= inline$AtomicWrite$0$sx@1 (ShadowableVar x@@3)))) (and (and (and (and (and (=> (= (ControlFlow 0 9) 3) inline$AtomicWrite$0$WriteFastPath_correct) (=> (= (ControlFlow 0 9) 4) inline$AtomicWrite$0$WriteExclusive_correct)) (=> (= (ControlFlow 0 9) 5) inline$AtomicWrite$0$WritedShared_correct)) (=> (= (ControlFlow 0 9) 6) inline$AtomicWrite$0$WriteWriteRace_correct)) (=> (= (ControlFlow 0 9) 7) inline$AtomicWrite$0$ReadWriteRace_correct)) (=> (= (ControlFlow 0 9) 8) inline$AtomicWrite$0$SharedWriteRace_correct)))))
(let ((inline$AtomicWrite$0$Entry_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 10) 9)) inline$AtomicWrite$0$anon0_correct)))
inline$AtomicWrite$0$Entry_correct))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun x@@3 () T@Var)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRead$0$st@1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRead$0$sx@1 () T@Shadowable)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Trigger_AtomicRead_sx (T@Shadowable) Bool)
(declare-fun inline$AtomicRead$0$sx@0 () T@Shadowable)
(declare-fun Trigger_AtomicRead_st (T@Shadowable) Bool)
(declare-fun inline$AtomicRead$0$st@0 () T@Shadowable)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicRead)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 10) (let ((inline$AtomicRead$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicRead$0$WriteReadRace_correct  (=> (and (not (EpochLeq (select sx.W x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@3))))) (= (ControlFlow 0 8) 2)) inline$AtomicRead$0$Return_correct)))
(let ((inline$AtomicRead$0$ReadShare_correct  (=> (and (and (and (not (= (select sx.R x@@3) SHARED)) (EpochLeq (select sx.W x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@3))))) (and (= shadow.VC@2 (store shadow.VC@@0 inline$AtomicRead$0$sx@1 VC.bottom)) (= shadow.VC@3 (store shadow.VC@2 inline$AtomicRead$0$sx@1 (store (select shadow.VC@2 inline$AtomicRead$0$sx@1) (|tid#epoch| (select sx.R x@@3)) (select sx.R x@@3)))))) (and (and (= shadow.VC@4 (store shadow.VC@3 inline$AtomicRead$0$sx@1 (store (select shadow.VC@3 inline$AtomicRead$0$sx@1) tid@@3 (VCArrayGet (select shadow.VC@3 inline$AtomicRead$0$st@1) tid@@3)))) (= shadow.VC@5 (store shadow.VC@4 inline$AtomicRead$0$sx@1 (VCArraySetLen (select shadow.VC@4 inline$AtomicRead$0$sx@1) (q@max (+ (|tid#epoch| (select sx.R x@@3)) 1) (+ tid@@3 1)))))) (and (= sx.R@1 (store sx.R x@@3 SHARED)) (= (ControlFlow 0 7) 2)))) inline$AtomicRead$0$Return_correct)))
(let ((inline$AtomicRead$0$ReadShared_correct  (=> (= (select sx.R x@@3) SHARED) (=> (and (and (EpochLeq (select sx.W x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@3)))) (= shadow.VC@0 (store shadow.VC@@0 inline$AtomicRead$0$sx@1 (store (select shadow.VC@@0 inline$AtomicRead$0$sx@1) tid@@3 (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) tid@@3))))) (and (= shadow.VC@1 (store shadow.VC@0 inline$AtomicRead$0$sx@1 (VCArraySetLen (select shadow.VC@0 inline$AtomicRead$0$sx@1) (q@max (VCArrayLen (select shadow.VC@0 inline$AtomicRead$0$sx@1)) (+ tid@@3 1))))) (= (ControlFlow 0 6) 2))) inline$AtomicRead$0$Return_correct))))
(let ((inline$AtomicRead$0$ReadExclusive_correct  (=> (not (= (select sx.R x@@3) SHARED)) (=> (and (and (EpochLeq (select sx.W x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@3)))) (EpochLeq (select sx.R x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.R x@@3))))) (and (= sx.R@0 (store sx.R x@@3 (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) tid@@3))) (= (ControlFlow 0 5) 2))) inline$AtomicRead$0$Return_correct))))
(let ((inline$AtomicRead$0$ReadSharedSameEpoch_correct  (=> (= (select sx.R x@@3) SHARED) (=> (and (= (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$sx@1) tid@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) tid@@3)) (= (ControlFlow 0 4) 2)) inline$AtomicRead$0$Return_correct))))
(let ((inline$AtomicRead$0$ReadSameEpoch_correct  (=> (and (= (select sx.R x@@3) (VCArrayGet (select shadow.VC@@0 inline$AtomicRead$0$st@1) tid@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicRead$0$Return_correct)))
(let ((inline$AtomicRead$0$anon0_correct  (=> (and (and (Trigger_AtomicRead_sx inline$AtomicRead$0$sx@0) (Trigger_AtomicRead_st inline$AtomicRead$0$st@0)) (and (= inline$AtomicRead$0$st@1 (ShadowableTid tid@@3)) (= inline$AtomicRead$0$sx@1 (ShadowableVar x@@3)))) (and (and (and (and (and (=> (= (ControlFlow 0 9) 3) inline$AtomicRead$0$ReadSameEpoch_correct) (=> (= (ControlFlow 0 9) 4) inline$AtomicRead$0$ReadSharedSameEpoch_correct)) (=> (= (ControlFlow 0 9) 5) inline$AtomicRead$0$ReadExclusive_correct)) (=> (= (ControlFlow 0 9) 6) inline$AtomicRead$0$ReadShared_correct)) (=> (= (ControlFlow 0 9) 7) inline$AtomicRead$0$ReadShare_correct)) (=> (= (ControlFlow 0 9) 8) inline$AtomicRead$0$WriteReadRace_correct)))))
(let ((inline$AtomicRead$0$Entry_correct  (=> (and (and (and (not (= tid@@3 nil)) (>= tid@@3 0)) (>= tid@@3 0)) (and (ValidTid tid@@3) (= (ControlFlow 0 10) 9))) inline$AtomicRead$0$anon0_correct)))
inline$AtomicRead$0$Entry_correct))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun uid () Int)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid uid) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableTid uid)) tid@@3) (=> (and (and (not (= tid@@3 uid)) (ValidTid uid)) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= tid@@3 inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) STOPPED) (ValidTid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) tid@@3))) (and (= thread.HasJoined@0 (store thread.HasJoined tid@@3 inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 3) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (= (select thread.State tid@@3) RUNNING) (ValidTid tid@@3)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= tid@@3 inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) UNUSED) (ValidTid inline$AtomicAllocTid$0$uid@0)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 NEW))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 tid@@3)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) tid@@3))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (forall ((t Int) ) (!  (=> (= (select thread.State t) UNUSED) (= (select shadow.Lock (ShadowableTid t)) nil))
 :qid |verifiedftdefinebpl.1025:20|
 :skolemid |39|
)) (=> (and (and (= (select thread.State tid@@3) RUNNING) (ValidTid tid@@3)) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicStartThread$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State uid RUNNING)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid uid) uid)) (= (ControlFlow 0 3) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (= (select thread.State uid) NEW) (= (select shadow.Lock (ShadowableTid uid)) tid@@3)) (=> (and (and (not (= tid@@3 uid)) (ValidTid uid)) (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) tid@@3)) (= (ControlFlow 0 3) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicChooseLockToAcquire$0$anon0_correct)))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToRelease$0$l@0 () T@Lock)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicChooseLockToRelease)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicChooseLockToRelease$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (and (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) tid@@3) (= (ControlFlow 0 3) 2)) inline$AtomicChooseLockToRelease$0$Return_correct)))
(let ((inline$AtomicChooseLockToRelease$0$Entry_correct  (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicChooseLockToRelease$0$anon0_correct)))
inline$AtomicChooseLockToRelease$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun SHARED () T@Epoch)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun nil () Int)
(define-fun SharedInvPreserved ((oldR (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) Bool (forall ((x T@Var) ) (!  (=> (= (select oldR x) SHARED) (= (select r x) SHARED))
 :qid |verifiedftdefinebpl.177:11|
 :skolemid |10|
)))
(define-fun LocksPreserved ((tid Int) (oldLocks (Array T@Shadowable Int)) (locks (Array T@Shadowable Int)) ) Bool (forall ((v T@Shadowable) ) (!  (=> (= (select oldLocks v) tid) (= (select locks v) tid))
 :qid |verifiedftdefinebpl.173:11|
 :skolemid |9|
)))
(define-fun FTPreserved ((tid@@0 Int) (oldLocks@@0 (Array T@Shadowable Int)) (oldVcs (Array T@Shadowable (Array Int T@Epoch))) (oldW (Array T@Var T@Epoch)) (oldR@@0 (Array T@Var T@Epoch)) (locks@@0 (Array T@Shadowable Int)) (vcs (Array T@Shadowable (Array Int T@Epoch))) (w (Array T@Var T@Epoch)) (r@@0 (Array T@Var T@Epoch)) ) Bool  (and (and (and (and (LocksPreserved tid@@0 oldLocks@@0 locks@@0) (SharedInvPreserved oldR@@0 r@@0)) (forall ((s T@Shadowable) ) (!  (=> (= (select oldLocks@@0 s) tid@@0) (= (select vcs s) (select oldVcs s)))
 :qid |verifiedftdefinebpl.185:11|
 :skolemid |11|
))) (forall ((x@@0 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@0)) tid@@0) (= (select r@@0 x@@0) (select oldR@@0 x@@0)))
 :qid |verifiedftdefinebpl.186:11|
 :skolemid |12|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select oldLocks@@0 (ShadowableVar x@@1)) tid@@0) (= (select w x@@1) (select oldW x@@1)))
 :qid |verifiedftdefinebpl.187:11|
 :skolemid |13|
))))
(define-fun VCsRepOk ((vcs@@0 (Array T@Shadowable (Array Int T@Epoch))) ) Bool (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select vcs@@0 s@@0))
 :qid |verifiedftdefinebpl.160:11|
 :skolemid |8|
)))
(define-fun FTRepOk ((vcs@@1 (Array T@Shadowable (Array Int T@Epoch))) (w@@0 (Array T@Var T@Epoch)) (r@@1 (Array T@Var T@Epoch)) ) Bool  (and (VCsRepOk vcs@@1) (VarsRepOk w@@0 r@@1)))
(define-fun VCArraySetLen ((vc (Array Int T@Epoch)) (n Int) ) (Array Int T@Epoch) (store vc (- 0 1) (epoch (- 0 1) n)))
(define-fun VC.bottom () (Array Int T@Epoch) (VCArraySetLen EMPTY_MAP 0))
(define-fun STOPPED () Int 3)
(define-fun RUNNING () Int 2)
(define-fun NEW () Int 1)
(define-fun UNUSED () Int 0)
(define-fun VCArrayGet ((vc@@0 (Array Int T@Epoch)) (i Int) ) T@Epoch (select vc@@0 i))
(define-fun VCArrayLen ((vc@@1 (Array Int T@Epoch)) ) Int (|clock#epoch| (select vc@@1 (- 0 1))))
(define-fun EpochInit ((tid@@1 Int) ) T@Epoch (epoch tid@@1 0))
(define-fun q@max ((a Int) (b Int) ) Int (ite (< a b) b a))
(define-fun EpochMax ((e1 T@Epoch) (e2 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e1) (q@max (|clock#epoch| e1) (|clock#epoch| e2))))
(define-fun EpochLeq ((e1@@0 T@Epoch) (e2@@0 T@Epoch) ) Bool  (and (= (|tid#epoch| e1@@0) (|tid#epoch| e2@@0)) (<= (|clock#epoch| e1@@0) (|clock#epoch| e2@@0))))
(define-fun EpochIsShared ((e T@Epoch) ) Bool (= e SHARED))
(define-fun EpochInc ((e@@0 T@Epoch) ) T@Epoch (epoch (|tid#epoch| e@@0) (+ (|clock#epoch| e@@0) 1)))
(define-fun ValidTid ((tid@@2 Int) ) Bool  (and (not (= tid@@2 nil)) (>= tid@@2 0)))
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w@@1 (Array T@Var T@Epoch)) (r@@2 (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w@@1 r@@2)  (and (forall ((v@@0 T@Var) ) (! (ValidTid (|tid#epoch| (select w@@1 v@@0)))
 :qid |verifiedftdefinebpl.148:11|
 :skolemid |1|
)) (forall ((v@@1 T@Var) ) (!  (or (= (select r@@2 v@@1) SHARED) (and (>= (|tid#epoch| (select r@@2 v@@1)) 0) (not (= (|tid#epoch| (select r@@2 v@@1)) nil))))
 :qid |verifiedftdefinebpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftdefinebpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w@@1 r@@2))
)))
(assert (forall ((vc@@2 (Array Int T@Epoch)) ) (! (= (VCRepOk vc@@2)  (and (and (and (>= (VCArrayLen vc@@2) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (VCArrayLen vc@@2))) (>= (|clock#epoch| (select vc@@2 j)) 0))
 :qid |verifiedftdefinebpl.154:11|
 :skolemid |4|
 :pattern ( (select vc@@2 j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (VCArrayLen vc@@2))) (= (|tid#epoch| (select vc@@2 j@@0)) j@@0))
 :qid |verifiedftdefinebpl.155:11|
 :skolemid |5|
 :pattern ( (select vc@@2 j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (VCArrayLen vc@@2) j@@1) (= (select vc@@2 j@@1) (EpochInit j@@1)))
 :qid |verifiedftdefinebpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftdefinebpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc@@2))
)))
(assert (forall ((x@@2 Int) ) (! (= (select Identity x@@2) x@@2)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i@@0 Int) ) (! (= (f i@@0) true)
 :qid |verifiedftdefinebpl.1073:28|
 :skolemid |40|
 :pattern ( (f i@@0))
)))
(assert (forall ((i@@1 Int) ) (! (= (select EMPTY_MAP i@@1) (EpochInit i@@1))
 :qid |verifiedftdefinebpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftdefinebpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid@@3 () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun l () T@Lock)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid@@3 true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock l) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableLock l)) tid@@3) (=> (and (ValidTid tid@@3) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
