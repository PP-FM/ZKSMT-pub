(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= (select shadow.Lock (ShadowableVar second_x)) nil) (= (select (store shadow.Lock (ShadowableVar second_x) second_tid) (ShadowableVar first_x)) nil)) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) second_tid) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicAcquireVarLock$1$anon0_correct  (=> (= (select shadow.Lock@0 (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicAcquireVarLock$1$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicAcquireVarLock$1$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |45|
)) (=> (and (not (= first_tid nil)) (>= first_tid 0)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableVar first_x)) nil) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |46|
)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |47|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |48|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateSetW_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |49|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |50|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateSetR_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (not (= (select sx.R first_x) SHARED)))) (=> (=> true (not (= (select sx.R first_x) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |51|
)) (=> (and (and (and (not (= (select sx.R first_x) SHARED)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |52|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |53|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |54|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |55|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |56|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |57|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 8) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |58|
)) (not (is-ShadowableVar first_v2))) (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 11) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |59|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11))) inline$AtomicAcquireVarLock$0$anon0_correct))))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 10) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |60|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 11) 10))) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 8) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |61|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (=> (and (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select (store shadow.Lock (ShadowableTid second_uid) nil) (ShadowableVar first_x)) nil) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableTid second_uid) nil) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableTid second_uid) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseJoinLock$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |62|
)) (=> (and (not (= first_tid nil)) (>= first_tid 0)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_uid () Int)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseJoinLock_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 7) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (not (= first_tid first_uid)))) (=> (=> true (not (= first_tid first_uid))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_uid nil)) (>= first_uid 0)))) (=> (=> true (and (not (= first_uid nil)) (>= first_uid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 6) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |63|
)) (=> (and (= (select shadow.Lock (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid))) (=> (and (and (and (not (= first_uid nil)) (>= first_uid 0)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 7) 6))) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3)) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil)) (= (select (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid) (ShadowableVar first_x)) nil)) (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true))) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid) (ShadowableVar first_x) first_tid))) (= thread.State thread.State))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock@0 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 3) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |64|
)) (=> (and (not (= first_tid nil)) (>= first_tid 0)) (=> (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4)) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= (select (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid) (ShadowableVar first_x)) nil)) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid) (ShadowableVar first_x) first_tid))) (= shadow.VC@@0 shadow.VC@@0))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |65|
)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicAllocTid_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) 0) (= (select shadow.Lock@0 (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (=> (=> true (forall ((first_t@@0 Int) ) (!  (=> (= (select thread.State first_t@@0) 0) (= (select shadow.Lock@0 (ShadowableTid first_t@@0)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0)))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |66|
)) (forall ((first_t@@1 Int) ) (!  (=> (= (select thread.State first_t@@1) 0) (= (select shadow.Lock (ShadowableTid first_t@@1)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun first_x () T@Var)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= (select (store shadow.Lock (ShadowableTid second_uid) second_uid) (ShadowableVar first_x)) nil) (= thread.State@0 (store thread.State second_uid 2))) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableTid second_uid) second_uid) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 3) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicStartThread$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |67|
)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun first_uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicStartThread_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 8) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select thread.State first_uid) 1))) (=> (=> true (= (select thread.State first_uid) 1)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (not (= first_tid first_uid)))) (=> (=> true (not (= first_tid first_uid))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_uid nil)) (>= first_uid 0)))) (=> (=> true (and (not (= first_uid nil)) (>= first_uid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 7) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |68|
)) (= (select thread.State first_uid) 1)) (and (= (select shadow.Lock (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid)))) (=> (and (and (and (not (= first_uid nil)) (>= first_uid 0)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 8) 7))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (= (select (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid) (ShadowableVar first_x)) nil)) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock@0 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |69|
)) (=> (and (not (= first_tid nil)) (>= first_tid 0)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToRelease$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicChooseLockToRelease)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToRelease$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) second_tid) (= (select shadow.Lock (ShadowableVar first_x)) nil)) (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (and (= (select shadow.Lock@0 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) second_tid) (= (ControlFlow 0 3) 2)) inline$AtomicChooseLockToRelease$0$Return_correct)))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseLockToRelease$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |70|
)) (=> (and (not (= first_tid nil)) (>= first_tid 0)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)) inline$AtomicAcquireVarLock$0$anon0_correct)))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAcquireVarLock_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select (store shadow.Lock (ShadowableLock second_l) nil) (ShadowableVar first_x)) nil) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableLock second_l) nil) (ShadowableVar first_x) first_tid)))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableLock second_l) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar first_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseChosenLock$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |71|
)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct))))
inline$AtomicAcquireVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_l () T@Lock)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseChosenLock_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableLock first_l)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableLock first_l)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar second_x)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |72|
)) (= (select shadow.Lock (ShadowableLock first_l)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicReleaseVarLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableVar first_x) nil))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$1$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar first_x) nil)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$1$anon0_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |73|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |74|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicReleaseVarLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |75|
)) (=> (and (not (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |76|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |77|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |78|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |79|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |80|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |81|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |82|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |83|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |84|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 11) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |85|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11)))) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |86|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicThreadStateGetE_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |87|
)) (=> (and (not (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1)))))))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |88|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicThreadStateGetE$0$anon0_correct))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1)))))))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |89|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicThreadStateGetE$0$anon0_correct))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |90|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicThreadStateGetE$0$anon0_correct))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select shadow.VC@2 second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@2 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)) (and (and (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@2 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |91|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicThreadStateGetE$0$anon0_correct)))
inline$AtomicThreadStateGetE$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select shadow.VC@0 second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |92|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicThreadStateGetE$0$anon0_correct))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicThreadStateGetE_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1))))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid first_tid)) first_tid))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid first_tid)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |93|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicThreadStateGetE$0$anon0_correct)))))
inline$AtomicThreadStateGetE$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVarStateSetW_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |94|
)) (=> (and (not (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateSetW_AtomicVarStateGetW)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateGetW$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W second_x)) (= sx.W@0 (store sx.W first_x first_e))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@0 second_x)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetW$0$Return_correct)))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@0 (store sx.W first_x first_e)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetW$0$anon0_correct)))
(let ((inline$AtomicVarStateSetW$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |95|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateSetW$0$anon0_correct))))
inline$AtomicVarStateSetW$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVarStateGetW_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |96|
)) (=> (and (not (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateGetW_AtomicVarStateSetW)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateSetW$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= sx.W@0 (store sx.W second_x second_e)) (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@0 first_x))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@0 (store sx.W second_x second_e)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetW$0$Return_correct)))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W first_x)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetW$0$anon0_correct)))
(let ((inline$AtomicVarStateGetW$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |97|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateGetW$0$anon0_correct))))
inline$AtomicVarStateGetW$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVarStateSetR_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (not (= (select sx.R first_x) SHARED)) (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |98|
)) (=> (and (not (and (and (not (= (select sx.R first_x) SHARED)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateSetR_AtomicVarStateGetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateGetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= inline$AtomicVarStateGetR$0$e@1 (select sx.R second_x)) (= sx.R@0 (store sx.R first_x first_e))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@0 second_x)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R first_x first_e)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetR$0$anon0_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |99|
)) (=> (and (not (= (select sx.R first_x) SHARED)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateSetR$0$anon0_correct)))))
inline$AtomicVarStateSetR$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVarStateSetR$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R@0 first_x) SHARED)))))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 5) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |100|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicVarStateSetR$0$anon0_correct))))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVarStateSetR$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_r) first_tid))) (=> (=> true (= (select shadow.Lock first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R@0 (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 5) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |101|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicVarStateSetR$0$anon0_correct))))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVarStateSetR$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_r) first_tid))) (=> (=> true (= (select shadow.Lock first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R@0 (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R@0 (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 5) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |102|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicVarStateSetR$0$anon0_correct)))))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVarStateSetR$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R@0 (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R@0 (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 8) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |103|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicVarStateSetR$0$anon0_correct)))))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVarStateGetR_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |104|
)) (=> (and (not (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateGetR_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateSetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= sx.R@0 (store sx.R second_x second_e)) (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@0 first_x))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetR$0$e@1 (select sx.R first_x)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetR$0$anon0_correct)))
(let ((inline$AtomicVarStateGetR$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |105|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateGetR$0$anon0_correct))))
inline$AtomicVarStateGetR$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun first_x () T@Var)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_x () T@Var)
(declare-fun second_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVarStateGetRShared_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVarStateSetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= (select sx.R@0 first_x) SHARED) (= sx.R@0 (store sx.R second_x second_e))) (= SHARED SHARED)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R second_x second_e)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateGetRShared$0$anon0_correct  (=> (and (= (select sx.R first_x) SHARED) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetR$0$anon0_correct)))
(let ((inline$AtomicVarStateGetRShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |106|
)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (not (= (select sx.R second_x) SHARED)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVarStateGetRShared$0$anon0_correct))))
inline$AtomicVarStateGetRShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCGetSize_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 first_r) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |107|
)) (=> (and (not (and (= (select shadow.Lock first_r) first_tid) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetSize_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1)))))))) (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@1 first_r) (- 0 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@@0 first_r) (- 0 1)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCGetSize$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |108|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetSize$0$anon0_correct))))
inline$AtomicVCGetSize$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetSize_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1)))))))) (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@1 first_r) (- 0 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@@0 first_r) (- 0 1)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVCGetSize$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |109|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetSize$0$anon0_correct))))
inline$AtomicVCGetSize$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetSize_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@@0 first_r) (- 0 1)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicVCGetSize$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |110|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetSize$0$anon0_correct))))
inline$AtomicVCGetSize$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCGetElem_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 first_r) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |111|
)) (=> (and (not (and (= (select shadow.Lock first_r) first_tid) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1)))))))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 first_r) first_i))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |112|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetElem$0$anon0_correct))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1)))))))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 first_r) first_i))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |113|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetElem$0$anon0_correct))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@0 first_r) first_i))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |114|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElem$0$anon0_correct))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select shadow.VC@2 second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@2 first_r) first_i))) (= shadow.Lock shadow.Lock)) (and (and (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@2 first_r) first_i))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 first_r) first_i)) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |115|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicVCGetElem$0$anon0_correct)))
inline$AtomicVCGetElem$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select shadow.VC@0 second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@0 first_r) first_i))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |116|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetElem$0$anon0_correct))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElem_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1))))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 first_r) first_i))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 first_r) first_i)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |117|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElem$0$anon0_correct)))))
inline$AtomicVCGetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1)))))))) (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@1 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |118|
)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetElemShared$0$anon0_correct))))
inline$AtomicVCGetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1)))))))) (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@1 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |119|
)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock second_r) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCGetElemShared$0$anon0_correct))))
inline$AtomicVCGetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@0 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |120|
)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElemShared$0$anon0_correct))))
inline$AtomicVCGetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select shadow.VC@2 second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@2 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock)) (and (and (and (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@2 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |121|
)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicVCGetElemShared$0$anon0_correct))))
inline$AtomicVCGetElemShared$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCGetElemShared_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1))))) (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@1 (ShadowableVar first_x)) first_tid))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar first_x)) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |122|
)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (VCRepOk (select shadow.VC@@0 second_v)))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCGetElemShared$0$anon0_correct)))))
inline$AtomicVCGetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCSetElemShared_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))) (= (select sx.R first_x) SHARED)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |123|
)) (=> (and (not (and (and (= (select shadow.Lock (ShadowableVar first_x)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))) (= (select sx.R first_x) SHARED))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |124|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCGetSize)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetSize$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@@0 second_r) (- 0 1)))) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@1 second_r) (- 0 1)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetSize$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetSize$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |125|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock second_r) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |126|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock second_r) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@1 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |127|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$1$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (store (select shadow.VC@1 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar second_x) (store (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$1$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$1$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |128|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_r (store (select shadow.VC@1 second_r) second_i second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_r (store (select shadow.VC@2 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@2 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |129|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock second_r) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |130|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|tid#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (<= (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
))) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |131|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (not (is-ShadowableVar second_v2)))) (=> (and (and (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)))) (= shadow.VC@4 (store (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@3 (store shadow.VC@1 second_v1@@0 (select shadow.VC@1 second_v2))) (=> (and (= shadow.VC@4 shadow.VC@3) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@1 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))))))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |132|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@1 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 11) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |133|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 12) 11))))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)))) (= shadow.VC@2 (store (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x) (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@2 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |134|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select sx.R first_x) SHARED) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElemShared$0$anon0_correct)))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 10) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |135|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 11) 10))))) inline$AtomicVCSetElemShared$0$anon0_correct)))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) (ShadowableVar first_x) (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_v (store (select shadow.VC@1 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@1 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_v (store (select shadow.VC@2 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@2 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@2 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |136|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (VCRepOk (select shadow.VC@@0 second_v)))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@1 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 8) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |137|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 9) 8)))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun first_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElemShared_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x) (store (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e)) (ShadowableVar first_x)) (- 0 1))))))))) (= sx.R sx.R))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar first_x) (store (select shadow.VC@@0 (ShadowableVar first_x)) first_tid first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar first_x) (store (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1))) (+ first_tid 1)) (+ first_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar first_x)) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |138|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCSetElem_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (= (select shadow.Lock@0 first_r) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |139|
)) (=> (and (not (and (and (= (select shadow.Lock first_r) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (store (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |140|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCGetSize)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetSize$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@@0 second_r) (- 0 1)))) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (store (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@1 second_r) (- 0 1)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetSize$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetSize$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |141|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock second_r) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (store (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |142|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock second_r) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (store (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@1 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |143|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r) first_i first_e)) first_r (store (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r) first_i first_e)) first_r) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (store (select shadow.VC@1 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar second_x) (store (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |144|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r) first_i first_e)) first_r (store (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r) first_i first_e)) first_r) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$1$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_r (store (select shadow.VC@1 second_r) second_i second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_r (store (select shadow.VC@2 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@2 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$1$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$1$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |145|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock second_r) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r) first_i first_e)) first_r (store (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r) first_i first_e)) first_r) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |146|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|tid#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (<= (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
))) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (store (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |147|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (not (is-ShadowableVar second_v2)))) (=> (and (and (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)))) (= shadow.VC@4 (store (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r) first_i first_e)) first_r (store (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_r) first_i first_e)) first_r) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r) first_i first_e)) first_r (store (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r) first_i first_e)) first_r) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@3 (store shadow.VC@1 second_v1@@0 (select shadow.VC@1 second_v2))) (=> (and (= shadow.VC@4 shadow.VC@3) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@1 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))))))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |148|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVCSetElem$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@1 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 11) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |149|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 12) 11))))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)))) (= shadow.VC@2 (store (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r) first_i first_e)) first_r (store (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_r) first_i first_e)) first_r) (- 0 1))))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@2 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |150|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVCSetElem$0$anon0_correct)))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVCSetElem$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 10) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |151|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 11) 10))))) inline$AtomicVCSetElem$0$anon0_correct)))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r) first_i first_e)) first_r (store (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r) first_i first_e)) first_r) (- 0 1)))))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_v (store (select shadow.VC@1 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@1 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_v (store (select shadow.VC@2 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@2 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@2 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |152|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (VCRepOk (select shadow.VC@@0 second_v)))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVCSetElem$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@1 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 8) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |153|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 9) 8)))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun first_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCSetElem_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@1 (store (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r (store (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e)) first_r) (- 0 1))))))))) (= sx.R sx.R))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store (select shadow.VC@@0 first_r) first_i first_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_r (store (select shadow.VC@0 first_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@0 first_r) (- 0 1)))))))) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |154|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVCInit_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (= (select shadow.Lock@0 first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |155|
)) (=> (and (not (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |156|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCGetSize)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetSize$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@@0 second_r) (- 0 1)))) (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetSize$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetSize$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |157|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@0 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |158|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@0 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |159|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (store (select shadow.VC@1 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@1 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |160|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) second_i second_e))) (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r (store (select shadow.VC@1 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@1 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |161|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$1$anon0_correct  (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$1$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$1$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |162|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|tid#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (<= (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
))) (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@0 second_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@0 second_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Leq$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |163|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (not (is-ShadowableVar second_v2))) (=> (and (and (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct))))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)))) (= shadow.VC@3 (store (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@3 (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@2 (store shadow.VC@0 second_v1@@0 (select shadow.VC@0 second_v2))) (=> (and (= shadow.VC@3 shadow.VC@2) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@1 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@1 (store shadow.VC@0 second_v1@@0 (select shadow.VC@1 second_v1@@0)))) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |164|
)) (=> (and (and (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicVCInit$0$anon0_correct))))
inline$AtomicVCInit$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVCInit$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 11) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |165|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11)))) inline$AtomicVCInit$0$anon0_correct))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)))) (= shadow.VC@1 (store (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@1 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@0 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@0 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@1 (store shadow.VC@0 second_v1@@0 (select shadow.VC@1 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |166|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVCInit$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 10) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |167|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 11) 10)))) inline$AtomicVCInit$0$anon0_correct)))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_r () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@2 (store shadow.VC@1 second_v (store (select shadow.VC@1 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@1 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@1 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |168|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct))))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVCInit$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 8) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |169|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_r () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVCInit_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= sx.R sx.R))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |170|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicVCInit$0$anon0_correct)))))
inline$AtomicVCInit$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Leq_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (= (select shadow.Lock@0 first_v2) first_tid)) (= (select shadow.Lock@0 first_v1) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |171|
)) (=> (and (not (and (and (and (and (and (not (is-ShadowableVar first_v2)) (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1)))))))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (and (= (|tid#epoch| (select (select shadow.VC@1 first_v1) first_j)) (|tid#epoch| (select (select shadow.VC@1 first_v2) first_j))) (<= (|clock#epoch| (select (select shadow.VC@1 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@1 first_v2) first_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |172|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1)))))))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (and (= (|tid#epoch| (select (select shadow.VC@1 first_v1) first_j)) (|tid#epoch| (select (select shadow.VC@1 first_v2) first_j))) (<= (|clock#epoch| (select (select shadow.VC@1 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@1 first_v2) first_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |173|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (and (= (|tid#epoch| (select (select shadow.VC@0 first_v1) first_j)) (|tid#epoch| (select (select shadow.VC@0 first_v2) first_j))) (<= (|clock#epoch| (select (select shadow.VC@0 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@0 first_v2) first_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |174|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select shadow.VC@2 second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (and (= (|tid#epoch| (select (select shadow.VC@2 first_v1) first_j)) (|tid#epoch| (select (select shadow.VC@2 first_v2) first_j))) (<= (|clock#epoch| (select (select shadow.VC@2 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@2 first_v2) first_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock)) (and (and (and (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j@@0 Int) ) (!  (=> (and (<= 0 first_j@@0) (f first_j@@0)) (and (= (|tid#epoch| (select (select shadow.VC@2 first_v1) first_j@@0)) (|tid#epoch| (select (select shadow.VC@2 first_v2) first_j@@0))) (<= (|clock#epoch| (select (select shadow.VC@2 first_v1) first_j@@0)) (|clock#epoch| (select (select shadow.VC@2 first_v2) first_j@@0)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j@@0))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |175|
)) (not (is-ShadowableVar first_v2))) (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicVC.Leq$0$anon0_correct))))
inline$AtomicVC.Leq$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select shadow.VC@0 second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (and (= (|tid#epoch| (select (select shadow.VC@0 first_v1) first_j)) (|tid#epoch| (select (select shadow.VC@0 first_v2) first_j))) (<= (|clock#epoch| (select (select shadow.VC@0 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@0 first_v2) first_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |176|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Leq$0$anon0_correct)))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Leq_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= shadow.VC@1 (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1))))) (= inline$AtomicVC.Leq$0$res@1 (forall ((first_j Int) ) (!  (=> (and (<= 0 first_j) (f first_j)) (and (= (|tid#epoch| (select (select shadow.VC@1 first_v1) first_j)) (|tid#epoch| (select (select shadow.VC@1 first_v2) first_j))) (<= (|clock#epoch| (select (select shadow.VC@1 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@1 first_v2) first_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f first_j))
)))) (= sx.R sx.R)) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |177|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v)))) (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Leq$0$anon0_correct))))
inline$AtomicVC.Leq$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock@0 first_v2) first_tid)) (= (select shadow.Lock@0 first_v1) first_tid)) (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |178|
)) (=> (and (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (|clock#epoch| (select (select shadow.VC@2 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@2 first_v1) first_j) (select (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid))) (= shadow.Lock shadow.Lock)) (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@2 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |179|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_tid nil)) (>= second_tid 0)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (|clock#epoch| (select (select shadow.VC@2 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@2 first_v1) first_j) (select (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 second_r) second_i))) (= shadow.Lock shadow.Lock)) (and (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@2 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |180|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (not (= second_tid nil)) (>= second_tid 0)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (|clock#epoch| (select (select shadow.VC@2 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@2 first_v1) first_j) (select (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar second_x)) second_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@2 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |181|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (select sx.R second_x) SHARED))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@4 first_v1)) (= (|clock#epoch| (select (select shadow.VC@4 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v2) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@4 first_v1) first_j) (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@4 (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1 (select shadow.VC@4 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@4 (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1 (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v2))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar second_x) (store (select shadow.VC@2 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@4 (store shadow.VC@3 (ShadowableVar second_x) (store (select shadow.VC@3 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@3 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@3 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |182|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (select sx.R second_x) SHARED)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v1)) (VCRepOk (select shadow.VC@1 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |183|
)) (=> (and (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@4 first_v1)) (= (|clock#epoch| (select (select shadow.VC@4 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v2) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@4 first_v1) first_j) (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@4 (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1 (select shadow.VC@4 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1 (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v2))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@3 (store shadow.VC@2 second_r (store (select shadow.VC@2 second_r) second_i second_e))) (=> (and (= shadow.VC@4 (store shadow.VC@3 second_r (store (select shadow.VC@3 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@3 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@3 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |184|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v1)) (VCRepOk (select shadow.VC@1 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |185|
)) (=> (and (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock second_r) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select shadow.VC@3 first_v1)) (= (|clock#epoch| (select (select shadow.VC@3 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1) (- 0 1))) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v2) (- 0 1))) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@3 first_v1) first_j) (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@3 (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1 (select shadow.VC@3 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (= shadow.VC@3 (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1 (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v2))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@3 (store shadow.VC@2 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |186|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED)))) (and (not (= second_tid nil)) (>= second_tid 0)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (VCRepOk (select shadow.VC@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |187|
)) (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct)))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (|clock#epoch| (select (select shadow.VC@2 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@2 first_v1) first_j) (select (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|tid#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (<= (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)) (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j@@0 Int) ) (!  (=> (and (<= 0 second_j@@0) (f second_j@@0)) (and (= (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j@@0)) (|tid#epoch| (select (select shadow.VC@@0 second_v2) second_j@@0))) (<= (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j@@0)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j@@0)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j@@0))
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R)))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@2 second_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@2 second_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |188|
)) (=> (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (not (is-ShadowableVar second_v2))) (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (not (= second_tid nil)) (>= second_tid 0)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 7) (let ((inline$AtomicVC.Copy$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (or (or (and (and (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)))) (VCRepOk (select shadow.VC@5 first_v1))) (= (|clock#epoch| (select (select shadow.VC@5 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v1) (- 0 1))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v2) (- 0 1)))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v2) (- 0 1))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@5 first_v1) first_j) (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@5 (store (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v1 (select shadow.VC@5 first_v1)))) (= shadow.Lock shadow.Lock)) (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j@@0 Int) ) (!  (=> (<= 0 second_j@@0) (= (select (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0) second_j@@0) (select (select shadow.VC@@0 second_v2) second_j@@0)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) second_v1@@0)))) (= shadow.VC@5 (store (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v1 (select (witness shadow.VC@@0 shadow.VC@5 second_v1@@0) first_v2)))) (= shadow.Lock shadow.Lock))) (and (and (and (and (VCRepOk (select shadow.VC@5 first_v1)) (= (|clock#epoch| (select (select shadow.VC@5 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1) (- 0 1))) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) (- 0 1))) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1) (- 0 1)))))) (forall ((first_j@@0 Int) ) (!  (=> (<= 0 first_j@@0) (= (select (select shadow.VC@5 first_v1) first_j@@0) (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) first_j@@0)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@5 (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1 (select shadow.VC@5 first_v1)))) (= shadow.Lock shadow.Lock))) (and (= shadow.VC@5 (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1 (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$1$anon3_Else_correct  (=> (= shadow.VC@4 (store shadow.VC@2 second_v1@@0 (select shadow.VC@2 second_v2))) (=> (and (= shadow.VC@5 shadow.VC@4) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$1$Return_correct))))
(let ((inline$AtomicVC.Copy$1$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@3 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@3 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$1$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$1$j) (= (select (select shadow.VC@3 second_v1@@0) inline$AtomicVC.Copy$1$j) (select (select shadow.VC@2 second_v2) inline$AtomicVC.Copy$1$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@3 (store shadow.VC@2 second_v1@@0 (select shadow.VC@3 second_v1@@0)))) (and (= shadow.VC@5 shadow.VC@3) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$1$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (and (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (= shadow.VC@2 shadow.VC@1)) (and (=> (= (ControlFlow 0 6) 3) inline$AtomicVC.Copy$1$anon3_Then_correct) (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$1$anon3_Else_correct)))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= shadow.VC@2 shadow.VC@0))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$1$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$1$anon3_Else_correct))))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |189|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (not (= second_tid nil)) (>= second_tid 0))))) (and (=> (= (ControlFlow 0 7) 5) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 7) 6) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct)))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 13) (let ((inline$AtomicVC.Copy$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@2 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@2 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@2 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@2 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 12) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 11) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |190|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (not (= second_tid nil)) (>= second_tid 0))))) (and (=> (= (ControlFlow 0 13) 11) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 13) 12) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (VCRepOk (select shadow.VC@2 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |191|
)) (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (not (= second_tid nil)) (>= second_tid 0)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)))) (VCRepOk (select shadow.VC@3 first_v1))) (= (|clock#epoch| (select (select shadow.VC@3 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1) (- 0 1))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) (- 0 1)))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) (- 0 1))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@3 first_v1) first_j) (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@3 (store (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1 (select shadow.VC@3 first_v1)))) (= shadow.Lock shadow.Lock)) (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j@@0 Int) ) (!  (=> (<= 0 second_j@@0) (= (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) second_j@@0) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j@@0)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j@@0)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j@@0))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j@@0)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j@@0))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)))) (= shadow.VC@3 (store (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2)))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@3 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@3 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@3 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@2 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@2 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@3 (store shadow.VC@2 second_v1@@0 (select shadow.VC@3 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |192|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (not (= second_tid nil)) (>= second_tid 0))))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVC.Copy$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@2 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@2 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 11) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 10) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |193|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (not (= second_tid nil)) (>= second_tid 0))))) (and (=> (= (ControlFlow 0 12) 10) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 12) 11) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (VCRepOk (select shadow.VC@4 first_v1)) (= (|clock#epoch| (select (select shadow.VC@4 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v2) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@4 first_v1) first_j) (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1 (select shadow.VC@4 first_v1)))) (= shadow.Lock shadow.Lock)) (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1 (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v2))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@3 (store shadow.VC@2 second_v (store (select shadow.VC@2 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@2 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@4 (store shadow.VC@3 second_v (store (select shadow.VC@3 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@3 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@3 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |194|
)) (=> (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v))) (and (>= second_i 0) (not (is-ShadowableVar second_v)))) (and (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (not (= second_tid nil)) (>= second_tid 0)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 10) (let ((inline$AtomicVC.Copy$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@2 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@2 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 9) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 8) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |195|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))))) (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (not (= second_tid nil)) (>= second_tid 0))))) (and (=> (= (ControlFlow 0 10) 8) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 10) 9) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Copy_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v1)) (VCRepOk (select shadow.VC@1 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |196|
)) (=> (and (not (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (VCRepOk (select shadow.VC@@0 second_v))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Copy_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (VCRepOk (select shadow.VC@2 first_v1))) (= (|clock#epoch| (select (select shadow.VC@2 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@2 first_v1) first_j) (select (select shadow.VC@@0 first_v2) first_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@2 first_v1)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@2 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2)))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@2 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 first_v1 (select shadow.VC@@0 first_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 5) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 4) 3))) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |197|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock@0 first_v2) first_tid)) (= (select shadow.Lock@0 first_v1) first_tid)) (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |198|
)) (=> (and (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@0 first_v1) first_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |199|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@0 first_v1) first_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 second_r) second_i))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@0 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |200|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@0 first_v1) first_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar second_x)) second_tid))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@0 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |201|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (|clock#epoch| (select (select shadow.VC@2 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v2) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@2 first_v1) first_j) (epoch (|tid#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1) first_j)) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1) first_j)) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v2) first_j))) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v2) first_j)) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@2 (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v1 (select shadow.VC@2 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (store (select shadow.VC@1 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@1 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |202|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4))))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |203|
)) (=> (and (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (|clock#epoch| (select (select shadow.VC@2 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v2) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@2 first_v1) first_j) (epoch (|tid#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1) first_j)) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1) first_j)) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v2) first_j))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v2) first_j)) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v1 (select shadow.VC@2 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) second_i second_e))) (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r (store (select shadow.VC@1 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@1 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |204|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4))))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |205|
)) (=> (and (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock second_r) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v1)) (= (|clock#epoch| (select (select shadow.VC@1 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1) (- 0 1))) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v2) (- 0 1))) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@1 first_v1) first_j) (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1) first_j)) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1) first_j)) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v2) first_j))) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v2) first_j)) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v1 (select shadow.VC@1 first_v1)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |206|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |207|
)) (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct)))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@0 first_v1) first_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|tid#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (<= (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
)))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@0 second_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@0 second_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |208|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (not (is-ShadowableVar second_v2)))) (and (and (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) second_v1@@0)))) (VCRepOk (select shadow.VC@3 first_v1))) (= (|clock#epoch| (select (select shadow.VC@3 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1) (- 0 1))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) (- 0 1)))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) (- 0 1))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@3 first_v1) first_j) (epoch (|tid#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1) first_j)) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1) first_j)) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) first_j))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v2) first_j)) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@3 (store (witness shadow.VC@@0 shadow.VC@3 second_v1@@0) first_v1 (select shadow.VC@3 first_v1)))) (= shadow.Lock shadow.Lock)) (and (and (and (and (VCRepOk (select shadow.VC@3 first_v1)) (= (|clock#epoch| (select (select shadow.VC@3 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1) (- 0 1))) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) (- 0 1))) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1) (- 0 1)))))) (forall ((first_j@@0 Int) ) (!  (=> (<= 0 first_j@@0) (= (select (select shadow.VC@3 first_v1) first_j@@0) (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1) first_j@@0)) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1) first_j@@0)) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) first_j@@0))) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v2) first_j@@0)) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1) first_j@@0))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@3 (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v1 (select shadow.VC@3 first_v1)))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@2 (store shadow.VC@0 second_v1@@0 (select shadow.VC@0 second_v2))) (=> (and (= shadow.VC@3 shadow.VC@2) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@1 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@1 (store shadow.VC@0 second_v1@@0 (select shadow.VC@1 second_v1@@0)))) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (and (and (VCRepOk (select shadow.VC@0 first_v1)) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (and (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
)) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |209|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVC.Join$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 11) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |210|
)) (=> (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11)))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |211|
)) (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (not (= second_tid nil)) (>= second_tid 0)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) second_v1@@0)))) (VCRepOk (select shadow.VC@1 first_v1))) (= (|clock#epoch| (select (select shadow.VC@1 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1) (- 0 1))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v2) (- 0 1)))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v2) (- 0 1))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@1 first_v1) first_j) (epoch (|tid#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1) first_j)) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1) first_j)) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v2) first_j))) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v2) first_j)) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@1 (store (witness shadow.VC@@0 shadow.VC@1 second_v1@@0) first_v1 (select shadow.VC@1 first_v1)))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$1$anon0_correct  (=> (VCRepOk (select shadow.VC@1 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$1$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$1$j) (= (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$1$j) (epoch (|tid#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$1$j)) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$1$j)) (|clock#epoch| (select (select shadow.VC@0 second_v2) inline$AtomicVC.Join$1$j))) (|clock#epoch| (select (select shadow.VC@0 second_v2) inline$AtomicVC.Join$1$j)) (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$1$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@1 (store shadow.VC@0 second_v1@@0 (select shadow.VC@1 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$1$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Join$1$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |212|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVC.Join$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 10) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |213|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 11) 10)))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (VCRepOk (select shadow.VC@2 first_v1)) (= (|clock#epoch| (select (select shadow.VC@2 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v2) (- 0 1)))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v2) (- 0 1))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@2 first_v1) first_j) (epoch (|tid#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1) first_j)) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1) first_j)) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v2) first_j))) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v2) first_j)) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@2 (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v1 (select shadow.VC@2 first_v1)))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@2 (store shadow.VC@1 second_v (store (select shadow.VC@1 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@1 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@1 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |214|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v)))) (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct))))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVC.Join$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0))) (= (ControlFlow 0 8) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |215|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8)))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Join_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |216|
)) (=> (and (not (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v2)) (not (is-ShadowableVar first_v2))) (not (is-ShadowableVar first_v1))) (= (select shadow.Lock first_v2) first_tid)) (= (select shadow.Lock first_v1) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (VCRepOk (select shadow.VC@@0 second_v))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Join_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (VCRepOk (select shadow.VC@0 first_v1))) (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1)))))) (forall ((first_j Int) ) (!  (=> (<= 0 first_j) (= (select (select shadow.VC@0 first_v1) first_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) first_j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) first_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid)))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 first_v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 first_v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 first_v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 first_v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 first_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 first_v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 first_v1 (select shadow.VC@0 first_v1))) (= (ControlFlow 0 4) 3))) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |217|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Join$0$anon0_correct)))
inline$AtomicVC.Join$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock@0 first_v) first_tid)) (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |218|
)) (=> (and (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid second_tid)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v (store (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) 1)))))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@1 (ShadowableTid second_tid)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |219|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 second_r) second_i)) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v (store (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) 1)))))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 second_r) second_i)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |220|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar second_x)) second_tid)) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v (store (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@1 (ShadowableVar second_x)) second_tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |221|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (=> (and (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1))))))) first_v (store (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))) first_v) (- 0 1))))))) first_v) first_i)) 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar second_x) (store (select shadow.VC@1 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar second_x) (store (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |222|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |223|
)) (=> (and (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct)))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1))))))) first_v (store (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))) first_v) (- 0 1))))))) first_v) first_i)) 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_r (store (select shadow.VC@1 second_r) second_i second_e))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_r (store (select shadow.VC@2 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@2 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |224|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |225|
)) (=> (and (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock second_r) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct)))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (= shadow.VC@2 (store (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v (store (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) first_v) (- 0 1))))))) first_v) first_i)) 1))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@2 (store shadow.VC@1 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |226|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |227|
)) (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVCInit$0$anon0_correct)))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (= inline$AtomicVC.Leq$0$res@1 (forall ((second_j Int) ) (!  (=> (and (<= 0 second_j) (f second_j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|tid#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (<= (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f second_j))
))) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v (store (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) 1)))))) (= shadow.Lock shadow.Lock)) (= sx.R sx.R))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |228|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (not (is-ShadowableVar second_v2)))) (and (and (and (=> (is-ShadowableVar second_v1@@0) (= (select sx.R (|x#ShadowableVar| second_v1@@0)) SHARED)) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid)) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) second_v1@@0)))) (= shadow.VC@4 (store (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1))))))) first_v (store (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v (store (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@4 second_v1@@0) first_v) (- 0 1))))))) first_v) first_i)) 1)))))) (= shadow.Lock shadow.Lock)) (and (= shadow.VC@4 (store (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1))))))) first_v (store (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v (store (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)) first_v) (- 0 1))))))) first_v) first_i)) 1))))) (= shadow.Lock shadow.Lock)))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@3 (store shadow.VC@1 second_v1@@0 (select shadow.VC@1 second_v2))) (=> (and (= shadow.VC@4 shadow.VC@3) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@1 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1)))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |229|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (=> (and (and (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicVC.Inc$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@1 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 11) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |230|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v)))) (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@2 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |231|
)) (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))) (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2)))) (=> (and (and (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))) (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid))) (and (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2))) (and (not (= second_tid nil)) (>= second_tid 0)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (VCRepOk (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)) (= (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0) second_j) (epoch (|tid#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) second_j)) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) second_j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (= (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) (store shadow.VC@@0 second_v1@@0 (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) second_v1@@0)))) (= shadow.VC@2 (store (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1))))))) first_v (store (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v (store (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (witness shadow.VC@@0 shadow.VC@2 second_v1@@0) first_v) (- 0 1))))))) first_v) first_i)) 1)))))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@2 second_v1@@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@1 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@2 second_v1@@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@1 second_v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@1 second_v1@@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@2 (store shadow.VC@1 second_v1@@0 (select shadow.VC@2 second_v1@@0))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |232|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0)))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Join_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 11) (let ((inline$AtomicVC.Inc$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@1 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock first_v2) first_tid))) (=> (=> true (= (select shadow.Lock first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock first_v1) first_tid))) (=> (=> true (= (select shadow.Lock first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 10) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |233|
)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v)))) (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 11) 10)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$1$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= shadow.VC@3 (store (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1))))))) first_v (store (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v (store (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))) first_v) (- 0 1))))))) first_v) first_i)) 1))))) (= shadow.Lock shadow.Lock))))))
(let ((inline$AtomicVC.Inc$1$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 second_v (store (select shadow.VC@1 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@1 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@3 (store shadow.VC@2 second_v (store (select shadow.VC@2 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@2 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@2 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$1$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicVC.Inc$1$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |234|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v)))) (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicVC.Inc$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@1 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@1 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock first_v) first_tid))) (=> (=> true (= (select shadow.Lock first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 8) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |235|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (VCRepOk (select shadow.VC@@0 second_v)))) (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8)))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicVC.Inc_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (and (VCRepOk (select shadow.VC@1 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |236|
)) (=> (and (not (and (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v)) (>= first_i 0)) (not (is-ShadowableVar first_v))) (= (select shadow.Lock first_v) first_tid)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0)))) (VCRepOk (select shadow.VC@@0 second_v))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicVC.Inc_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (= shadow.VC@1 (store (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v (store (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))))))) first_v) first_i)) 1))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 first_v (store (select shadow.VC@@0 first_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1))) (+ first_i 1)) (+ first_i 1) (|clock#epoch| (select (select shadow.VC@@0 first_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 first_v (store (select shadow.VC@0 first_v) first_i (epoch (|tid#epoch| (select (select shadow.VC@0 first_v) first_i)) (+ (|clock#epoch| (select (select shadow.VC@0 first_v) first_i)) 1))))) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |237|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicVC.Inc$0$anon0_correct)))))
inline$AtomicVC.Inc$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun first_uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicReleaseJoinLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid first_uid) nil))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid first_uid) nil)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |238|
)) (=> (and (and (= (select shadow.Lock (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid))) (and (not (= first_uid nil)) (>= first_uid 0))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseJoinLock$0$anon0_correct)))))
inline$AtomicReleaseJoinLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |239|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_uid () Int)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicReleaseJoinLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid))) (and (not (= first_uid nil)) (>= first_uid 0))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |240|
)) (=> (and (not (and (and (and (= (select shadow.Lock (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid))) (and (not (= first_uid nil)) (>= first_uid 0))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |241|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |242|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |243|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |244|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |245|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseJoinLock$0$anon0_correct))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |246|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseJoinLock$0$anon0_correct)))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |247|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseJoinLock$0$anon0_correct)))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |248|
)) (=> (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= first_tid nil)) (>= first_tid 0))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseJoinLock$0$anon0_correct)))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |249|
)) (not (is-ShadowableVar first_v2))) (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0)))) (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 11) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |250|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0)))) (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_uid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |251|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0)))) (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicChooseThreadToJoin_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (not (= first_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3)) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (= (select (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil)) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) first_tid))) (= thread.HasJoined@0 (store thread.HasJoined first_tid inline$AtomicChooseThreadToJoin$0$uid@0 true))) (= thread.State thread.State))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= first_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) first_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined first_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseVarLock$0$anon0_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |252|
)) (=> (and (and (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
inline$AtomicChooseThreadToJoin$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |253|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |254|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |255|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |256|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |257|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 4) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |258|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 5) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |259|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 6) 5))) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 5) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |260|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 6) 5))) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 5) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |261|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 6) 5))) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 8) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |262|
)) (not (is-ShadowableVar first_v2))) (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 9) 8))) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 11) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |263|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 12) 11))) inline$AtomicChooseThreadToJoin$0$anon0_correct))))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= second_tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) second_tid))) (and (= thread.HasJoined@0 (store thread.HasJoined second_tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 8) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |264|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (=> (and (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 9) 8))) inline$AtomicChooseThreadToJoin$0$anon0_correct))))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (= shadow.VC@@0 shadow.VC@@0))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |265|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) 0) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |266|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicAllocTid_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) 0) (= (select shadow.Lock@0 (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)) (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0)))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |267|
)) (=> (and (not (and (forall ((first_t@@0 Int) ) (!  (=> (= (select thread.State first_t@@0) 0) (= (select shadow.Lock (ShadowableTid first_t@@0)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)) (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0))))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |268|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |269|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |270|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |271|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |272|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(declare-fun second_e () T@Epoch)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@1 (store (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x) (store (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e)) (ShadowableVar second_x)) (- 0 1))))))))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar second_x) (store (select shadow.VC@@0 (ShadowableVar second_x)) second_tid second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar second_x) (store (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1))) (+ second_tid 1)) (+ second_tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar second_x)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |273|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) 0) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (= (select sx.R second_x) SHARED) (= (ControlFlow 0 5) 4)))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 5) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |274|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 6) 5))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun second_e () T@Epoch)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@1 (store (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r (store (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e)) second_r) (- 0 1))))))))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (= sx.R sx.R))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_r (store (select shadow.VC@@0 second_r) second_i second_e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_r (store (select shadow.VC@0 second_r) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@0 second_r) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |275|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) 0) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0))) (= (select shadow.Lock second_r) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (and (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))) (= (ControlFlow 0 5) 4)))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 5) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |276|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
)))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 6) 5))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_r () T@Shadowable)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (= sx.R sx.R))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 second_r (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicVCInit$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |277|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) 0) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0))) (and (= (select shadow.Lock second_r) second_tid) (=> (is-ShadowableVar second_r) (not (= (select sx.R (|x#ShadowableVar| second_r)) SHARED))))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 5) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |278|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 6) 5))) inline$AtomicAllocTid$0$anon0_correct)))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 8) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |279|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 9) 8))) inline$AtomicAllocTid$0$anon0_correct)))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v1@@0 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v2 () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (or (and (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@2 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@2 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (forall ((second_j Int) ) (!  (=> (<= 0 second_j) (= (select (select shadow.VC@2 second_v1@@0) second_j) (select (select shadow.VC@@0 second_v2) second_j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@2 second_v1@@0)))) (not (= first_tid inline$AtomicAllocTid$0$uid@0))) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@2 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@2 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@2 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2)))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@1 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@@0 second_v2))) (=> (and (= shadow.VC@2 shadow.VC@1) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@0 second_v1@@0)) (= (|clock#epoch| (select (select shadow.VC@0 second_v1@@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 second_v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 second_v1@@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 second_v1@@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 second_v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@0 (store shadow.VC@@0 second_v1@@0 (select shadow.VC@0 second_v1@@0)))) (and (= shadow.VC@2 shadow.VC@0) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (=> (and (and (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1)) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid)) (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct)))))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |280|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) 0) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0)))) (and (and (VCRepOk (select shadow.VC@@0 second_v1@@0)) (VCRepOk (select shadow.VC@@0 second_v2))) (and (not (is-ShadowableVar second_v2)) (not (is-ShadowableVar second_v1@@0))))) (and (and (and (= (select shadow.Lock second_v2) second_tid) (= (select shadow.Lock second_v1@@0) second_tid)) (and (= (select shadow.Lock (ShadowableTid second_tid)) second_tid) (not (= second_v1@@0 second_v2)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5)))) inline$AtomicAllocTid$0$anon0_correct)))
inline$AtomicAllocTid$0$Entry_correct))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 11) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |281|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 12) 11)))) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_v () T@Shadowable)
(declare-fun second_i () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicAllocTid_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (and (and (and (and (and (and (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0)) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@0)))) (= shadow.VC@1 (store (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v (store (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i (epoch (|tid#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) (+ (|clock#epoch| (select (select (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))))))) second_v) second_i)) 1)))))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid))) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 second_v (store (select shadow.VC@@0 second_v) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1))) (+ second_i 1)) (+ second_i 1) (|clock#epoch| (select (select shadow.VC@@0 second_v) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 second_v (store (select shadow.VC@0 second_v) second_i (epoch (|tid#epoch| (select (select shadow.VC@0 second_v) second_i)) (+ (|clock#epoch| (select (select shadow.VC@0 second_v) second_i)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= first_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 first_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) first_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 4) 3)))) inline$AtomicVC.Inc$0$anon0_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |282|
)) (forall ((first_t Int) ) (!  (=> (= (select thread.State first_t) 0) (= (select shadow.Lock (ShadowableTid first_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (=> (and (and (= (select thread.State first_tid) 2) (and (not (= first_tid nil)) (>= first_tid 0))) (VCRepOk (select shadow.VC@@0 second_v))) (=> (and (and (and (>= second_i 0) (not (is-ShadowableVar second_v))) (and (= (select shadow.Lock second_v) second_tid) (= (select shadow.Lock (ShadowableTid second_tid)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicAllocTid$0$anon0_correct)))))
inline$AtomicAllocTid$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicAllocTid$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= second_tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 second_tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) second_tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 8) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |283|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (forall ((second_t Int) ) (!  (=> (= (select thread.State second_t) 0) (= (select shadow.Lock (ShadowableTid second_t)) nil))
 :qid |unknown.0:0|
 :skolemid |39|
))) (and (and (= (select thread.State second_tid) 2) (and (not (= second_tid nil)) (>= second_tid 0))) (= (ControlFlow 0 9) 8))) inline$AtomicAllocTid$0$anon0_correct)))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun first_uid () Int)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicStartThread_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= thread.State@0 (store thread.State first_uid 2)) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableTid first_uid) first_uid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State first_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid first_uid) first_uid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |284|
)) (= (select thread.State first_uid) 1)) (=> (and (and (= (select shadow.Lock (ShadowableTid first_uid)) first_tid) (not (= first_tid first_uid))) (and (not (= first_uid nil)) (>= first_uid 0))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |285|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun first_uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicStartThread_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (and (and (and (= (select thread.State first_uid) 1) (= (select shadow.Lock@0 (ShadowableTid first_uid)) first_tid)) (not (= first_tid first_uid))) (and (not (= first_uid nil)) (>= first_uid 0))) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |286|
)) (=> (and (not (and (and (and (and (= (select thread.State first_uid) 1) (= (select shadow.Lock (ShadowableTid first_uid)) first_tid)) (not (= first_tid first_uid))) (and (not (= first_uid nil)) (>= first_uid 0))) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |287|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |288|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |289|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |290|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 4) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |291|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 5) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |292|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select thread.State second_uid) 1))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 5) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |293|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select thread.State second_uid) 1))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 5) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |294|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicStartThread$0$anon0_correct))))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 8) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |295|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1))) (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 11) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |296|
)) (=> (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (=> (and (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2)))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1))) (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11)))) inline$AtomicStartThread$0$anon0_correct)))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun second_uid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicStartThread$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State second_uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid second_uid) second_uid)) (= (ControlFlow 0 8) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |297|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select thread.State second_uid) 1))) (and (and (and (= (select shadow.Lock (ShadowableTid second_uid)) second_tid) (not (= second_tid second_uid))) (and (not (= second_uid nil)) (>= second_uid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8)))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicChooseLockToAcquire_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) first_tid)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) first_tid)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |298|
)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |299|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct)))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |300|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct)))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |301|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct)))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |302|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct)))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |303|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct)))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 4) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |304|
)) (= (select shadow.Lock first_r) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToAcquire$0$anon0_correct)))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |305|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select sx.R first_x) SHARED)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |306|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 5) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |307|
)) (=> (and (and (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 8) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |308|
)) (not (is-ShadowableVar first_v2))) (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 11) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |309|
)) (=> (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (=> (and (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1))) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) second_tid)) (= (ControlFlow 0 8) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |310|
)) (VCRepOk (select shadow.VC@@0 first_v))) (and (>= first_i 0) (not (is-ShadowableVar first_v)))) (=> (and (and (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (not (= first_tid nil)) (>= first_tid 0))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicChooseLockToAcquire$0$anon0_correct))))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToRelease$0$l@0 () T@Lock)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicChooseLockToRelease_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (= (select shadow.Lock@0 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) first_tid) (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (and (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) first_tid) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))
(let ((inline$AtomicChooseLockToRelease$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |311|
)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicChooseLockToRelease$0$anon0_correct))))
inline$AtomicChooseLockToRelease$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun first_l () T@Lock)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_CommutativityChecker_AtomicReleaseChosenLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= shadow.Lock@1 (store (store shadow.Lock (ShadowableVar second_x) nil) (ShadowableLock first_l) nil))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@1 (store shadow.Lock@0 (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock first_l) nil)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |312|
)) (= (select shadow.Lock (ShadowableLock first_l)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicReleaseVarLock_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |313|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_l () T@Lock)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_x () T@Var)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_FailurePreservationChecker_AtomicReleaseChosenLock_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (not (and (= (select shadow.Lock@0 (ShadowableLock first_l)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar second_x) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |314|
)) (=> (and (not (and (= (select shadow.Lock (ShadowableLock first_l)) first_tid) (and (not (= first_tid nil)) (>= first_tid 0)))) (= (select shadow.Lock (ShadowableVar second_x)) second_tid)) (=> (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct)))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicThreadStateGetE_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |315|
)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetW_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |316|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVarStateGetR_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |317|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetSize_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |318|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCGetElem_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 4) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |319|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 5) 4))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_x () T@Var)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElemShared_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableVar first_x)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (= (select sx.R first_x) SHARED)))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |320|
)) (= (select shadow.Lock (ShadowableVar first_x)) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (= (select sx.R first_x) SHARED) (= (select shadow.Lock (ShadowableLock second_l)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCSetElem_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (and (not (= first_tid nil)) (>= first_tid 0)))) (=> (=> true (and (not (= first_tid nil)) (>= first_tid 0))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |321|
)) (= (select shadow.Lock first_r) first_tid)) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (and (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))) (= (select shadow.Lock (ShadowableLock second_l)) second_tid))) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_r () T@Shadowable)
(declare-fun first_tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVCInit_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 6) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_r) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_r) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED))))) (=> (=> true (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 5) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |322|
)) (=> (and (= (select shadow.Lock first_r) first_tid) (=> (is-ShadowableVar first_r) (not (= (select sx.R (|x#ShadowableVar| first_r)) SHARED)))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 6) 5))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun first_v2 () T@Shadowable)
(declare-fun first_v1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Leq_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)))) (=> (=> true (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |323|
)) (not (is-ShadowableVar first_v2))) (=> (and (and (=> (is-ShadowableVar first_v1) (= (select sx.R (|x#ShadowableVar| first_v1)) SHARED)) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid)) (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v1 () T@Shadowable)
(declare-fun first_v2 () T@Shadowable)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Copy_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 12) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 10)) (=> true (VCRepOk (select shadow.VC@@0 first_v1)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (=> true (VCRepOk (select shadow.VC@@0 first_v2)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (=> true (not (is-ShadowableVar first_v2)))) (=> (=> true (not (is-ShadowableVar first_v2))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (not (is-ShadowableVar first_v1)))) (=> (=> true (not (is-ShadowableVar first_v1))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (= (select shadow.Lock@0 first_v2) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v2) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (= (select shadow.Lock@0 first_v1) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v1) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (not (= first_v1 first_v2)))) (=> (=> true (not (= first_v1 first_v2))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 11) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |324|
)) (=> (and (and (and (and (VCRepOk (select shadow.VC@@0 first_v1)) (VCRepOk (select shadow.VC@@0 first_v2))) (and (not (is-ShadowableVar first_v2)) (not (is-ShadowableVar first_v1)))) (and (and (= (select shadow.Lock first_v2) first_tid) (= (select shadow.Lock first_v1) first_tid)) (and (= (select shadow.Lock (ShadowableTid first_tid)) first_tid) (not (= first_v1 first_v2))))) (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 12) 11)))) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun first_v () T@Shadowable)
(declare-fun first_i () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun first_tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun second_l () T@Lock)
(declare-fun second_tid () Int)
(set-info :boogie-vc-id Civl_GatePreservationChecker_AtomicVC.Inc_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 9) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (and (=> (= (ControlFlow 0 2) (- 0 7)) (=> true (VCRepOk (select shadow.VC@@0 first_v)))) (=> (=> true (VCRepOk (select shadow.VC@@0 first_v))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> true (>= first_i 0))) (=> (=> true (>= first_i 0)) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> true (not (is-ShadowableVar first_v)))) (=> (=> true (not (is-ShadowableVar first_v))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> true (= (select shadow.Lock@0 first_v) first_tid))) (=> (=> true (= (select shadow.Lock@0 first_v) first_tid)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid))) (=> (=> true (= (select shadow.Lock@0 (ShadowableTid first_tid)) first_tid)) (=> (= (ControlFlow 0 2) (- 0 1)) (=> true (and (not (= first_tid nil)) (>= first_tid 0))))))))))))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock second_l) nil)) (= (ControlFlow 0 8) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (and (exists ((Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) first_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) (store ((as const (Array Int Bool)) false) second_tid true) ((_ map (= (Int Int) Bool)) Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |325|
)) (VCRepOk (select shadow.VC@@0 first_v))) (=> (and (and (>= first_i 0) (not (is-ShadowableVar first_v))) (and (= (select shadow.Lock first_v) first_tid) (= (select shadow.Lock (ShadowableTid first_tid)) first_tid))) (=> (and (and (and (not (= first_tid nil)) (>= first_tid 0)) (= (select shadow.Lock (ShadowableLock second_l)) second_tid)) (and (and (not (= second_tid nil)) (>= second_tid 0)) (= (ControlFlow 0 9) 8))) inline$AtomicReleaseChosenLock$0$anon0_correct)))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v1 () T@Shadowable)
(declare-fun v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun tid () Int)
(set-info :boogie-vc-id Civl_CooperationChecker_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((init_correct  (=> (= (ControlFlow 0 2) (- 0 1)) true)))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (VCRepOk (select shadow.VC@@0 v1)) (VCRepOk (select shadow.VC@@0 v2))) (and (not (is-ShadowableVar v2)) (not (is-ShadowableVar v1)))) (=> (and (and (and (= (select shadow.Lock v2) tid) (= (select shadow.Lock v1) tid)) (and (= (select shadow.Lock (ShadowableTid tid)) tid) (not (= v1 v2)))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 3) 2))) init_correct))))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun res@0 () Bool)
(declare-fun v1 () T@Shadowable)
(declare-fun v2 () T@Shadowable)
(declare-fun res () Bool)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun inline$AtomicVCGetSize$1$i@1 () Int)
(declare-fun i@0 () Int)
(declare-fun inline$AtomicVCGetElem$0$e@2 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@2 () T@Epoch)
(declare-fun i@1 () Int)
(set-info :boogie-vc-id Civl_VC.Leq_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 50) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 22) (- 0 24)) (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (= res@0 (forall ((j@@2 Int) ) (!  (=> (and (<= 0 j@@2) (f j@@2)) (and (= (|tid#epoch| (select (select shadow.VC@0 v1) j@@2)) (|tid#epoch| (select (select shadow.VC@0 v2) j@@2))) (<= (|clock#epoch| (select (select shadow.VC@0 v1) j@@2)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@2)))))
 :qid |verifiedftbpl.326:19|
 :skolemid |15|
 :pattern ( (f j@@2))
))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (= res@0 (forall ((j@@3 Int) ) (!  (=> (and (<= 0 j@@3) (f j@@3)) (and (= (|tid#epoch| (select (select shadow.VC@0 v1) j@@3)) (|tid#epoch| (select (select shadow.VC@0 v2) j@@3))) (<= (|clock#epoch| (select (select shadow.VC@0 v1) j@@3)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@3)))))
 :qid |verifiedftbpl.326:19|
 :skolemid |15|
 :pattern ( (f j@@3))
))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 22) (- 0 23)) (=> false (and (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (= res@0 res)))) (=> (=> false (and (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (= res@0 res))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (= res@0 (forall ((j@@4 Int) ) (!  (=> (and (<= 0 j@@4) (f j@@4)) (and (= (|tid#epoch| (select (select shadow.VC@0 v1) j@@4)) (|tid#epoch| (select (select shadow.VC@0 v2) j@@4))) (<= (|clock#epoch| (select (select shadow.VC@0 v1) j@@4)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@4)))))
 :qid |verifiedftbpl.326:19|
 :skolemid |15|
 :pattern ( (f j@@4))
))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (= res@0 res) false)))) (= (ControlFlow 0 22) (- 0 21))) Civl_ok@0)))))))
(let ((anon5_LoopDone_@2_Civl_ReturnChecker_correct  (=> (and (= res@0 true) (= (ControlFlow 0 36) 22)) Civl_ReturnChecker_correct)))
(let ((anon6_Then_@2_Civl_ReturnChecker_correct  (=> (and (= res@0 false) (= (ControlFlow 0 25) 22)) Civl_ReturnChecker_correct)))
(let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 18) (- 0 20)) (and (forall ((s T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@0))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 18) (- 0 19)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 18) (- 0 17)) (and (and (and (and (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@0 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select sx.R x@@0) SHARED) (= (select sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@1) tid) (= (select shadow.VC@0 s@@1) (select shadow.VC@@0 s@@1)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@1)) tid) (= (select sx.R@0 x@@1) (select sx.R x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@2)) tid) (= (select sx.W@0 x@@2) (select sx.W x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= (ControlFlow 0 16) (- 0 15))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 13) (- 0 14)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 13) (- 0 12)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@0 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@0 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 10) (- 0 11)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 10) (- 0 9)) (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@0 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@7)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@0 x@@7) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@8)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@0 x@@8) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 5) (- 0 7)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 5) (- 0 6)) (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 5) (- 0 4)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((anon5_LoopDone_correct  (=> (<= (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1) i@0) (and (and (and (and (and (and (=> (= (ControlFlow 0 37) 36) anon5_LoopDone_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 37) 5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 37) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 37) 10) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 37) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 37) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)) (=> (= (ControlFlow 0 37) 18) GeneratedUnifiedExit_correct)))))
(let ((anon6_Then_correct  (=> (not (and (= (|tid#epoch| inline$AtomicVCGetElem$0$e@2) (|tid#epoch| inline$AtomicVCGetElem$1$e@2)) (<= (|clock#epoch| inline$AtomicVCGetElem$0$e@2) (|clock#epoch| inline$AtomicVCGetElem$1$e@2)))) (and (=> (= (ControlFlow 0 26) (- 0 27)) (f i@0)) (=> (f i@0) (and (and (and (and (and (and (=> (= (ControlFlow 0 26) 25) anon6_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 26) 5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 26) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 26) 10) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 26) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 26) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)) (=> (= (ControlFlow 0 26) 18) GeneratedUnifiedExit_correct)))))))
(let ((anon6_Else_correct  (=> (and (and (= (|tid#epoch| inline$AtomicVCGetElem$0$e@2) (|tid#epoch| inline$AtomicVCGetElem$1$e@2)) (<= (|clock#epoch| inline$AtomicVCGetElem$0$e@2) (|clock#epoch| inline$AtomicVCGetElem$1$e@2))) (= i@1 (+ i@0 1))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (<= 0 i@1)) (=> (<= 0 i@1) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((j@@5 Int) ) (!  (=> (and (and (<= 0 j@@5) (< j@@5 i@1)) (f j@@5)) (and (= (|tid#epoch| (select (select shadow.VC@0 v1) j@@5)) (|tid#epoch| (select (select shadow.VC@0 v2) j@@5))) (<= (|clock#epoch| (select (select shadow.VC@0 v1) j@@5)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@5)))))
 :qid |verifiedftbpl.345:35|
 :skolemid |16|
 :pattern ( (f j@@5))
))))))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@2 (select (select shadow.VC@0 v2) i@0)) (and (=> (= (ControlFlow 0 28) 26) anon6_Then_correct) (=> (= (ControlFlow 0 28) 2) anon6_Else_correct)))))
(let ((anon5_LoopBody$1_correct  (and (=> (= (ControlFlow 0 29) (- 0 31)) (= (select shadow.Lock@0 v2) tid)) (=> (= (select shadow.Lock@0 v2) tid) (and (=> (= (ControlFlow 0 29) (- 0 30)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 29) 28) inline$AtomicVCGetElem$1$anon0_correct)))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@2 (select (select shadow.VC@0 v1) i@0)) (= (ControlFlow 0 32) 29)) anon5_LoopBody$1_correct)))
(let ((anon5_LoopBody_correct  (=> (< i@0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 33) (- 0 35)) (= (select shadow.Lock@0 v1) tid)) (=> (= (select shadow.Lock@0 v1) tid) (and (=> (= (ControlFlow 0 33) (- 0 34)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 33) 32) inline$AtomicVCGetElem$0$anon0_correct))))))))
(let ((anon5_LoopHead_correct  (=> (and (<= 0 i@0) (forall ((j@@6 Int) ) (!  (=> (and (and (<= 0 j@@6) (< j@@6 i@0)) (f j@@6)) (and (= (|tid#epoch| (select (select shadow.VC@0 v1) j@@6)) (|tid#epoch| (select (select shadow.VC@0 v2) j@@6))) (<= (|clock#epoch| (select (select shadow.VC@0 v1) j@@6)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@6)))))
 :qid |verifiedftbpl.345:35|
 :skolemid |16|
 :pattern ( (f j@@6))
))) (and (=> (= (ControlFlow 0 38) 37) anon5_LoopDone_correct) (=> (= (ControlFlow 0 38) 33) anon5_LoopBody_correct)))))
(let ((anon0$2_correct  (and (=> (= (ControlFlow 0 39) (- 0 41)) (<= 0 0)) (=> (<= 0 0) (and (=> (= (ControlFlow 0 39) (- 0 40)) (forall ((j@@7 Int) ) (!  (=> (and (and (<= 0 j@@7) (< j@@7 0)) (f j@@7)) (and (= (|tid#epoch| (select (select shadow.VC@0 v1) j@@7)) (|tid#epoch| (select (select shadow.VC@0 v2) j@@7))) (<= (|clock#epoch| (select (select shadow.VC@0 v1) j@@7)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@7)))))
 :qid |verifiedftbpl.345:35|
 :skolemid |16|
 :pattern ( (f j@@7))
))) (=> (forall ((j@@8 Int) ) (!  (=> (and (and (<= 0 j@@8) (< j@@8 0)) (f j@@8)) (and (= (|tid#epoch| (select (select shadow.VC@0 v1) j@@8)) (|tid#epoch| (select (select shadow.VC@0 v2) j@@8))) (<= (|clock#epoch| (select (select shadow.VC@0 v1) j@@8)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@8)))))
 :qid |verifiedftbpl.345:35|
 :skolemid |16|
 :pattern ( (f j@@8))
)) (=> (= (ControlFlow 0 39) 38) anon5_LoopHead_correct)))))))
(let ((inline$AtomicVCGetSize$1$anon0_correct  (=> (and (= inline$AtomicVCGetSize$1$i@1 (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))) (= (ControlFlow 0 42) 39)) anon0$2_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 43) (- 0 45)) (= (select shadow.Lock@0 v1) tid)) (=> (= (select shadow.Lock@0 v1) tid) (and (=> (= (ControlFlow 0 43) (- 0 44)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 43) 42) inline$AtomicVCGetSize$1$anon0_correct)))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))) (= (ControlFlow 0 46) 43)) anon0$1_correct)))
(let ((anon0_correct  (=> (and (and (forall ((s@@6 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@6))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@7) tid) (= (select shadow.Lock@0 v@@7) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R x@@9) SHARED) (= (select sx.R@0 x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@7) tid) (= (select shadow.VC@0 s@@7) (select shadow.VC@@0 s@@7)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@10)) tid) (= (select sx.R@0 x@@10) (select sx.R x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@11)) tid) (= (select sx.W@0 x@@11) (select sx.W x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (and (and (and (and (not (is-ShadowableVar v2)) (=> (is-ShadowableVar v1) (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED))) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (= (select shadow.Lock@0 v2) tid)) (= (select shadow.Lock@0 v1) tid)) (and (not (= tid nil)) (>= tid 0))) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 47) (- 0 49)) (= (select shadow.Lock@0 v1) tid)) (=> (= (select shadow.Lock@0 v1) tid) (and (=> (= (ControlFlow 0 47) (- 0 48)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 47) 46) inline$AtomicVCGetSize$0$anon0_correct))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (forall ((s@@8 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@8))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@8) tid) (= (select shadow.Lock v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@12 T@Var) ) (!  (=> (= (select sx.R x@@12) SHARED) (= (select sx.R x@@12) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@9) tid) (= (select shadow.VC@@0 s@@9) (select shadow.VC@@0 s@@9)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@13 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@13)) tid) (= (select sx.R x@@13) (select sx.R x@@13)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@14)) tid) (= (select sx.W x@@14) (select sx.W x@@14)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= (ControlFlow 0 50) 47)) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun v2 () T@Shadowable)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun inline$AtomicVCGetSize$1$i@1 () Int)
(declare-fun i@0 () Int)
(declare-fun i@1 () Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCGetElem$0$e@2 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_VC.Copy_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 62) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 37) (- 0 40)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 37) (- 0 39)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@0 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@0 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 37) (- 0 38)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s v1)) (not (= s v1))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@4 s)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 v1)) (not (= s@@0 v1))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@4 s@@0)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 37) (- 0 36)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@4 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (and (= shadow.VC@4 shadow.VC@1) (= (ControlFlow 0 41) 37)) GeneratedUnifiedExit_correct)))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= (ControlFlow 0 35) (- 0 34))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 32) (- 0 33)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 32) (- 0 31)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@0) SHARED) (= (select sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 29) (- 0 30)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 29) (- 0 28)) (and (and (and (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@0 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@1 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@0 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 24) (- 0 26)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 24) (- 0 25)) (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 24) (- 0 23)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (|clock#epoch| (select (select shadow.VC@1 v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (select (select shadow.VC@1 v1) j@@2) (select (select shadow.VC@0 v2) j@@2)))
 :qid |verifiedftbpl.380:24|
 :skolemid |17|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@0 v2))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (|clock#epoch| (select (select shadow.VC@1 v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))))) (forall ((j@@3 Int) ) (!  (=> (<= 0 j@@3) (= (select (select shadow.VC@1 v1) j@@3) (select (select shadow.VC@0 v2) j@@3)))
 :qid |verifiedftbpl.380:24|
 :skolemid |17|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@0 v2))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (and (=> (= (ControlFlow 0 20) (- 0 21)) (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (|clock#epoch| (select (select shadow.VC@1 v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (select (select shadow.VC@1 v1) j@@4) (select (select shadow.VC@0 v2) j@@4)))
 :qid |verifiedftbpl.380:24|
 :skolemid |17|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@0 v2))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) false))) (= (ControlFlow 0 20) (- 0 19))) Civl_ok@0)))))))
(let ((anon2_LoopDone_correct  (=> (<= (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1) i@0) (and (and (and (and (and (and (=> (= (ControlFlow 0 42) 20) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 42) 41) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 42) 24) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 42) 27) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 42) 29) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 42) 32) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 42) 35) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)))))
(let ((anon2_LoopBody$2_correct  (=> (= i@1 (+ i@0 1)) (and (=> (= (ControlFlow 0 2) (- 0 9)) (forall ((s@@6 T@Shadowable) ) (!  (=> (not (= s@@6 v1)) (= (select shadow.VC@3 s@@6) (select shadow.VC@0 s@@6)))
 :qid |verifiedftbpl.407:35|
 :skolemid |18|
))) (=> (forall ((s@@7 T@Shadowable) ) (!  (=> (not (= s@@7 v1)) (= (select shadow.VC@3 s@@7) (select shadow.VC@0 s@@7)))
 :qid |verifiedftbpl.407:35|
 :skolemid |18|
)) (and (=> (= (ControlFlow 0 2) (- 0 8)) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@8) tid) (= (select shadow.Lock@0 s@@8) tid))
 :qid |verifiedftbpl.408:35|
 :skolemid |19|
))) (=> (forall ((s@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@9) tid) (= (select shadow.Lock@0 s@@9) tid))
 :qid |verifiedftbpl.408:35|
 :skolemid |19|
)) (and (=> (= (ControlFlow 0 2) (- 0 7)) (VCRepOk (select shadow.VC@3 v1))) (=> (VCRepOk (select shadow.VC@3 v1)) (and (=> (= (ControlFlow 0 2) (- 0 6)) (>= i@1 0)) (=> (>= i@1 0) (and (=> (= (ControlFlow 0 2) (- 0 5)) (<= i@1 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1))) (=> (<= i@1 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (= (|clock#epoch| (select (select shadow.VC@3 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 i@1) i@1 inline$AtomicVCGetSize$0$i@1))) (=> (= (|clock#epoch| (select (select shadow.VC@3 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 i@1) i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (forall ((j@@5 Int) ) (!  (=> (and (<= 0 j@@5) (< j@@5 i@1)) (= (select (select shadow.VC@3 v1) j@@5) (select (select shadow.VC@3 v2) j@@5)))
 :qid |verifiedftbpl.413:35|
 :skolemid |20|
))) (=> (forall ((j@@6 Int) ) (!  (=> (and (<= 0 j@@6) (< j@@6 i@1)) (= (select (select shadow.VC@3 v1) j@@6) (select (select shadow.VC@3 v2) j@@6)))
 :qid |verifiedftbpl.413:35|
 :skolemid |20|
)) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((j@@7 Int) ) (!  (=> (<= (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1) j@@7) (= (select (select shadow.VC@3 v1) j@@7) (select (select shadow.VC@3 v2) j@@7)))
 :qid |verifiedftbpl.414:35|
 :skolemid |21|
))))))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 v1 (store (select shadow.VC@1 v1) i@0 inline$AtomicVCGetElem$0$e@2))) (=> (and (= shadow.VC@3 (store shadow.VC@2 v1 (store (select shadow.VC@2 v1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 v1) (- 0 1))) (+ i@0 1)) (+ i@0 1) (|clock#epoch| (select (select shadow.VC@2 v1) (- 0 1)))))))) (= (ControlFlow 0 10) 2)) anon2_LoopBody$2_correct))))
(let ((anon2_LoopBody$1_correct  (and (=> (= (ControlFlow 0 11) (- 0 14)) (= (select shadow.Lock@0 v1) tid)) (=> (= (select shadow.Lock@0 v1) tid) (and (=> (= (ControlFlow 0 11) (- 0 13)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (=> (is-ShadowableVar v1) (not (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED)))) (=> (=> (is-ShadowableVar v1) (not (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED))) (=> (= (ControlFlow 0 11) 10) inline$AtomicVCSetElem$0$anon0_correct)))))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@2 (select (select shadow.VC@1 v2) i@0)) (= (ControlFlow 0 15) 11)) anon2_LoopBody$1_correct)))
(let ((anon2_LoopBody_correct  (=> (< i@0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 16) (- 0 18)) (= (select shadow.Lock@0 v2) tid)) (=> (= (select shadow.Lock@0 v2) tid) (and (=> (= (ControlFlow 0 16) (- 0 17)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 16) 15) inline$AtomicVCGetElem$0$anon0_correct))))))))
(let ((anon2_LoopHead_correct  (=> (and (and (and (forall ((s@@10 T@Shadowable) ) (!  (=> (not (= s@@10 v1)) (= (select shadow.VC@1 s@@10) (select shadow.VC@0 s@@10)))
 :qid |verifiedftbpl.407:35|
 :skolemid |18|
)) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@11) tid) (= (select shadow.Lock@0 s@@11) tid))
 :qid |verifiedftbpl.408:35|
 :skolemid |19|
))) (and (VCRepOk (select shadow.VC@1 v1)) (>= i@0 0))) (and (and (<= i@0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (= (|clock#epoch| (select (select shadow.VC@1 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 i@0) i@0 inline$AtomicVCGetSize$0$i@1))) (and (forall ((j@@8 Int) ) (!  (=> (and (<= 0 j@@8) (< j@@8 i@0)) (= (select (select shadow.VC@1 v1) j@@8) (select (select shadow.VC@1 v2) j@@8)))
 :qid |verifiedftbpl.413:35|
 :skolemid |20|
)) (forall ((j@@9 Int) ) (!  (=> (<= (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1) j@@9) (= (select (select shadow.VC@1 v1) j@@9) (select (select shadow.VC@1 v2) j@@9)))
 :qid |verifiedftbpl.414:35|
 :skolemid |21|
))))) (and (=> (= (ControlFlow 0 43) 42) anon2_LoopDone_correct) (=> (= (ControlFlow 0 43) 16) anon2_LoopBody_correct)))))
(let ((anon0$3_correct  (and (=> (= (ControlFlow 0 44) (- 0 52)) (forall ((s@@12 T@Shadowable) ) (!  (=> (not (= s@@12 v1)) (= (select shadow.VC@0 s@@12) (select shadow.VC@0 s@@12)))
 :qid |verifiedftbpl.407:35|
 :skolemid |18|
))) (=> (forall ((s@@13 T@Shadowable) ) (!  (=> (not (= s@@13 v1)) (= (select shadow.VC@0 s@@13) (select shadow.VC@0 s@@13)))
 :qid |verifiedftbpl.407:35|
 :skolemid |18|
)) (and (=> (= (ControlFlow 0 44) (- 0 51)) (forall ((s@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@14) tid) (= (select shadow.Lock@0 s@@14) tid))
 :qid |verifiedftbpl.408:35|
 :skolemid |19|
))) (=> (forall ((s@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@15) tid) (= (select shadow.Lock@0 s@@15) tid))
 :qid |verifiedftbpl.408:35|
 :skolemid |19|
)) (and (=> (= (ControlFlow 0 44) (- 0 50)) (VCRepOk (select shadow.VC@0 v1))) (=> (VCRepOk (select shadow.VC@0 v1)) (and (=> (= (ControlFlow 0 44) (- 0 49)) (>= 0 0)) (=> (>= 0 0) (and (=> (= (ControlFlow 0 44) (- 0 48)) (<= 0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1))) (=> (<= 0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 44) (- 0 47)) (= (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 0) 0 inline$AtomicVCGetSize$0$i@1))) (=> (= (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 0) 0 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 44) (- 0 46)) (forall ((j@@10 Int) ) (!  (=> (and (<= 0 j@@10) (< j@@10 0)) (= (select (select shadow.VC@0 v1) j@@10) (select (select shadow.VC@0 v2) j@@10)))
 :qid |verifiedftbpl.413:35|
 :skolemid |20|
))) (=> (forall ((j@@11 Int) ) (!  (=> (and (<= 0 j@@11) (< j@@11 0)) (= (select (select shadow.VC@0 v1) j@@11) (select (select shadow.VC@0 v2) j@@11)))
 :qid |verifiedftbpl.413:35|
 :skolemid |20|
)) (and (=> (= (ControlFlow 0 44) (- 0 45)) (forall ((j@@12 Int) ) (!  (=> (<= (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1) j@@12) (= (select (select shadow.VC@0 v1) j@@12) (select (select shadow.VC@0 v2) j@@12)))
 :qid |verifiedftbpl.414:35|
 :skolemid |21|
))) (=> (forall ((j@@13 Int) ) (!  (=> (<= (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1) j@@13) (= (select (select shadow.VC@0 v1) j@@13) (select (select shadow.VC@0 v2) j@@13)))
 :qid |verifiedftbpl.414:35|
 :skolemid |21|
)) (=> (= (ControlFlow 0 44) 43) anon2_LoopHead_correct)))))))))))))))))))
(let ((inline$AtomicVCGetSize$1$anon0_correct  (=> (and (= inline$AtomicVCGetSize$1$i@1 (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1)))) (= (ControlFlow 0 53) 44)) anon0$3_correct)))
(let ((anon0$2_correct  (and (=> (= (ControlFlow 0 54) (- 0 56)) (= (select shadow.Lock@0 v2) tid)) (=> (= (select shadow.Lock@0 v2) tid) (and (=> (= (ControlFlow 0 54) (- 0 55)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 54) 53) inline$AtomicVCGetSize$1$anon0_correct)))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))) (= (ControlFlow 0 57) 54)) anon0$2_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 58) (- 0 60)) (= (select shadow.Lock@0 v1) tid)) (=> (= (select shadow.Lock@0 v1) tid) (and (=> (= (ControlFlow 0 58) (- 0 59)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 58) 57) inline$AtomicVCGetSize$0$anon0_correct)))))))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@16 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@16) tid) (= (select shadow.VC@0 s@@16) (select shadow.VC@@0 s@@16)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (forall ((s@@17 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@17))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 v1)) (VCRepOk (select shadow.VC@0 v2))) (not (is-ShadowableVar v2))) (not (is-ShadowableVar v1))) (= (select shadow.Lock@0 v2) tid)) (= (select shadow.Lock@0 v1) tid)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (not (= v1 v2))) (and (not (= tid nil)) (>= tid 0))) (and (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= (ControlFlow 0 61) 58))) anon0$1_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@9) tid) (= (select shadow.Lock v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R x@@9) SHARED) (= (select sx.R x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@18 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@18) tid) (= (select shadow.VC@@0 s@@18) (select shadow.VC@@0 s@@18)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@10)) tid) (= (select sx.R x@@10) (select sx.R x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@11)) tid) (= (select sx.W x@@11) (select sx.W x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@19 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@19))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 62) 61))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun v2 () T@Shadowable)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun inline$AtomicVCGetSize$1$i@1 () Int)
(declare-fun i@0 () Int)
(declare-fun i@1 () Int)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@2 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@2 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_VC.Join_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 67) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 42) (- 0 45)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 42) (- 0 44)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@0 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@0 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 42) (- 0 43)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s v1)) (not (= s v1))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@4 s)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 v1)) (not (= s@@0 v1))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@4 s@@0)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 42) (- 0 41)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@4 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (and (= shadow.VC@4 shadow.VC@1) (= (ControlFlow 0 46) 42)) GeneratedUnifiedExit_correct)))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= (ControlFlow 0 40) (- 0 39))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 37) (- 0 38)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 37) (- 0 36)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@0) SHARED) (= (select sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 34) (- 0 35)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 34) (- 0 33)) (and (and (and (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@0 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@1 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@0 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 29) (- 0 31)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 29) (- 0 30)) (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 29) (- 0 28)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 25) (- 0 27)) (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (|clock#epoch| (select (select shadow.VC@1 v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (select (select shadow.VC@1 v1) j@@2) (epoch (|tid#epoch| (select (select shadow.VC@0 v1) j@@2)) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) j@@2)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@2))) (|clock#epoch| (select (select shadow.VC@0 v2) j@@2)) (|clock#epoch| (select (select shadow.VC@0 v1) j@@2))))))
 :qid |verifiedftbpl.437:20|
 :skolemid |22|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (|clock#epoch| (select (select shadow.VC@1 v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))))) (forall ((j@@3 Int) ) (!  (=> (<= 0 j@@3) (= (select (select shadow.VC@1 v1) j@@3) (epoch (|tid#epoch| (select (select shadow.VC@0 v1) j@@3)) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) j@@3)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@3))) (|clock#epoch| (select (select shadow.VC@0 v2) j@@3)) (|clock#epoch| (select (select shadow.VC@0 v1) j@@3))))))
 :qid |verifiedftbpl.437:20|
 :skolemid |22|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 25) (- 0 26)) (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 v1)) (= (|clock#epoch| (select (select shadow.VC@1 v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (select (select shadow.VC@1 v1) j@@4) (epoch (|tid#epoch| (select (select shadow.VC@0 v1) j@@4)) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) j@@4)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@4))) (|clock#epoch| (select (select shadow.VC@0 v2) j@@4)) (|clock#epoch| (select (select shadow.VC@0 v1) j@@4))))))
 :qid |verifiedftbpl.437:20|
 :skolemid |22|
))) (= shadow.VC@1 (store shadow.VC@0 v1 (select shadow.VC@1 v1)))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 25) (- 0 24))) Civl_ok@0)))))))
(let ((anon2_LoopDone_correct  (=> (<= (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1) i@0) (and (and (and (and (and (and (=> (= (ControlFlow 0 47) 25) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 47) 46) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 47) 29) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 47) 32) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 47) 34) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 47) 37) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 47) 40) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)))))
(let ((anon2_LoopBody$3_correct  (=> (= i@1 (+ i@0 1)) (and (=> (= (ControlFlow 0 2) (- 0 9)) (forall ((s@@6 T@Shadowable) ) (!  (=> (not (= s@@6 v1)) (= (select shadow.VC@3 s@@6) (select shadow.VC@0 s@@6)))
 :qid |verifiedftbpl.461:35|
 :skolemid |23|
))) (=> (forall ((s@@7 T@Shadowable) ) (!  (=> (not (= s@@7 v1)) (= (select shadow.VC@3 s@@7) (select shadow.VC@0 s@@7)))
 :qid |verifiedftbpl.461:35|
 :skolemid |23|
)) (and (=> (= (ControlFlow 0 2) (- 0 8)) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@8) tid) (= (select shadow.Lock@0 s@@8) tid))
 :qid |verifiedftbpl.462:35|
 :skolemid |24|
))) (=> (forall ((s@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@9) tid) (= (select shadow.Lock@0 s@@9) tid))
 :qid |verifiedftbpl.462:35|
 :skolemid |24|
)) (and (=> (= (ControlFlow 0 2) (- 0 7)) (VCRepOk (select shadow.VC@3 v1))) (=> (VCRepOk (select shadow.VC@3 v1)) (and (=> (= (ControlFlow 0 2) (- 0 6)) (>= i@1 0)) (=> (>= i@1 0) (and (=> (= (ControlFlow 0 2) (- 0 5)) (<= i@1 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1))) (=> (<= i@1 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 2) (- 0 4)) (= (|clock#epoch| (select (select shadow.VC@3 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 i@1) i@1 inline$AtomicVCGetSize$0$i@1))) (=> (= (|clock#epoch| (select (select shadow.VC@3 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 i@1) i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 2) (- 0 3)) (forall ((j@@5 Int) ) (!  (=> (and (<= 0 j@@5) (<= i@1 j@@5)) (= (select (select shadow.VC@3 v1) j@@5) (select (select shadow.VC@0 v1) j@@5)))
 :qid |verifiedftbpl.467:35|
 :skolemid |25|
))) (=> (forall ((j@@6 Int) ) (!  (=> (and (<= 0 j@@6) (<= i@1 j@@6)) (= (select (select shadow.VC@3 v1) j@@6) (select (select shadow.VC@0 v1) j@@6)))
 :qid |verifiedftbpl.467:35|
 :skolemid |25|
)) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((j@@7 Int) ) (!  (=> (and (<= 0 j@@7) (< j@@7 i@1)) (= (select (select shadow.VC@3 v1) j@@7) (epoch (|tid#epoch| (select (select shadow.VC@0 v1) j@@7)) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) j@@7)) (|clock#epoch| (select (select shadow.VC@3 v2) j@@7))) (|clock#epoch| (select (select shadow.VC@3 v2) j@@7)) (|clock#epoch| (select (select shadow.VC@0 v1) j@@7))))))
 :qid |verifiedftbpl.468:35|
 :skolemid |26|
))))))))))))))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 v1 (store (select shadow.VC@1 v1) i@0 inline$AtomicVCSetElem$0$e@1))) (=> (and (= shadow.VC@3 (store shadow.VC@2 v1 (store (select shadow.VC@2 v1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 v1) (- 0 1))) (+ i@0 1)) (+ i@0 1) (|clock#epoch| (select (select shadow.VC@2 v1) (- 0 1)))))))) (= (ControlFlow 0 10) 2)) anon2_LoopBody$3_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (= inline$AtomicVCSetElem$0$e@1 (epoch (|tid#epoch| inline$AtomicVCGetElem$0$e@2) (ite (< (|clock#epoch| inline$AtomicVCGetElem$0$e@2) (|clock#epoch| inline$AtomicVCGetElem$1$e@2)) (|clock#epoch| inline$AtomicVCGetElem$1$e@2) (|clock#epoch| inline$AtomicVCGetElem$0$e@2)))) (= (ControlFlow 0 11) 10)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((anon2_LoopBody$2_correct  (and (=> (= (ControlFlow 0 12) (- 0 15)) (= (select shadow.Lock@0 v1) tid)) (=> (= (select shadow.Lock@0 v1) tid) (and (=> (= (ControlFlow 0 12) (- 0 14)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 12) (- 0 13)) (=> (is-ShadowableVar v1) (not (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED)))) (=> (=> (is-ShadowableVar v1) (not (= (select sx.R@0 (|x#ShadowableVar| v1)) SHARED))) (=> (= (ControlFlow 0 12) 11) inline$AtomicVCSetElem$0$Entry_correct)))))))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (and (= inline$AtomicVCGetElem$1$e@2 (select (select shadow.VC@1 v2) i@0)) (= (ControlFlow 0 16) 12)) anon2_LoopBody$2_correct)))
(let ((anon2_LoopBody$1_correct  (and (=> (= (ControlFlow 0 17) (- 0 19)) (= (select shadow.Lock@0 v2) tid)) (=> (= (select shadow.Lock@0 v2) tid) (and (=> (= (ControlFlow 0 17) (- 0 18)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 17) 16) inline$AtomicVCGetElem$1$anon0_correct)))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@2 (select (select shadow.VC@1 v1) i@0)) (= (ControlFlow 0 20) 17)) anon2_LoopBody$1_correct)))
(let ((anon2_LoopBody_correct  (=> (< i@0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 21) (- 0 23)) (= (select shadow.Lock@0 v1) tid)) (=> (= (select shadow.Lock@0 v1) tid) (and (=> (= (ControlFlow 0 21) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 21) 20) inline$AtomicVCGetElem$0$anon0_correct))))))))
(let ((anon2_LoopHead_correct  (=> (and (and (and (forall ((s@@10 T@Shadowable) ) (!  (=> (not (= s@@10 v1)) (= (select shadow.VC@1 s@@10) (select shadow.VC@0 s@@10)))
 :qid |verifiedftbpl.461:35|
 :skolemid |23|
)) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@11) tid) (= (select shadow.Lock@0 s@@11) tid))
 :qid |verifiedftbpl.462:35|
 :skolemid |24|
))) (and (VCRepOk (select shadow.VC@1 v1)) (>= i@0 0))) (and (and (<= i@0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (= (|clock#epoch| (select (select shadow.VC@1 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 i@0) i@0 inline$AtomicVCGetSize$0$i@1))) (and (forall ((j@@8 Int) ) (!  (=> (and (<= 0 j@@8) (<= i@0 j@@8)) (= (select (select shadow.VC@1 v1) j@@8) (select (select shadow.VC@0 v1) j@@8)))
 :qid |verifiedftbpl.467:35|
 :skolemid |25|
)) (forall ((j@@9 Int) ) (!  (=> (and (<= 0 j@@9) (< j@@9 i@0)) (= (select (select shadow.VC@1 v1) j@@9) (epoch (|tid#epoch| (select (select shadow.VC@0 v1) j@@9)) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) j@@9)) (|clock#epoch| (select (select shadow.VC@1 v2) j@@9))) (|clock#epoch| (select (select shadow.VC@1 v2) j@@9)) (|clock#epoch| (select (select shadow.VC@0 v1) j@@9))))))
 :qid |verifiedftbpl.468:35|
 :skolemid |26|
))))) (and (=> (= (ControlFlow 0 48) 47) anon2_LoopDone_correct) (=> (= (ControlFlow 0 48) 21) anon2_LoopBody_correct)))))
(let ((anon0$3_correct  (and (=> (= (ControlFlow 0 49) (- 0 57)) (forall ((s@@12 T@Shadowable) ) (!  (=> (not (= s@@12 v1)) (= (select shadow.VC@0 s@@12) (select shadow.VC@0 s@@12)))
 :qid |verifiedftbpl.461:35|
 :skolemid |23|
))) (=> (forall ((s@@13 T@Shadowable) ) (!  (=> (not (= s@@13 v1)) (= (select shadow.VC@0 s@@13) (select shadow.VC@0 s@@13)))
 :qid |verifiedftbpl.461:35|
 :skolemid |23|
)) (and (=> (= (ControlFlow 0 49) (- 0 56)) (forall ((s@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@14) tid) (= (select shadow.Lock@0 s@@14) tid))
 :qid |verifiedftbpl.462:35|
 :skolemid |24|
))) (=> (forall ((s@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@15) tid) (= (select shadow.Lock@0 s@@15) tid))
 :qid |verifiedftbpl.462:35|
 :skolemid |24|
)) (and (=> (= (ControlFlow 0 49) (- 0 55)) (VCRepOk (select shadow.VC@0 v1))) (=> (VCRepOk (select shadow.VC@0 v1)) (and (=> (= (ControlFlow 0 49) (- 0 54)) (>= 0 0)) (=> (>= 0 0) (and (=> (= (ControlFlow 0 49) (- 0 53)) (<= 0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1))) (=> (<= 0 (ite (< inline$AtomicVCGetSize$0$i@1 inline$AtomicVCGetSize$1$i@1) inline$AtomicVCGetSize$1$i@1 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 49) (- 0 52)) (= (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 0) 0 inline$AtomicVCGetSize$0$i@1))) (=> (= (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (ite (< inline$AtomicVCGetSize$0$i@1 0) 0 inline$AtomicVCGetSize$0$i@1)) (and (=> (= (ControlFlow 0 49) (- 0 51)) (forall ((j@@10 Int) ) (!  (=> (and (<= 0 j@@10) (<= 0 j@@10)) (= (select (select shadow.VC@0 v1) j@@10) (select (select shadow.VC@0 v1) j@@10)))
 :qid |verifiedftbpl.467:35|
 :skolemid |25|
))) (=> (forall ((j@@11 Int) ) (!  (=> (and (<= 0 j@@11) (<= 0 j@@11)) (= (select (select shadow.VC@0 v1) j@@11) (select (select shadow.VC@0 v1) j@@11)))
 :qid |verifiedftbpl.467:35|
 :skolemid |25|
)) (and (=> (= (ControlFlow 0 49) (- 0 50)) (forall ((j@@12 Int) ) (!  (=> (and (<= 0 j@@12) (< j@@12 0)) (= (select (select shadow.VC@0 v1) j@@12) (epoch (|tid#epoch| (select (select shadow.VC@0 v1) j@@12)) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) j@@12)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@12))) (|clock#epoch| (select (select shadow.VC@0 v2) j@@12)) (|clock#epoch| (select (select shadow.VC@0 v1) j@@12))))))
 :qid |verifiedftbpl.468:35|
 :skolemid |26|
))) (=> (forall ((j@@13 Int) ) (!  (=> (and (<= 0 j@@13) (< j@@13 0)) (= (select (select shadow.VC@0 v1) j@@13) (epoch (|tid#epoch| (select (select shadow.VC@0 v1) j@@13)) (ite (< (|clock#epoch| (select (select shadow.VC@0 v1) j@@13)) (|clock#epoch| (select (select shadow.VC@0 v2) j@@13))) (|clock#epoch| (select (select shadow.VC@0 v2) j@@13)) (|clock#epoch| (select (select shadow.VC@0 v1) j@@13))))))
 :qid |verifiedftbpl.468:35|
 :skolemid |26|
)) (=> (= (ControlFlow 0 49) 48) anon2_LoopHead_correct)))))))))))))))))))
(let ((inline$AtomicVCGetSize$1$anon0_correct  (=> (and (= inline$AtomicVCGetSize$1$i@1 (|clock#epoch| (select (select shadow.VC@0 v2) (- 0 1)))) (= (ControlFlow 0 58) 49)) anon0$3_correct)))
(let ((anon0$2_correct  (and (=> (= (ControlFlow 0 59) (- 0 61)) (= (select shadow.Lock@0 v2) tid)) (=> (= (select shadow.Lock@0 v2) tid) (and (=> (= (ControlFlow 0 59) (- 0 60)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 59) 58) inline$AtomicVCGetSize$1$anon0_correct)))))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1)))) (= (ControlFlow 0 62) 59)) anon0$2_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 63) (- 0 65)) (= (select shadow.Lock@0 v1) tid)) (=> (= (select shadow.Lock@0 v1) tid) (and (=> (= (ControlFlow 0 63) (- 0 64)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 63) 62) inline$AtomicVCGetSize$0$anon0_correct)))))))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@16 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@16) tid) (= (select shadow.VC@0 s@@16) (select shadow.VC@@0 s@@16)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (forall ((s@@17 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@17))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 v2)) (not (is-ShadowableVar v2))) (not (is-ShadowableVar v1))) (= (select shadow.Lock@0 v2) tid)) (= (select shadow.Lock@0 v1) tid)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (not (= v1 v2))) (and (not (= tid nil)) (>= tid 0))) (and (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= (ControlFlow 0 66) 63))) anon0$1_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@9) tid) (= (select shadow.Lock v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R x@@9) SHARED) (= (select sx.R x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@18 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@18) tid) (= (select shadow.VC@@0 s@@18) (select shadow.VC@@0 s@@18)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@10)) tid) (= (select sx.R x@@10) (select sx.R x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@11)) tid) (= (select sx.W x@@11) (select sx.W x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@19 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@19))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 67) 66))) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun v@@1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun i@@1 () Int)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$0$e@0 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_VC.Inc_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 33) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 19) (- 0 21)) (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@0 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@3) tid) (= (select shadow.Lock@0 v@@3) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s v@@1)) (not (= s v@@1))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@2 s)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 v@@1)) (not (= s@@0 v@@1))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@2 s@@0)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= (ControlFlow 0 17) (- 0 16))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@0) SHARED) (= (select sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (and (and (and (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@0 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@2 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@0 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 6) (- 0 8)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 6) (- 0 7)) (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@8) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@0 v@@8) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 6) (- 0 5)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@2 (store (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1 (store (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1 (epoch (|tid#epoch| (select (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1)) (+ (|clock#epoch| (select (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1)) 1))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (= shadow.VC@2 (store (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1 (store (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1 (epoch (|tid#epoch| (select (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1)) (+ (|clock#epoch| (select (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1)) 1))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (= shadow.VC@2 (store (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1 (store (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1 (epoch (|tid#epoch| (select (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1)) (+ (|clock#epoch| (select (select (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 v@@1) (- 0 1))))))) v@@1) i@@1)) 1))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (and (= shadow.VC@1 (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) i@@1 inline$AtomicVCSetElem$0$e@0))) (= shadow.VC@2 (store shadow.VC@1 v@@1 (store (select shadow.VC@1 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@1 v@@1) (- 0 1))))))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 9) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 11) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (and (= inline$AtomicVCSetElem$0$e@0 (epoch (|tid#epoch| inline$AtomicVCGetElem$0$e@1) (+ (|clock#epoch| inline$AtomicVCGetElem$0$e@1) 1))) (= (ControlFlow 0 24) 23)) inline$AtomicVCSetElem$0$anon0_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 v@@1) tid)) (=> (= (select shadow.Lock@0 v@@1) tid) (and (=> (= (ControlFlow 0 25) (- 0 27)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 25) (- 0 26)) (=> (is-ShadowableVar v@@1) (not (= (select sx.R@0 (|x#ShadowableVar| v@@1)) SHARED)))) (=> (=> (is-ShadowableVar v@@1) (not (= (select sx.R@0 (|x#ShadowableVar| v@@1)) SHARED))) (=> (= (ControlFlow 0 25) 24) inline$AtomicVCSetElem$0$Entry_correct)))))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@0 v@@1) i@@1)) (= (ControlFlow 0 29) 25)) anon0$1_correct)))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@9) tid) (= (select shadow.Lock@0 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@6) tid) (= (select shadow.VC@0 s@@6) (select shadow.VC@@0 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (and (and (and (and (and (VCRepOk (select shadow.VC@0 v@@1)) (>= i@@1 0)) (not (is-ShadowableVar v@@1))) (= (select shadow.Lock@0 v@@1) tid)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (and (not (= tid nil)) (>= tid 0))) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 30) (- 0 32)) (= (select shadow.Lock@0 v@@1) tid)) (=> (= (select shadow.Lock@0 v@@1) tid) (and (=> (= (ControlFlow 0 30) (- 0 31)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 30) 29) inline$AtomicVCGetElem$0$anon0_correct))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@10) tid) (= (select shadow.Lock v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R x@@9) SHARED) (= (select sx.R x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@8) tid) (= (select shadow.VC@@0 s@@8) (select shadow.VC@@0 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@10)) tid) (= (select sx.R x@@10) (select sx.R x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@11)) tid) (= (select sx.W x@@11) (select sx.W x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 33) 30))) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun uid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v@0 () T@Shadowable)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Fork_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 34) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 23)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 20) (- 0 22)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@4 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@4 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 20) (- 0 21)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s (ShadowableTid tid))) (not (= s (ShadowableTid uid)))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@4 s)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 (ShadowableTid tid))) (not (= s@@0 (ShadowableTid uid)))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@4 s@@0)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 20) (- 0 19)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@4 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@4 sx.R@4)))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@4 sx.R@2) (=> (and (and (= sx.W@4 sx.W@2) (= shadow.Lock@4 shadow.Lock@2)) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 24) 20))) GeneratedUnifiedExit_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (= (ControlFlow 0 14) (- 0 13))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@3 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@3 sx.R@3)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@3 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@0) SHARED) (= (select Civl_global_old_sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 8) (- 0 9)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 8) (- 0 7)) (and (and (and (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@3 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@3 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@3 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@3 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@3 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 3) (- 0 4)) (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@3 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@3 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@3 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((anon0_0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@2) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@2) (= sx.W@3 sx.W@2)) (and (= sx.R@3 sx.R@2) (= Civl_global_old_shadow.VC@0 shadow.VC@2))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@2) (= Civl_global_old_sx.W@0 sx.W@2)) (and (= Civl_global_old_sx.R@0 sx.R@2) (= Civl_linear_tid_available@3 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 18) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 18) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_0_correct  (=> (= call1formal@Civl_0_v@0 (ShadowableTid tid)) (and (=> (= (ControlFlow 0 25) (- 0 28)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 25) (- 0 27)) (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@8) tid) (= (select shadow.Lock@1 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R@1 x@@6) SHARED) (= (select sx.R@1 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@6) tid) (= (select shadow.VC@1 s@@6) (select shadow.VC@1 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@7)) tid) (= (select sx.R@1 x@@7) (select sx.R@1 x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@8)) tid) (= (select sx.W@1 x@@8) (select sx.W@1 x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@9) tid) (= (select shadow.Lock@1 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R@1 x@@9) SHARED) (= (select sx.R@1 x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@7) tid) (= (select shadow.VC@1 s@@7) (select shadow.VC@1 s@@7)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@10)) tid) (= (select sx.R@1 x@@10) (select sx.R@1 x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@11)) tid) (= (select sx.W@1 x@@11) (select sx.W@1 x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 25) (- 0 26)) (and (forall ((s@@8 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@8))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@10) tid) (= (select shadow.Lock@2 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@10 T@Shadowable) ) (!  (=> (and (and (not (= s@@10 call1formal@Civl_0_v@0)) (not (= s@@10 call1formal@Civl_0_v@0))) (= (select shadow.Lock@1 s@@10) tid)) (= (select shadow.VC@1 s@@10) (select shadow.VC@2 s@@10)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@11 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@11))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@2 sx.R@2)) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 25) 17) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 25) 24) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 25) 18) anon0_0_@2_Civl_NoninterferenceChecker_correct))))))))))))
(let ((anon0_1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@1) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@1) (= sx.W@3 sx.W@1)) (and (= sx.R@3 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@3 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@0) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@3 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@3 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_1_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableTid uid)) (= call2formal@Civl_0_v2@0 (ShadowableTid tid))) (and (=> (= (ControlFlow 0 29) (- 0 32)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 29) (- 0 31)) (and (and (and (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@11) tid) (= (select shadow.Lock@0 v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@12 T@Var) ) (!  (=> (= (select sx.R@0 x@@12) SHARED) (= (select sx.R@0 x@@12) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@12) tid) (= (select shadow.VC@0 s@@12) (select shadow.VC@0 s@@12)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@13 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@13)) tid) (= (select sx.R@0 x@@13) (select sx.R@0 x@@13)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@14)) tid) (= (select sx.W@0 x@@14) (select sx.W@0 x@@14)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@12) tid) (= (select shadow.Lock@0 v@@12) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@15 T@Var) ) (!  (=> (= (select sx.R@0 x@@15) SHARED) (= (select sx.R@0 x@@15) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@13) tid) (= (select shadow.VC@0 s@@13) (select shadow.VC@0 s@@13)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@16 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@16)) tid) (= (select sx.R@0 x@@16) (select sx.R@0 x@@16)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@17)) tid) (= (select sx.W@0 x@@17) (select sx.W@0 x@@17)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 29) (- 0 30)) (and (forall ((s@@14 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@14))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@15 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@15))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@13) tid) (= (select shadow.Lock@1 v@@13) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@16 T@Shadowable) ) (!  (=> (and (and (not (= s@@16 call1formal@Civl_0_v1@0)) (not (= s@@16 call1formal@Civl_0_v1@0))) (= (select shadow.Lock@0 s@@16) tid)) (= (select shadow.VC@0 s@@16) (select shadow.VC@1 s@@16)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@17 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@17))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 29) 25) anon0_0_correct) (=> (= (ControlFlow 0 29) 16) anon0_1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 29) 1) Civl_RefinementChecker_correct))))))))))))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@14) tid) (= (select shadow.Lock@0 v@@14) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@18 T@Var) ) (!  (=> (= (select sx.R x@@18) SHARED) (= (select sx.R@0 x@@18) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@18 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@18) tid) (= (select shadow.VC@0 s@@18) (select shadow.VC@@0 s@@18)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@19 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@19)) tid) (= (select sx.R@0 x@@19) (select sx.R x@@19)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@20 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@20)) tid) (= (select sx.W@0 x@@20) (select sx.W x@@20)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@19 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@19))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 33) 29) anon0_1_correct) (=> (= (ControlFlow 0 33) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 33) 1) Civl_RefinementChecker_correct))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@15) tid) (= (select shadow.Lock v@@15) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@21 T@Var) ) (!  (=> (= (select sx.R x@@21) SHARED) (= (select sx.R x@@21) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@20 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@20) tid) (= (select shadow.VC@@0 s@@20) (select shadow.VC@@0 s@@20)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@22 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@22)) tid) (= (select sx.R x@@22) (select sx.R x@@22)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@23 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@23)) tid) (= (select sx.W x@@23) (select sx.W x@@23)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@21 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@21))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 34) 33))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Join_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 29) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 19) (- 0 21)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@3 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@3 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s (ShadowableTid tid))) (not (= s (ShadowableTid tid)))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@3 s)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 (ShadowableTid tid))) (not (= s@@0 (ShadowableTid tid)))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@3 s@@0)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@3 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@3 sx.R@3)))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@3 sx.R@1) (=> (and (and (= sx.W@3 sx.W@1) (= shadow.Lock@3 shadow.Lock@1)) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 23) 19))) GeneratedUnifiedExit_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (= (ControlFlow 0 14) (- 0 13))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@2 sx.R@2)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@0) SHARED) (= (select Civl_global_old_sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 8) (- 0 9)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 8) (- 0 7)) (and (and (and (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@2 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@2 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@2 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@2 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@2 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 3) (- 0 4)) (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@2 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@2 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((anon0_0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@2 shadow.VC@1) (=> (and (and (and (= shadow.Lock@2 shadow.Lock@1) (= sx.W@2 sx.W@1)) (and (= sx.R@2 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 17) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 17) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_0_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableTid tid)) (= call2formal@Civl_0_v2@0 (ShadowableTid uid))) (and (=> (= (ControlFlow 0 24) (- 0 27)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 24) (- 0 26)) (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R@0 x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@6) tid) (= (select shadow.VC@0 s@@6) (select shadow.VC@0 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R@0 x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W@0 x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@9) tid) (= (select shadow.Lock@0 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R@0 x@@9) SHARED) (= (select sx.R@0 x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@7) tid) (= (select shadow.VC@0 s@@7) (select shadow.VC@0 s@@7)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@10)) tid) (= (select sx.R@0 x@@10) (select sx.R@0 x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@11)) tid) (= (select sx.W@0 x@@11) (select sx.W@0 x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 24) (- 0 25)) (and (forall ((s@@8 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@8))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@10) tid) (= (select shadow.Lock@1 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@10 T@Shadowable) ) (!  (=> (and (and (not (= s@@10 call1formal@Civl_0_v1@0)) (not (= s@@10 call1formal@Civl_0_v1@0))) (= (select shadow.Lock@0 s@@10) tid)) (= (select shadow.VC@0 s@@10) (select shadow.VC@1 s@@10)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@11 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@11))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 24) 16) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 24) 23) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 24) 17) anon0_0_@2_Civl_NoninterferenceChecker_correct))))))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@2 shadow.VC@0) (=> (and (and (and (= shadow.Lock@2 shadow.Lock@0) (= sx.W@2 sx.W@0)) (and (= sx.R@2 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@11) tid) (= (select shadow.Lock@0 v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@12 T@Var) ) (!  (=> (= (select sx.R x@@12) SHARED) (= (select sx.R@0 x@@12) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@12) tid) (= (select shadow.VC@0 s@@12) (select shadow.VC@@0 s@@12)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@13 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@13)) tid) (= (select sx.R@0 x@@13) (select sx.R x@@13)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@14)) tid) (= (select sx.W@0 x@@14) (select sx.W x@@14)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@13 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@13))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 28) 24) anon0_0_correct) (=> (= (ControlFlow 0 28) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 28) 1) Civl_RefinementChecker_correct))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@12) tid) (= (select shadow.Lock v@@12) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@15 T@Var) ) (!  (=> (= (select sx.R x@@15) SHARED) (= (select sx.R x@@15) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@14) tid) (= (select shadow.VC@@0 s@@14) (select shadow.VC@@0 s@@14)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@16 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@16)) tid) (= (select sx.R x@@16) (select sx.R x@@16)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@17)) tid) (= (select sx.W x@@17) (select sx.W x@@17)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@15 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@15))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 29) 28))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun l () T@Lock)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Acquire_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 29) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 19) (- 0 21)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@3 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@3 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s (ShadowableTid tid))) (not (= s (ShadowableTid tid)))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@3 s)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 (ShadowableTid tid))) (not (= s@@0 (ShadowableTid tid)))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@3 s@@0)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@3 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@3 sx.R@3)))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@3 sx.R@1) (=> (and (and (= sx.W@3 sx.W@1) (= shadow.Lock@3 shadow.Lock@1)) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 23) 19))) GeneratedUnifiedExit_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (= (ControlFlow 0 14) (- 0 13))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@2 sx.R@2)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@0) SHARED) (= (select Civl_global_old_sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 8) (- 0 9)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 8) (- 0 7)) (and (and (and (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@2 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@2 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@2 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@2 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@2 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 3) (- 0 4)) (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@2 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@2 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((anon0_0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@2 shadow.VC@1) (=> (and (and (and (= shadow.Lock@2 shadow.Lock@1) (= sx.W@2 sx.W@1)) (and (= sx.R@2 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 17) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 17) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_0_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableTid tid)) (= call2formal@Civl_0_v2@0 (ShadowableLock l))) (and (=> (= (ControlFlow 0 24) (- 0 27)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 24) (- 0 26)) (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R@0 x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@6) tid) (= (select shadow.VC@0 s@@6) (select shadow.VC@0 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R@0 x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W@0 x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@9) tid) (= (select shadow.Lock@0 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R@0 x@@9) SHARED) (= (select sx.R@0 x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@7) tid) (= (select shadow.VC@0 s@@7) (select shadow.VC@0 s@@7)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@10)) tid) (= (select sx.R@0 x@@10) (select sx.R@0 x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@11)) tid) (= (select sx.W@0 x@@11) (select sx.W@0 x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 24) (- 0 25)) (and (forall ((s@@8 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@8))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@10) tid) (= (select shadow.Lock@1 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@10 T@Shadowable) ) (!  (=> (and (and (not (= s@@10 call1formal@Civl_0_v1@0)) (not (= s@@10 call1formal@Civl_0_v1@0))) (= (select shadow.Lock@0 s@@10) tid)) (= (select shadow.VC@0 s@@10) (select shadow.VC@1 s@@10)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@11 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@11))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 24) 16) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 24) 23) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 24) 17) anon0_0_@2_Civl_NoninterferenceChecker_correct))))))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@2 shadow.VC@0) (=> (and (and (and (= shadow.Lock@2 shadow.Lock@0) (= sx.W@2 sx.W@0)) (and (= sx.R@2 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@11) tid) (= (select shadow.Lock@0 v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@12 T@Var) ) (!  (=> (= (select sx.R x@@12) SHARED) (= (select sx.R@0 x@@12) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@12) tid) (= (select shadow.VC@0 s@@12) (select shadow.VC@@0 s@@12)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@13 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@13)) tid) (= (select sx.R@0 x@@13) (select sx.R x@@13)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@14)) tid) (= (select sx.W@0 x@@14) (select sx.W x@@14)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@13 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@13))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 28) 24) anon0_0_correct) (=> (= (ControlFlow 0 28) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 28) 1) Civl_RefinementChecker_correct))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@12) tid) (= (select shadow.Lock v@@12) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@15 T@Var) ) (!  (=> (= (select sx.R x@@15) SHARED) (= (select sx.R x@@15) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@14) tid) (= (select shadow.VC@@0 s@@14) (select shadow.VC@@0 s@@14)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@16 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@16)) tid) (= (select sx.R x@@16) (select sx.R x@@16)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@17)) tid) (= (select sx.W x@@17) (select sx.W x@@17)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@15 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@15))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 29) 28))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun l () T@Lock)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v@0 () T@Shadowable)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Release_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 34) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 23)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 20) (- 0 22)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@4 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@4 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 20) (- 0 21)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s (ShadowableTid tid))) (not (= s (ShadowableLock l)))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@4 s)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 (ShadowableTid tid))) (not (= s@@0 (ShadowableLock l)))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@4 s@@0)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)) (=> (= (ControlFlow 0 20) (- 0 19)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@4 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@4 sx.R@4)))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@4 sx.R@2) (=> (and (and (= sx.W@4 sx.W@2) (= shadow.Lock@4 shadow.Lock@2)) (and (= shadow.VC@4 shadow.VC@2) (= (ControlFlow 0 24) 20))) GeneratedUnifiedExit_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (= (ControlFlow 0 14) (- 0 13))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@3 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@3 sx.R@3)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@3 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@0) SHARED) (= (select Civl_global_old_sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 8) (- 0 9)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 8) (- 0 7)) (and (and (and (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@3 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@3 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@3 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@3 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@3 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@3 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 3) (- 0 4)) (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@3 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@3 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@3 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((anon0_0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@2) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@2) (= sx.W@3 sx.W@2)) (and (= sx.R@3 sx.R@2) (= Civl_global_old_shadow.VC@0 shadow.VC@2))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@2) (= Civl_global_old_sx.W@0 sx.W@2)) (and (= Civl_global_old_sx.R@0 sx.R@2) (= Civl_linear_tid_available@3 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 18) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 18) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_0_correct  (=> (= call1formal@Civl_0_v@0 (ShadowableTid tid)) (and (=> (= (ControlFlow 0 25) (- 0 28)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 25) (- 0 27)) (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@8) tid) (= (select shadow.Lock@1 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R@1 x@@6) SHARED) (= (select sx.R@1 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@6) tid) (= (select shadow.VC@1 s@@6) (select shadow.VC@1 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@7)) tid) (= (select sx.R@1 x@@7) (select sx.R@1 x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@8)) tid) (= (select sx.W@1 x@@8) (select sx.W@1 x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@9) tid) (= (select shadow.Lock@1 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R@1 x@@9) SHARED) (= (select sx.R@1 x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@7) tid) (= (select shadow.VC@1 s@@7) (select shadow.VC@1 s@@7)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@10)) tid) (= (select sx.R@1 x@@10) (select sx.R@1 x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@11)) tid) (= (select sx.W@1 x@@11) (select sx.W@1 x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 25) (- 0 26)) (and (forall ((s@@8 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@8))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@10) tid) (= (select shadow.Lock@2 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@10 T@Shadowable) ) (!  (=> (and (and (not (= s@@10 call1formal@Civl_0_v@0)) (not (= s@@10 call1formal@Civl_0_v@0))) (= (select shadow.Lock@1 s@@10) tid)) (= (select shadow.VC@1 s@@10) (select shadow.VC@2 s@@10)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@11 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@11))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@2 sx.R@2)) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 25) 17) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 25) 24) Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 25) 18) anon0_0_@2_Civl_NoninterferenceChecker_correct))))))))))))
(let ((anon0_1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@1) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@1) (= sx.W@3 sx.W@1)) (and (= sx.R@3 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@3 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@3 shadow.VC@0) (=> (and (and (and (= shadow.Lock@3 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@3 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@3 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_1_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableLock l)) (= call2formal@Civl_0_v2@0 (ShadowableTid tid))) (and (=> (= (ControlFlow 0 29) (- 0 32)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 29) (- 0 31)) (and (and (and (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@11) tid) (= (select shadow.Lock@0 v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@12 T@Var) ) (!  (=> (= (select sx.R@0 x@@12) SHARED) (= (select sx.R@0 x@@12) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@12) tid) (= (select shadow.VC@0 s@@12) (select shadow.VC@0 s@@12)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@13 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@13)) tid) (= (select sx.R@0 x@@13) (select sx.R@0 x@@13)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@14)) tid) (= (select sx.W@0 x@@14) (select sx.W@0 x@@14)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@12) tid) (= (select shadow.Lock@0 v@@12) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@15 T@Var) ) (!  (=> (= (select sx.R@0 x@@15) SHARED) (= (select sx.R@0 x@@15) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 s@@13) tid) (= (select shadow.VC@0 s@@13) (select shadow.VC@0 s@@13)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@16 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@16)) tid) (= (select sx.R@0 x@@16) (select sx.R@0 x@@16)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select shadow.Lock@0 (ShadowableVar x@@17)) tid) (= (select sx.W@0 x@@17) (select sx.W@0 x@@17)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 29) (- 0 30)) (and (forall ((s@@14 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@14))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@15 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@15))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock@0 v@@13) tid) (= (select shadow.Lock@1 v@@13) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@16 T@Shadowable) ) (!  (=> (and (and (not (= s@@16 call1formal@Civl_0_v1@0)) (not (= s@@16 call1formal@Civl_0_v1@0))) (= (select shadow.Lock@0 s@@16) tid)) (= (select shadow.VC@0 s@@16) (select shadow.VC@1 s@@16)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@17 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@17))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 29) 25) anon0_0_correct) (=> (= (ControlFlow 0 29) 16) anon0_1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 29) 1) Civl_RefinementChecker_correct))))))))))))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@14) tid) (= (select shadow.Lock@0 v@@14) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@18 T@Var) ) (!  (=> (= (select sx.R x@@18) SHARED) (= (select sx.R@0 x@@18) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@18 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@18) tid) (= (select shadow.VC@0 s@@18) (select shadow.VC@@0 s@@18)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@19 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@19)) tid) (= (select sx.R@0 x@@19) (select sx.R x@@19)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@20 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@20)) tid) (= (select sx.W@0 x@@20) (select sx.W x@@20)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@19 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@19))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 33) 29) anon0_1_correct) (=> (= (ControlFlow 0 33) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 33) 1) Civl_RefinementChecker_correct))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@15) tid) (= (select shadow.Lock v@@15) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@21 T@Var) ) (!  (=> (= (select sx.R x@@21) SHARED) (= (select sx.R x@@21) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@20 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@20) tid) (= (select shadow.VC@@0 s@@20) (select shadow.VC@@0 s@@20)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@22 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@22)) tid) (= (select sx.R x@@22) (select sx.R x@@22)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@23 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@23)) tid) (= (select sx.W x@@23) (select sx.W x@@23)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@21 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@21))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 34) 33))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@8 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@11 () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun sx.W@6 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@7 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@4 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$AtomicVarStateGetWNoLock$0$e@1 () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun x@@0 () T@Var)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@1 () T@Epoch)
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun call10formal@Civl_0_res@0 () Bool)
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun inline$AtomicVCGetElem$1$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$i@0 () Int)
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun call1formal@Civl_0_v1@0 () T@Shadowable)
(declare-fun call2formal@Civl_0_v2@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$i@0 () Int)
(declare-fun call1formal@Civl_1_old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun call2formal@Civl_1_old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun call3formal@Civl_1_old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun call4formal@Civl_1_old.sx.R@0 () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Write_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 73) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (and (forall ((s T@Shadowable) ) (! (VCRepOk (select shadow.VC@6 s))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@8 sx.R@6))) (=> (and (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select shadow.VC@6 s@@0))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@8 sx.R@6)) (and (=> (= (ControlFlow 0 20) (- 0 21)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 20) (- 0 19)) (and (and (and (and (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@11 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@1 T@Var) ) (!  (=> (= (select sx.R x@@1) SHARED) (= (select sx.R@6 x@@1) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@1) tid) (= (select shadow.VC@6 s@@1) (select shadow.VC@@0 s@@1)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@2)) tid) (= (select sx.R@6 x@@2) (select sx.R x@@2)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@3 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@3)) tid) (= (select sx.W@8 x@@3) (select sx.W x@@3)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@6 sx.R@4) (=> (and (and (= sx.W@8 sx.W@6) (= shadow.Lock@11 shadow.Lock@9)) (and (= shadow.VC@6 shadow.VC@4) (= (ControlFlow 0 23) 20))) GeneratedUnifiedExit_correct))))
(let ((anon12_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@0) (=> (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@6 sx.W@0)) (and (= sx.R@4 sx.R@0) (= (ControlFlow 0 66) 23))) Civl_UnifiedReturn_correct))))
(let ((anon13_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (= shadow.Lock@9 shadow.Lock@8) (= sx.W@6 sx.W@1)) (and (= sx.R@4 sx.R@1) (= (ControlFlow 0 51) 23))) Civl_UnifiedReturn_correct))))
(let ((anon15_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (= shadow.Lock@9 shadow.Lock@7) (= sx.W@6 sx.W@1)) (and (= sx.R@4 sx.R@1) (= (ControlFlow 0 42) 23))) Civl_UnifiedReturn_correct))))
(let ((anon16_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@2) (=> (and (and (= shadow.Lock@9 shadow.Lock@4) (= sx.W@6 sx.W@2)) (and (= sx.R@4 sx.R@2) (= (ControlFlow 0 30) 23))) Civl_UnifiedReturn_correct))))
(let ((anon11$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@4 shadow.VC@3) (=> (and (and (= shadow.Lock@9 shadow.Lock@6) (= sx.W@6 sx.W@5)) (and (= sx.R@4 sx.R@3) (= (ControlFlow 0 24) 23))) Civl_UnifiedReturn_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@1 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@1 Civl_global_old_sx.R@1)) (= (ControlFlow 0 14) (- 0 13))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@5 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@7 sx.R@5)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@4 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@1 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@10 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@4 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4) SHARED) (= (select Civl_global_old_sx.R@1 x@@4) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.VC@1 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.R@1 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@5)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@6 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@6)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.W@1 x@@6) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@6)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 8) (- 0 9)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 8) (- 0 7)) (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@10 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@7 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@7) SHARED) (= (select sx.R@5 x@@7) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@5 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@8)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@5 x@@8) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@8)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@9 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@9)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@7 x@@9) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@9)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@4 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 3) (- 0 4)) (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@10 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@10 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@5 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((anon12_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@0) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@0) (= sx.W@7 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@4 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 67) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 67) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 67) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 67) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 67) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon12_Then_correct  (=> (= inline$AtomicVarStateGetWNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 68) 66) anon12_Then_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 68) 67) anon12_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 68) 18) Civl_ReturnChecker_correct)))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@1) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@8) (= sx.W@7 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@4 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 52) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 52) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 52) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 52) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 52) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$3$anon0_correct  (=> (= shadow.Lock@8 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 53) 51) anon13_Then$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 53) 52) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 53) 18) Civl_ReturnChecker_correct)))))
(let ((anon13_Then_correct  (=> (and (not (and (= (|tid#epoch| inline$AtomicVarStateGetW$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$0$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetW$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$0$e@1)))) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 54) 53)) inline$AtomicReleaseVarLock$3$anon0_correct))))
(let ((anon15_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@1) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@7) (= sx.W@7 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@4 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 43) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 43) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 43) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 43) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 43) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$2$anon0_correct  (=> (= shadow.Lock@7 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 44) 42) anon15_Then$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 44) 43) anon15_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 44) 18) Civl_ReturnChecker_correct)))))
(let ((anon15_Then_correct  (=> (and (not (and (= (|tid#epoch| inline$AtomicVarStateGetR$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$1$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetR$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$1$e@1)))) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 45) 44)) inline$AtomicReleaseVarLock$2$anon0_correct))))
(let ((anon16_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@2) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@4) (= sx.W@7 sx.W@2)) (and (= sx.R@5 sx.R@2) (= Civl_global_old_shadow.VC@1 shadow.VC@2))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@3) (= Civl_global_old_sx.W@1 sx.W@2)) (and (= Civl_global_old_sx.R@1 sx.R@2) (= Civl_linear_tid_available@4 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 31) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 31) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 31) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 31) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 31) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (= shadow.Lock@4 (store shadow.Lock@3 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 32) 30) anon16_Then$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 32) 31) anon16_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 32) 18) Civl_ReturnChecker_correct)))))
(let ((anon16_Then_correct  (=> (and (not call10formal@Civl_0_res@0) (= (select shadow.Lock@3 (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 33) 32)) inline$AtomicReleaseVarLock$1$anon0_correct))))
(let ((anon11$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@3) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@6) (= sx.W@7 sx.W@5)) (and (= sx.R@5 sx.R@3) (= Civl_global_old_shadow.VC@1 Civl_global_old_shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 Civl_global_old_shadow.Lock@0) (= Civl_global_old_sx.W@1 Civl_global_old_sx.W@0)) (and (= Civl_global_old_sx.R@1 Civl_global_old_sx.R@0) (= Civl_linear_tid_available@4 Civl_linear_tid_available@3)))) (and (and (and (and (=> (= (ControlFlow 0 17) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 17) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 17) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (= shadow.Lock@6 (store shadow.Lock@5 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 25) 24) anon11$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 25) 17) anon11$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 25) 18) Civl_ReturnChecker_correct)))))
(let ((anon11_correct  (=> (= (select shadow.Lock@5 (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 26) 25)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((anon15_Else$1_correct  (=> (and (= shadow.VC@3 shadow.VC@1) (= shadow.Lock@5 shadow.Lock@2)) (=> (and (and (and (= sx.W@5 sx.W@4) (= sx.R@3 sx.R@1)) (and (= Civl_global_old_shadow.VC@0 shadow.VC@1) (= Civl_global_old_shadow.Lock@0 shadow.Lock@1))) (and (and (= Civl_global_old_sx.W@0 sx.W@1) (= Civl_global_old_sx.R@0 sx.R@1)) (and (= Civl_linear_tid_available@3 Civl_linear_tid_available@1) (= (ControlFlow 0 39) 26)))) anon11_correct))))
(let ((inline$AtomicVarStateSetW$1$anon0_correct  (=> (and (= sx.W@4 (store sx.W@1 x@@0 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 40) 39)) anon15_Else$1_correct)))
(let ((anon15_Else_correct  (=> (and (and (and (= (|tid#epoch| inline$AtomicVarStateGetR$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$1$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetR$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$1$e@1))) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 41) 40))) inline$AtomicVarStateSetW$1$anon0_correct)))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@1 (select (select shadow.VC@1 inline$AtomicVCGetElem$1$r@0) inline$AtomicVCGetElem$1$i@0)) (and (=> (= (ControlFlow 0 46) 45) anon15_Then_correct) (=> (= (ControlFlow 0 46) 41) anon15_Else_correct)))))
(let ((inline$AtomicVCGetElem$1$Entry_correct  (=> (= inline$AtomicVCGetElem$1$r@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVCGetElem$1$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 47) 46)) inline$AtomicVCGetElem$1$anon0_correct))))
(let ((anon14_Then_correct  (=> (and (not (= inline$AtomicVarStateGetR$0$e@1 SHARED)) (= (select shadow.Lock@2 (ShadowableTid tid)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 48) 47)) inline$AtomicVCGetElem$1$Entry_correct))))
(let ((anon16_Else$1_correct  (=> (and (= shadow.VC@3 shadow.VC@2) (= shadow.Lock@5 shadow.Lock@3)) (=> (and (and (and (= sx.W@5 sx.W@3) (= sx.R@3 sx.R@2)) (and (= Civl_global_old_shadow.VC@0 shadow.VC@2) (= Civl_global_old_shadow.Lock@0 shadow.Lock@3))) (and (and (= Civl_global_old_sx.W@0 sx.W@2) (= Civl_global_old_sx.R@0 sx.R@2)) (and (= Civl_linear_tid_available@3 Civl_linear_tid_available@2) (= (ControlFlow 0 27) 26)))) anon11_correct))))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@3 (store sx.W@2 x@@0 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 28) 27)) anon16_Else$1_correct)))
(let ((anon16_Else_correct  (=> (and call10formal@Civl_0_res@0 (= (select shadow.Lock@3 (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 29) 28)) inline$AtomicVarStateSetW$0$anon0_correct))))
(let ((anon14_Else_0_correct  (=> (and (= call1formal@Civl_0_v1@0 (ShadowableVar x@@0)) (= call2formal@Civl_0_v2@0 (ShadowableTid tid))) (and (=> (= (ControlFlow 0 34) (- 0 37)) (and (forall ((s@@6 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@6))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (=> (= (ControlFlow 0 34) (- 0 36)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 34) (- 0 35)) (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@7) tid) (= (select shadow.Lock@2 v@@7) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@10 T@Var) ) (!  (=> (= (select sx.R@1 x@@10) SHARED) (= (select sx.R@1 x@@10) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 s@@8) tid) (= (select shadow.VC@1 s@@8) (select shadow.VC@1 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@11)) tid) (= (select sx.R@1 x@@11) (select sx.R@1 x@@11)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@12 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@12)) tid) (= (select sx.W@1 x@@12) (select sx.W@1 x@@12)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@8) tid) (= (select shadow.Lock@2 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@13 T@Var) ) (!  (=> (= (select sx.R@1 x@@13) SHARED) (= (select sx.R@1 x@@13) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 s@@9) tid) (= (select shadow.VC@1 s@@9) (select shadow.VC@1 s@@9)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@14)) tid) (= (select sx.R@1 x@@14) (select sx.R@1 x@@14)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@15 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@15)) tid) (= (select sx.W@1 x@@15) (select sx.W@1 x@@15)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@10 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@10))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@2 sx.R@2)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@9) tid) (= (select shadow.Lock@3 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@16 T@Var) ) (!  (=> (= (select sx.R@1 x@@16) SHARED) (= (select sx.R@2 x@@16) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 s@@11) tid) (= (select shadow.VC@2 s@@11) (select shadow.VC@1 s@@11)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@17)) tid) (= (select sx.R@2 x@@17) (select sx.R@1 x@@17)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@18 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@18)) tid) (= (select sx.W@2 x@@18) (select sx.W@1 x@@18)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))) (and (=> (= (ControlFlow 0 34) 33) anon16_Then_correct) (=> (= (ControlFlow 0 34) 29) anon16_Else_correct)))))))))))))
(let ((anon14_Else_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@1) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@2) (= sx.W@7 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@4 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon12_Else_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@5 shadow.VC@0) (=> (and (and (and (= shadow.Lock@10 shadow.Lock@0) (= sx.W@7 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@4 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon14_Else_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 SHARED) (and (and (=> (= (ControlFlow 0 38) 34) anon14_Else_0_correct) (=> (= (ControlFlow 0 38) 16) anon14_Else_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 38) 1) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@1 x@@0)) (and (=> (= (ControlFlow 0 49) 48) anon14_Then_correct) (=> (= (ControlFlow 0 49) 38) anon14_Else_correct)))))
(let ((anon13_Else_correct  (=> (and (and (and (= (|tid#epoch| inline$AtomicVarStateGetW$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$0$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetW$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$0$e@1))) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 50) 49))) inline$AtomicVarStateGetR$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 inline$AtomicVCGetElem$0$r@0) inline$AtomicVCGetElem$0$i@0)) (and (=> (= (ControlFlow 0 55) 54) anon13_Then_correct) (=> (= (ControlFlow 0 55) 50) anon13_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= inline$AtomicVCGetElem$0$r@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVCGetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetW$0$e@1)) (= (ControlFlow 0 56) 55)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((anon2_0$2_correct  (=> (= (select shadow.Lock@2 (ShadowableTid tid)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 57) 56)) inline$AtomicVCGetElem$0$Entry_correct))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@1 x@@0)) (= (ControlFlow 0 58) 57)) anon2_0$2_correct)))
(let ((anon2_0$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 59) 58)) inline$AtomicVarStateGetW$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableVar x@@0)) nil) (=> (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableVar x@@0) tid)) (= (ControlFlow 0 60) 59)) anon2_0$1_correct))))
(let ((anon2_0_correct  (=> (and (and (= call1formal@Civl_1_old.shadow.Lock@0 shadow.Lock) (= call2formal@Civl_1_old.shadow.VC@0 shadow.VC@@0)) (and (= call3formal@Civl_1_old.sx.W@0 sx.W) (= call4formal@Civl_1_old.sx.R@0 sx.R))) (and (=> (= (ControlFlow 0 61) (- 0 64)) (and (forall ((s@@12 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@12))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@13 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@13))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 61) (- 0 63)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 61) (- 0 62)) (and (and (and (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@10) tid) (= (select shadow.Lock@0 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@19 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@19) SHARED) (= (select sx.R@0 x@@19) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@14 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@14) tid) (= (select shadow.VC@0 s@@14) (select call2formal@Civl_1_old.shadow.VC@0 s@@14)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@20 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@20)) tid) (= (select sx.R@0 x@@20) (select call4formal@Civl_1_old.sx.R@0 x@@20)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@21 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@21)) tid) (= (select sx.W@0 x@@21) (select call3formal@Civl_1_old.sx.W@0 x@@21)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@11) tid) (= (select shadow.Lock@0 v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@22 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@22) SHARED) (= (select sx.R@0 x@@22) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@15 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@15) tid) (= (select shadow.VC@0 s@@15) (select call2formal@Civl_1_old.shadow.VC@0 s@@15)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@23 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@23)) tid) (= (select sx.R@0 x@@23) (select call4formal@Civl_1_old.sx.R@0 x@@23)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@24 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@24)) tid) (= (select sx.W@0 x@@24) (select call3formal@Civl_1_old.sx.W@0 x@@24)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@16 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@16))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (and (forall ((v@@12 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@12) tid) (= (select shadow.Lock@1 v@@12) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@25 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@25) SHARED) (= (select sx.R@1 x@@25) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@17 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@17) tid) (= (select shadow.VC@1 s@@17) (select call2formal@Civl_1_old.shadow.VC@0 s@@17)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@26 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@26)) tid) (= (select sx.R@1 x@@26) (select call4formal@Civl_1_old.sx.R@0 x@@26)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@27 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@27)) tid) (= (select sx.W@1 x@@27) (select call3formal@Civl_1_old.sx.W@0 x@@27)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 61) 60))) inline$AtomicAcquireVarLock$0$anon0_correct)))))))))))
(let ((anon12_Else_correct  (=> (not (= inline$AtomicVarStateGetWNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 65) 61) anon2_0_correct) (=> (= (ControlFlow 0 65) 15) anon12_Else_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 65) 1) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVarStateGetWNoLock$0$anon0_correct  (=> (= inline$AtomicVarStateGetWNoLock$0$e@1 (select sx.W@0 x@@0)) (and (=> (= (ControlFlow 0 69) 68) anon12_Then_correct) (=> (= (ControlFlow 0 69) 65) anon12_Else_correct)))))
(let ((anon0$1_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 70) 69)) inline$AtomicVarStateGetWNoLock$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (= (ControlFlow 0 71) 70)) anon0$1_correct)))
(let ((anon0_correct  (=> (and (and (forall ((s@@18 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@18))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (and (forall ((v@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@13) tid) (= (select shadow.Lock@0 v@@13) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@28 T@Var) ) (!  (=> (= (select sx.R x@@28) SHARED) (= (select sx.R@0 x@@28) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@19 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@19) tid) (= (select shadow.VC@0 s@@19) (select shadow.VC@@0 s@@19)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@29 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@29)) tid) (= (select sx.R@0 x@@29) (select sx.R x@@29)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@30 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@30)) tid) (= (select sx.W@0 x@@30) (select sx.W x@@30)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@0 (ShadowableTid tid)) tid))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 72) 71))) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (forall ((s@@20 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@20))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (forall ((v@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@14) tid) (= (select shadow.Lock v@@14) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@31 T@Var) ) (!  (=> (= (select sx.R x@@31) SHARED) (= (select sx.R x@@31) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@21 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@21) tid) (= (select shadow.VC@@0 s@@21) (select shadow.VC@@0 s@@21)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@32 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@32)) tid) (= (select sx.R x@@32) (select sx.R x@@32)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@33 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@33)) tid) (= (select sx.W x@@33) (select sx.W x@@33)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= (ControlFlow 0 73) 72)) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun shadow.VC@11 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@10 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$AtomicVarStateGetRNoLock$0$e@1 () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun x@@0 () T@Var)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@1 () T@Epoch)
(declare-fun shadow.VC@7 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$1$r@0 () T@Shadowable)
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCSetElem$0$i@0 () Int)
(declare-fun inline$AtomicVCInit$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$i@0 () Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCGetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$i@0 () Int)
(declare-fun call1formal@Civl_1_old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun call2formal@Civl_1_old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun call3formal@Civl_1_old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun call4formal@Civl_1_old.sx.R@0 () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Read_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 86) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 21)) (and (forall ((s T@Shadowable) ) (! (VCRepOk (select shadow.VC@11 s))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@4 sx.R@6))) (=> (and (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select shadow.VC@11 s@@0))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@4 sx.R@6)) (and (=> (= (ControlFlow 0 19) (- 0 20)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 19) (- 0 18)) (and (and (and (and (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@9 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@1 T@Var) ) (!  (=> (= (select sx.R x@@1) SHARED) (= (select sx.R@6 x@@1) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@1) tid) (= (select shadow.VC@11 s@@1) (select shadow.VC@@0 s@@1)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@2)) tid) (= (select sx.R@6 x@@2) (select sx.R x@@2)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@3 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@3)) tid) (= (select sx.W@4 x@@3) (select sx.W x@@3)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@6 sx.R@4) (=> (and (and (= sx.W@4 sx.W@2) (= shadow.Lock@9 shadow.Lock@7)) (and (= shadow.VC@11 shadow.VC@9) (= (ControlFlow 0 22) 19))) GeneratedUnifiedExit_correct))))
(let ((anon13_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (and (= shadow.Lock@7 shadow.Lock@0) (= sx.R@4 sx.R@0)) (and (= sx.W@2 sx.W@0) (= (ControlFlow 0 78) 22))) Civl_UnifiedReturn_correct))))
(let ((anon14_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (and (= shadow.Lock@7 shadow.Lock@0) (= sx.R@4 sx.R@0)) (and (= sx.W@2 sx.W@0) (= (ControlFlow 0 70) 22))) Civl_UnifiedReturn_correct))))
(let ((anon15_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (= shadow.Lock@7 shadow.Lock@6) (= sx.R@4 sx.R@1)) (and (= sx.W@2 sx.W@1) (= (ControlFlow 0 55) 22))) Civl_UnifiedReturn_correct))))
(let ((anon17_Then$2_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (= shadow.Lock@7 shadow.Lock@5) (= sx.R@4 sx.R@3)) (and (= sx.W@2 sx.W@1) (= (ControlFlow 0 43) 22))) Civl_UnifiedReturn_correct))))
(let ((anon17_Else$5_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@8) (=> (and (and (= shadow.Lock@7 shadow.Lock@4) (= sx.R@4 sx.R@2)) (and (= sx.W@2 sx.W@1) (= (ControlFlow 0 28) 22))) Civl_UnifiedReturn_correct))))
(let ((anon16_Else$2_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@9 shadow.VC@3) (=> (and (and (= shadow.Lock@7 shadow.Lock@3) (= sx.R@4 sx.R@1)) (and (= sx.W@2 sx.W@1) (= (ControlFlow 0 23) 22))) Civl_UnifiedReturn_correct))))
(let ((Civl_ReturnChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@0 Civl_global_old_sx.R@0)) (= (ControlFlow 0 14) (- 0 13))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@10 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@3 sx.R@5)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@8 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4) SHARED) (= (select Civl_global_old_sx.R@0 x@@4) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.R@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@5)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@6 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@6)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.W@0 x@@6) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@6)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 8) (- 0 9)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 8) (- 0 7)) (and (and (and (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@8 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@7 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@7) SHARED) (= (select sx.R@5 x@@7) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@10 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@8)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@5 x@@8) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@8)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@9 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@9)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@3 x@@9) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@9)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 3) (- 0 4)) (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@8 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@8 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@10 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((anon13_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 79) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 79) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 79) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 79) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 79) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon13_Then_correct  (=> (= inline$AtomicVarStateGetRNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 80) 78) anon13_Then_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 80) 79) anon13_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 80) 17) Civl_ReturnChecker_correct)))))
(let ((anon14_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 71) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 71) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 71) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 71) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 71) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon14_Then_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 72) 70) anon14_Then_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 72) 71) anon14_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 72) 17) Civl_ReturnChecker_correct)))))
(let ((anon15_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@1) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@6) (= sx.W@3 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 56) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 56) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 56) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 56) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 56) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$3$anon0_correct  (=> (= shadow.Lock@6 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 57) 55) anon15_Then$1_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 57) 56) anon15_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 57) 17) Civl_ReturnChecker_correct)))))
(let ((anon15_Then_correct  (=> (and (not (and (= (|tid#epoch| inline$AtomicVarStateGetW$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$0$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetW$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$0$e@1)))) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 58) 57)) inline$AtomicReleaseVarLock$3$anon0_correct))))
(let ((anon17_Then$2_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@1) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@5) (= sx.W@3 sx.W@1)) (and (= sx.R@5 sx.R@3) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 44) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 44) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 44) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 44) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 44) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$2$anon0_correct  (=> (= shadow.Lock@5 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 45) 43) anon17_Then$2_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 45) 44) anon17_Then$2_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 45) 17) Civl_ReturnChecker_correct)))))
(let ((anon17_Then$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 46) 45)) inline$AtomicReleaseVarLock$2$anon0_correct))))
(let ((inline$AtomicVarStateSetR$1$anon0_correct  (=> (and (= sx.R@3 (store sx.R@1 x@@0 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 47) 46)) anon17_Then$1_correct)))
(let ((anon17_Then_correct  (=> (and (= (|tid#epoch| inline$AtomicVarStateGetR$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$1$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetR$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$1$e@1))) (and (=> (= (ControlFlow 0 48) (- 0 49)) (>= (|tid#epoch| inline$AtomicThreadStateGetE$0$e@1) 0)) (=> (>= (|tid#epoch| inline$AtomicThreadStateGetE$0$e@1) 0) (=> (and (not (= (select sx.R@1 x@@0) SHARED)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 48) 47)) inline$AtomicVarStateSetR$1$anon0_correct)))))))
(let ((anon17_Else$5_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@8) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@4) (= sx.W@3 sx.W@1)) (and (= sx.R@5 sx.R@2) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 29) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 29) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 29) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 29) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 29) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (= shadow.Lock@4 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 30) 28) anon17_Else$5_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 30) 29) anon17_Else$5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 30) 17) Civl_ReturnChecker_correct)))))
(let ((anon17_Else$4_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 31) 30)) inline$AtomicReleaseVarLock$1$anon0_correct))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@2 (store sx.R@1 x@@0 SHARED)) (= (ControlFlow 0 32) 31)) anon17_Else$4_correct)))
(let ((anon17_Else$3_correct  (=> (and (not (= (select sx.R@1 x@@0) SHARED)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 33) 32)) inline$AtomicVarStateSetR$0$anon0_correct))))
(let ((inline$AtomicVCSetElem$1$anon0_correct  (=> (= shadow.VC@7 (store shadow.VC@6 inline$AtomicVCSetElem$1$r@0 (store (select shadow.VC@6 inline$AtomicVCSetElem$1$r@0) tid inline$AtomicThreadStateGetE$0$e@1))) (=> (and (= shadow.VC@8 (store shadow.VC@7 inline$AtomicVCSetElem$1$r@0 (store (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0) (- 0 1)))))))) (= (ControlFlow 0 34) 33)) anon17_Else$3_correct))))
(let ((inline$AtomicVCSetElem$1$Entry_correct  (=> (and (= inline$AtomicVCSetElem$1$r@0 (ShadowableVar x@@0)) (= (ControlFlow 0 35) 34)) inline$AtomicVCSetElem$1$anon0_correct)))
(let ((anon17_Else$2_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED))) (= (ControlFlow 0 36) 35))) inline$AtomicVCSetElem$1$Entry_correct))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@5 (store shadow.VC@4 inline$AtomicVCSetElem$0$r@0 (store (select shadow.VC@4 inline$AtomicVCSetElem$0$r@0) inline$AtomicVCSetElem$0$i@0 inline$AtomicVarStateGetR$0$e@1))) (=> (and (= shadow.VC@6 (store shadow.VC@5 inline$AtomicVCSetElem$0$r@0 (store (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0) (- 0 1))) (+ inline$AtomicVCSetElem$0$i@0 1)) (+ inline$AtomicVCSetElem$0$i@0 1) (|clock#epoch| (select (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0) (- 0 1)))))))) (= (ControlFlow 0 37) 36)) anon17_Else$2_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (= inline$AtomicVCSetElem$0$r@0 (ShadowableVar x@@0)) (=> (and (= inline$AtomicVCSetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 38) 37)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((anon17_Else$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED))) (= (ControlFlow 0 39) 38))) inline$AtomicVCSetElem$0$Entry_correct))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@4 (store shadow.VC@1 inline$AtomicVCInit$0$r@0 (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 40) 39)) anon17_Else$1_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (= inline$AtomicVCInit$0$r@0 (ShadowableVar x@@0)) (= (ControlFlow 0 41) 40)) inline$AtomicVCInit$0$anon0_correct)))
(let ((anon17_Else_correct  (=> (not (and (= (|tid#epoch| inline$AtomicVarStateGetR$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$1$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetR$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$1$e@1)))) (=> (and (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED)))) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 42) 41)) inline$AtomicVCInit$0$Entry_correct)))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@1 (select (select shadow.VC@1 inline$AtomicVCGetElem$1$r@0) inline$AtomicVCGetElem$1$i@0)) (and (=> (= (ControlFlow 0 50) 48) anon17_Then_correct) (=> (= (ControlFlow 0 50) 42) anon17_Else_correct)))))
(let ((inline$AtomicVCGetElem$1$Entry_correct  (=> (= inline$AtomicVCGetElem$1$r@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVCGetElem$1$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 51) 50)) inline$AtomicVCGetElem$1$anon0_correct))))
(let ((anon16_Then_correct  (=> (and (not (= inline$AtomicVarStateGetR$0$e@1 SHARED)) (= (select shadow.Lock@2 (ShadowableTid tid)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 52) 51)) inline$AtomicVCGetElem$1$Entry_correct))))
(let ((anon16_Else$2_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@3) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@3) (= sx.W@3 sx.W@1)) (and (= sx.R@5 sx.R@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)) (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (= shadow.Lock@3 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 24) 23) anon16_Else$2_@2_Civl_UnifiedReturn_correct) (=> (= (ControlFlow 0 24) 16) anon16_Else$2_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 24) 17) Civl_ReturnChecker_correct)))))
(let ((anon16_Else$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 25) 24)) inline$AtomicReleaseVarLock$0$anon0_correct))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar x@@0) (store (select shadow.VC@1 (ShadowableVar x@@0)) tid inline$AtomicThreadStateGetE$0$e@1))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar x@@0) (store (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1)))))))) (= (ControlFlow 0 26) 25)) anon16_Else$1_correct))))
(let ((anon16_Else_correct  (=> (and (= inline$AtomicVarStateGetR$0$e@1 SHARED) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (= (select sx.R@1 x@@0) SHARED) (= (ControlFlow 0 27) 26))) inline$AtomicVCSetElemShared$0$anon0_correct))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@1 x@@0)) (and (=> (= (ControlFlow 0 53) 52) anon16_Then_correct) (=> (= (ControlFlow 0 53) 27) anon16_Else_correct)))))
(let ((anon15_Else_correct  (=> (and (and (and (= (|tid#epoch| inline$AtomicVarStateGetW$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$0$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetW$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$0$e@1))) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 54) 53))) inline$AtomicVarStateGetR$0$anon0_correct)))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 inline$AtomicVCGetElem$0$r@0) inline$AtomicVCGetElem$0$i@0)) (and (=> (= (ControlFlow 0 59) 58) anon15_Then_correct) (=> (= (ControlFlow 0 59) 54) anon15_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= inline$AtomicVCGetElem$0$r@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVCGetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetW$0$e@1)) (= (ControlFlow 0 60) 59)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((anon5_0$2_correct  (=> (= (select shadow.Lock@2 (ShadowableTid tid)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 61) 60)) inline$AtomicVCGetElem$0$Entry_correct))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@1 x@@0)) (= (ControlFlow 0 62) 61)) anon5_0$2_correct)))
(let ((anon5_0$1_correct  (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 63) 62)) inline$AtomicVarStateGetW$0$anon0_correct))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableVar x@@0)) nil) (=> (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableVar x@@0) tid)) (= (ControlFlow 0 64) 63)) anon5_0$1_correct))))
(let ((anon5_0_correct  (=> (and (and (= call1formal@Civl_1_old.shadow.Lock@0 shadow.Lock) (= call2formal@Civl_1_old.shadow.VC@0 shadow.VC@@0)) (and (= call3formal@Civl_1_old.sx.W@0 sx.W) (= call4formal@Civl_1_old.sx.R@0 sx.R))) (and (=> (= (ControlFlow 0 65) (- 0 68)) (and (forall ((s@@6 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@6))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 65) (- 0 67)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 65) (- 0 66)) (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@7) tid) (= (select shadow.Lock@0 v@@7) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@10 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@10) SHARED) (= (select sx.R@0 x@@10) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@8) tid) (= (select shadow.VC@0 s@@8) (select call2formal@Civl_1_old.shadow.VC@0 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@11)) tid) (= (select sx.R@0 x@@11) (select call4formal@Civl_1_old.sx.R@0 x@@11)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@12 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@12)) tid) (= (select sx.W@0 x@@12) (select call3formal@Civl_1_old.sx.W@0 x@@12)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@13 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@13) SHARED) (= (select sx.R@0 x@@13) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@9 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@9) tid) (= (select shadow.VC@0 s@@9) (select call2formal@Civl_1_old.shadow.VC@0 s@@9)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@14)) tid) (= (select sx.R@0 x@@14) (select call4formal@Civl_1_old.sx.R@0 x@@14)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@15 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@15)) tid) (= (select sx.W@0 x@@15) (select call3formal@Civl_1_old.sx.W@0 x@@15)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@10 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@10))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@9) tid) (= (select shadow.Lock@1 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@16 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@16) SHARED) (= (select sx.R@1 x@@16) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@11) tid) (= (select shadow.VC@1 s@@11) (select call2formal@Civl_1_old.shadow.VC@0 s@@11)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@17)) tid) (= (select sx.R@1 x@@17) (select call4formal@Civl_1_old.sx.R@0 x@@17)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@18 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@18)) tid) (= (select sx.W@1 x@@18) (select call3formal@Civl_1_old.sx.W@0 x@@18)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 65) 64))) inline$AtomicAcquireVarLock$0$anon0_correct)))))))))))
(let ((anon5_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.W@3 sx.W@0)) (and (= sx.R@5 sx.R@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)) (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon13_Else_correct  (=> (not (= inline$AtomicVarStateGetRNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 77) 65) anon5_0_correct) (=> (= (ControlFlow 0 77) 15) anon5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 77) 1) Civl_RefinementChecker_correct)))))
(let ((anon12_Then$1_correct  (=> (not (= inline$AtomicVarStateGetRNoLock$0$e@1 SHARED)) (and (=> (= (ControlFlow 0 81) 80) anon13_Then_correct) (=> (= (ControlFlow 0 81) 77) anon13_Else_correct)))))
(let ((inline$AtomicVarStateGetRNoLock$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetRNoLock$0$e@1 (select sx.R@0 x@@0)) (= (ControlFlow 0 82) 81)) anon12_Then$1_correct)))
(let ((anon12_Then_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 83) 82)) inline$AtomicVarStateGetRNoLock$0$anon0_correct)))
(let ((anon14_Else_correct  (=> (not (= inline$AtomicVCGetElemShared$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 69) 65) anon5_0_correct) (=> (= (ControlFlow 0 69) 15) anon5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 69) 1) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@0 (ShadowableVar x@@0)) tid)) (and (=> (= (ControlFlow 0 73) 72) anon14_Then_correct) (=> (= (ControlFlow 0 73) 69) anon14_Else_correct)))))
(let ((anon12_Else$1_correct  (=> (= SHARED SHARED) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (= (select sx.R@0 x@@0) SHARED) (= (ControlFlow 0 74) 73))) inline$AtomicVCGetElemShared$0$anon0_correct))))
(let ((inline$AtomicVarStateGetRShared$0$anon0_correct  (=> (and (= (select sx.R@0 x@@0) SHARED) (= (ControlFlow 0 75) 74)) anon12_Else$1_correct)))
(let ((anon12_Else_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 76) 75)) inline$AtomicVarStateGetRShared$0$anon0_correct)))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (and (=> (= (ControlFlow 0 84) 83) anon12_Then_correct) (=> (= (ControlFlow 0 84) 76) anon12_Else_correct)))))
(let ((anon0_correct  (=> (and (and (forall ((s@@12 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@12))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@10) tid) (= (select shadow.Lock@0 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@19 T@Var) ) (!  (=> (= (select sx.R x@@19) SHARED) (= (select sx.R@0 x@@19) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@13) tid) (= (select shadow.VC@0 s@@13) (select shadow.VC@@0 s@@13)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@20 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@20)) tid) (= (select sx.R@0 x@@20) (select sx.R x@@20)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@21 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@21)) tid) (= (select sx.W@0 x@@21) (select sx.W x@@21)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@0 (ShadowableTid tid)) tid))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 85) 84))) inline$AtomicThreadStateGetE$0$anon0_correct))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (forall ((s@@14 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@14))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@11) tid) (= (select shadow.Lock v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@22 T@Var) ) (!  (=> (= (select sx.R x@@22) SHARED) (= (select sx.R x@@22) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@15) tid) (= (select shadow.VC@@0 s@@15) (select shadow.VC@@0 s@@15)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@23 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@23)) tid) (= (select sx.R x@@23) (select sx.R x@@23)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@24 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@24)) tid) (= (select sx.W x@@24) (select sx.W x@@24)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= (ControlFlow 0 86) 85)) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock@14 () (Array T@Shadowable Int))
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@8 () (Array T@Var T@Epoch))
(declare-fun sx.R@8 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@2 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@9 () (Array T@Var T@Epoch))
(declare-fun sx.R@9 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@10 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@15 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun ok@0 () Bool)
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@9 () (Array Int Bool))
(declare-fun shadow.Lock@11 () (Array T@Shadowable Int))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@6 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@1 () T@Lock)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@5 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToRelease$0$l@1 () T@Lock)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@4 () (Array Int Bool))
(declare-fun thread.State@5 () (Array Int Int))
(declare-fun thread.State@4 () (Array Int Int))
(declare-fun inline$AtomicAllocTid$0$uid@1 () Int)
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun thread.State@3 () (Array Int Int))
(declare-fun thread.ForkedBy@3 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@1 () Int)
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.VC@7 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@7 () (Array T@Var T@Epoch))
(declare-fun sx.R@7 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@13 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@8 () (Array Int Bool))
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@6 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@12 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@7 () (Array Int Bool))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Driver_10)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 86) (let ((Civl_ReturnChecker_correct true))
(let ((anon8_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 20) (- 0 21)) (= (select shadow.Lock@14 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@14 (ShadowableTid tid)) tid) (=> (= (ControlFlow 0 20) (- 0 19)) (and (forall ((s T@Shadowable) ) (! (VCRepOk (select shadow.VC@8 s))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@8 sx.R@8)))))))))
(let ((Civl_UnchangedChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct  (=> (and (and (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@2 s@@0))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@2 Civl_global_old_sx.R@2)) (= (ControlFlow 0 14) (- 0 13))) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@9 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@9 sx.R@9)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |327|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@15 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |328|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@1) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@2 v@@1) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@0) SHARED) (= (select Civl_global_old_sx.R@2 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.VC@2 s@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@2)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.R@2 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select Civl_global_old_sx.W@2 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 8) (- 0 9)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0 0)) (=> (= (ControlFlow 0 8) (- 0 7)) (and (and (and (and (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.Lock@15 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@9 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 s@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select shadow.VC@9 s@@3) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.VC@0 s@@3)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.R@9 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$tid@0) (= (select sx.W@9 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |329|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select Civl_global_old_shadow.Lock@2 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s) (select Civl_global_old_shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s)))
 :qid |unknown.0:0|
 :skolemid |14|
)))) (and (=> (= (ControlFlow 0 3) (- 0 5)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0 0)) (and (=> (= (ControlFlow 0 3) (- 0 4)) (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@15 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0) (= (select shadow.Lock@15 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 3) (- 0 2)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0) (select shadow.VC@9 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |14|
)))))))))))
(let ((anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 78) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 78) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 78) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 78) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 78) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon9_LoopDone_correct  (=> (not ok@0) (and (=> (= (ControlFlow 0 79) 77) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 79) 78) anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon12_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@10) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 72) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 72) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 72) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 72) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 72) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 59) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 59) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 59) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 59) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 59) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon14_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@5) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 41) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 41) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 41) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 41) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 41) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon14_Else$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@2) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 32) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 32) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 32) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 32) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 32) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon8_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@8) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@14) (= sx.W@9 sx.W@8)) (and (= sx.R@9 sx.R@8) (= Civl_global_old_shadow.VC@2 Civl_global_old_shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 Civl_global_old_shadow.Lock@1) (= Civl_global_old_sx.W@2 Civl_global_old_sx.W@1)) (and (= Civl_global_old_sx.R@2 Civl_global_old_sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@9)))) (and (and (and (and (=> (= (ControlFlow 0 23) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 23) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon12_Then_0_correct  (and (=> (= (ControlFlow 0 68) (- 0 71)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 68) (- 0 70)) (and (and (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@6) tid) (= (select shadow.Lock@10 v@@6) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R@1 x@@6) SHARED) (= (select sx.R@1 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 s@@4) tid) (= (select shadow.VC@1 s@@4) (select shadow.VC@1 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock@10 (ShadowableVar x@@7)) tid) (= (select sx.R@1 x@@7) (select sx.R@1 x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock@10 (ShadowableVar x@@8)) tid) (= (select sx.W@1 x@@8) (select sx.W@1 x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@7) tid) (= (select shadow.Lock@10 v@@7) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R@1 x@@9) SHARED) (= (select sx.R@1 x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 s@@5) tid) (= (select shadow.VC@1 s@@5) (select shadow.VC@1 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock@10 (ShadowableVar x@@10)) tid) (= (select sx.R@1 x@@10) (select sx.R@1 x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock@10 (ShadowableVar x@@11)) tid) (= (select sx.W@1 x@@11) (select sx.W@1 x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 68) (- 0 69)) (and (forall ((s@@6 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@6))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@8) tid) (= (select shadow.Lock@11 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@8 T@Shadowable) ) (!  (=> (and (and (not (= s@@8 (ShadowableTid tid))) (not (= s@@8 (ShadowableTid tid)))) (= (select shadow.Lock@10 s@@8) tid)) (= (select shadow.VC@1 s@@8) (select shadow.VC@5 s@@8)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@5 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@5 sx.R@5)) (and (= Civl_linear_tid_available@6 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= shadow.VC@8 shadow.VC@5)))) (and (and (and (= shadow.Lock@14 shadow.Lock@11) (= sx.W@8 sx.W@5)) (and (= sx.R@8 sx.R@5) (= Civl_global_old_shadow.VC@1 shadow.VC@5))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@11) (= Civl_global_old_sx.W@1 sx.W@5)) (and (= Civl_global_old_sx.R@1 sx.R@5) (= Civl_linear_tid_available@9 Civl_linear_tid_available@6))))) (and (and (=> (= (ControlFlow 0 68) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 68) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 68) 17) Civl_UnchangedChecker_correct)))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (and (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) nil) (= shadow.Lock@10 (store shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1) tid))) (and (and (=> (= (ControlFlow 0 73) 68) anon12_Then_0_correct) (=> (= (ControlFlow 0 73) 72) anon12_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 73) 17) Civl_UnchangedChecker_correct)))))
(let ((anon12_Then_correct  (and (=> (= (ControlFlow 0 74) (- 0 75)) (= (select shadow.Lock@1 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@1 (ShadowableTid tid)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 74) 73)) inline$AtomicChooseLockToAcquire$0$anon0_correct)))))
(let ((anon13_Then_0$1_correct  (=> (= shadow.VC@8 shadow.VC@4) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@9) (= sx.W@8 sx.W@4)) (and (= sx.R@8 sx.R@4) (= Civl_global_old_shadow.VC@1 shadow.VC@4))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@8) (= Civl_global_old_sx.W@1 sx.W@4)) (and (= Civl_global_old_sx.R@1 sx.R@4) (= Civl_linear_tid_available@9 Civl_linear_tid_available@5)))) (and (and (=> (= (ControlFlow 0 60) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 60) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 60) 17) Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@9 (store shadow.Lock@8 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1) nil)) (= (ControlFlow 0 61) 60)) anon13_Then_0$1_correct)))
(let ((anon13_Then_0_correct  (and (=> (= (ControlFlow 0 62) (- 0 65)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 62) (- 0 64)) (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@9) tid) (= (select shadow.Lock@1 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@12 T@Var) ) (!  (=> (= (select sx.R@1 x@@12) SHARED) (= (select sx.R@1 x@@12) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@10) tid) (= (select shadow.VC@1 s@@10) (select shadow.VC@1 s@@10)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@13 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@13)) tid) (= (select sx.R@1 x@@13) (select sx.R@1 x@@13)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@14)) tid) (= (select sx.W@1 x@@14) (select sx.W@1 x@@14)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@10) tid) (= (select shadow.Lock@1 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@15 T@Var) ) (!  (=> (= (select sx.R@1 x@@15) SHARED) (= (select sx.R@1 x@@15) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@11) tid) (= (select shadow.VC@1 s@@11) (select shadow.VC@1 s@@11)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@16 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@16)) tid) (= (select sx.R@1 x@@16) (select sx.R@1 x@@16)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@17)) tid) (= (select sx.W@1 x@@17) (select sx.W@1 x@@17)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 62) (- 0 63)) (and (forall ((s@@12 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@12))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@13 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@13))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@11) tid) (= (select shadow.Lock@8 v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@14 T@Shadowable) ) (!  (=> (and (and (not (= s@@14 (ShadowableTid tid))) (not (= s@@14 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)))) (= (select shadow.Lock@1 s@@14) tid)) (= (select shadow.VC@1 s@@14) (select shadow.VC@4 s@@14)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (=> (and (and (and (forall ((s@@15 T@Shadowable) ) (! (VCRepOk (select shadow.VC@4 s@@15))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@4 sx.R@4)) (and (= Civl_linear_tid_available@5 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@8 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 62) 61))) inline$AtomicReleaseChosenLock$0$anon0_correct))))))))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid) (and (and (=> (= (ControlFlow 0 66) 62) anon13_Then_0_correct) (=> (= (ControlFlow 0 66) 59) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 66) 17) Civl_UnchangedChecker_correct)))))
(let ((anon13_Then_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 67) 66)) inline$AtomicChooseLockToRelease$0$anon0_correct)))
(let ((anon14_Then_0$1_correct  (=> (= shadow.VC@8 shadow.VC@3) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@7) (= sx.W@8 sx.W@3)) (and (= sx.R@8 sx.R@3) (= Civl_global_old_shadow.VC@1 shadow.VC@3))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@6) (= Civl_global_old_sx.W@1 sx.W@3)) (and (= Civl_global_old_sx.R@1 sx.R@3) (= Civl_linear_tid_available@9 Civl_linear_tid_available@4)))) (and (and (=> (= (ControlFlow 0 42) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 42) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 42) 17) Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@5 (store thread.State@4 inline$AtomicAllocTid$0$uid@1 2)) (=> (and (= shadow.Lock@7 (store shadow.Lock@6 (ShadowableTid inline$AtomicAllocTid$0$uid@1) inline$AtomicAllocTid$0$uid@1)) (= (ControlFlow 0 43) 42)) anon14_Then_0$1_correct))))
(let ((anon14_Then_0_correct  (and (=> (= (ControlFlow 0 44) (- 0 47)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 44) (- 0 46)) (and (and (and (and (forall ((v@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 v@@12) tid) (= (select shadow.Lock@5 v@@12) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@18 T@Var) ) (!  (=> (= (select sx.R@1 x@@18) SHARED) (= (select sx.R@1 x@@18) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@16 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 s@@16) tid) (= (select shadow.VC@1 s@@16) (select shadow.VC@1 s@@16)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@19 T@Var) ) (!  (=> (= (select shadow.Lock@5 (ShadowableVar x@@19)) tid) (= (select sx.R@1 x@@19) (select sx.R@1 x@@19)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@20 T@Var) ) (!  (=> (= (select shadow.Lock@5 (ShadowableVar x@@20)) tid) (= (select sx.W@1 x@@20) (select sx.W@1 x@@20)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 v@@13) tid) (= (select shadow.Lock@5 v@@13) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@21 T@Var) ) (!  (=> (= (select sx.R@1 x@@21) SHARED) (= (select sx.R@1 x@@21) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@17 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 s@@17) tid) (= (select shadow.VC@1 s@@17) (select shadow.VC@1 s@@17)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@22 T@Var) ) (!  (=> (= (select shadow.Lock@5 (ShadowableVar x@@22)) tid) (= (select sx.R@1 x@@22) (select sx.R@1 x@@22)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@23 T@Var) ) (!  (=> (= (select shadow.Lock@5 (ShadowableVar x@@23)) tid) (= (select sx.W@1 x@@23) (select sx.W@1 x@@23)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 44) (- 0 45)) (and (forall ((s@@18 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@18))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@19 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@19))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 v@@14) tid) (= (select shadow.Lock@6 v@@14) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@20 T@Shadowable) ) (!  (=> (and (and (not (= s@@20 (ShadowableTid tid))) (not (= s@@20 (ShadowableTid inline$AtomicAllocTid$0$uid@1)))) (= (select shadow.Lock@5 s@@20) tid)) (= (select shadow.VC@1 s@@20) (select shadow.VC@3 s@@20)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@21 T@Shadowable) ) (! (VCRepOk (select shadow.VC@3 s@@21))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@3 sx.R@3)) (and (= Civl_linear_tid_available@4 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= (select thread.State@4 inline$AtomicAllocTid$0$uid@1) 1)))) (and (and (and (= (select shadow.Lock@6 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid) (not (= tid inline$AtomicAllocTid$0$uid@1))) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 44) 43)))) inline$AtomicStartThread$0$anon0_correct)))))))))
(let ((anon14_Then$1_correct  (and (=> (= (ControlFlow 0 48) (- 0 56)) (= (select shadow.Lock@5 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@5 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 48) (- 0 55)) (= (select shadow.Lock@5 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid)) (=> (= (select shadow.Lock@5 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid) (and (=> (= (ControlFlow 0 48) (- 0 54)) (forall ((s@@22 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@22))
 :qid |verifiedftbpl.976:37|
 :skolemid |38|
))) (=> (forall ((s@@23 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@23))
 :qid |verifiedftbpl.976:37|
 :skolemid |38|
)) (and (=> (= (ControlFlow 0 48) (- 0 53)) (not (= tid inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 48) (- 0 52)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 48) (- 0 51)) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (=> (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0)) (and (=> (= (ControlFlow 0 48) (- 0 50)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 48) (- 0 49)) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (=> (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0)) (and (and (=> (= (ControlFlow 0 48) 44) anon14_Then_0_correct) (=> (= (ControlFlow 0 48) 41) anon14_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 48) 17) Civl_UnchangedChecker_correct))))))))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= tid inline$AtomicAllocTid$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicAllocTid$0$uid@1) 0) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (= thread.State@3 (store thread.State@1 inline$AtomicAllocTid$0$uid@1 1))) (and (and (= thread.ForkedBy@3 (store thread.ForkedBy@1 inline$AtomicAllocTid$0$uid@1 tid)) (= shadow.Lock@5 (store shadow.Lock@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1) tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1))) (= (ControlFlow 0 57) 48)))) anon14_Then$1_correct))))
(let ((anon14_Then_correct  (=> (forall ((t Int) ) (!  (=> (= (select thread.State@1 t) 0) (= (select shadow.Lock@1 (ShadowableTid t)) nil))
 :qid |verifiedftbpl.1025:20|
 :skolemid |39|
)) (=> (and (and (= (select thread.State@1 tid) 2) (and (not (= tid nil)) (>= tid 0))) (= (ControlFlow 0 58) 57)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((anon14_Else_0$1_correct  (=> (= shadow.VC@8 shadow.VC@2) (=> (and (and (and (= shadow.Lock@14 shadow.Lock@4) (= sx.W@8 sx.W@2)) (and (= sx.R@8 sx.R@2) (= Civl_global_old_shadow.VC@1 shadow.VC@2))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@3) (= Civl_global_old_sx.W@1 sx.W@2)) (and (= Civl_global_old_sx.R@1 sx.R@2) (= Civl_linear_tid_available@9 Civl_linear_tid_available@3)))) (and (and (=> (= (ControlFlow 0 33) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 33) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 33) 17) Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@4 (store shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) nil)) (= (ControlFlow 0 34) 33)) anon14_Else_0$1_correct)))
(let ((anon14_Else_0_correct  (and (=> (= (ControlFlow 0 35) (- 0 38)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 35) (- 0 37)) (and (and (and (and (forall ((v@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@15) tid) (= (select shadow.Lock@2 v@@15) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@24 T@Var) ) (!  (=> (= (select sx.R@1 x@@24) SHARED) (= (select sx.R@1 x@@24) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@24 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 s@@24) tid) (= (select shadow.VC@1 s@@24) (select shadow.VC@1 s@@24)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@25 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@25)) tid) (= (select sx.R@1 x@@25) (select sx.R@1 x@@25)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@26 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@26)) tid) (= (select sx.W@1 x@@26) (select sx.W@1 x@@26)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@16 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@16) tid) (= (select shadow.Lock@2 v@@16) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@27 T@Var) ) (!  (=> (= (select sx.R@1 x@@27) SHARED) (= (select sx.R@1 x@@27) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@25 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 s@@25) tid) (= (select shadow.VC@1 s@@25) (select shadow.VC@1 s@@25)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@28 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@28)) tid) (= (select sx.R@1 x@@28) (select sx.R@1 x@@28)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@29 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@29)) tid) (= (select sx.W@1 x@@29) (select sx.W@1 x@@29)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 35) (- 0 36)) (and (forall ((s@@26 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@26))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@27 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@27))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@17 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@17) tid) (= (select shadow.Lock@3 v@@17) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@28 T@Shadowable) ) (!  (=> (and (and (not (= s@@28 (ShadowableTid tid))) (not (= s@@28 (ShadowableTid tid)))) (= (select shadow.Lock@2 s@@28) tid)) (= (select shadow.VC@1 s@@28) (select shadow.VC@2 s@@28)))
 :qid |verifiedftbpl.316:18|
 :skolemid |14|
)))) (and (and (forall ((s@@29 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@29))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@2 sx.R@2)) (= Civl_linear_tid_available@3 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (and (= (select shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid) (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1))) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 35) 34)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicChooseThreadToJoin$0$uid@1) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0))) (= (select shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) nil)) (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) tid)) (= thread.HasJoined@2 (store thread.HasJoined@1 tid inline$AtomicChooseThreadToJoin$0$uid@1 true)))) (and (and (=> (= (ControlFlow 0 39) 35) anon14_Else_0_correct) (=> (= (ControlFlow 0 39) 32) anon14_Else$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 39) 17) Civl_UnchangedChecker_correct))))))
(let ((anon14_Else_correct  (=> (and (and (= (select thread.State@1 tid) 2) (and (not (= tid nil)) (>= tid 0))) (= (ControlFlow 0 40) 39)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
(let ((anon10_Then_0_correct  (and (=> (= (ControlFlow 0 28) (- 0 31)) (and (forall ((s@@30 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@30))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@31 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@31))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (=> (= (ControlFlow 0 28) (- 0 30)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 28) (- 0 29)) (and (and (and (and (forall ((v@@18 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@18) tid) (= (select shadow.Lock@1 v@@18) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@30 T@Var) ) (!  (=> (= (select sx.R@1 x@@30) SHARED) (= (select sx.R@1 x@@30) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@32 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@32) tid) (= (select shadow.VC@1 s@@32) (select shadow.VC@1 s@@32)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@31 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@31)) tid) (= (select sx.R@1 x@@31) (select sx.R@1 x@@31)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@32 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@32)) tid) (= (select sx.W@1 x@@32) (select sx.W@1 x@@32)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@19 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@19) tid) (= (select shadow.Lock@1 v@@19) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@33 T@Var) ) (!  (=> (= (select sx.R@1 x@@33) SHARED) (= (select sx.R@1 x@@33) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@33 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@33) tid) (= (select shadow.VC@1 s@@33) (select shadow.VC@1 s@@33)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@34 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@34)) tid) (= (select sx.R@1 x@@34) (select sx.R@1 x@@34)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@35 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@35)) tid) (= (select sx.W@1 x@@35) (select sx.W@1 x@@35)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@34 T@Shadowable) ) (! (VCRepOk (select shadow.VC@7 s@@34))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@7 sx.R@7)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (and (forall ((v@@20 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@20) tid) (= (select shadow.Lock@13 v@@20) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@36 T@Var) ) (!  (=> (= (select sx.R@1 x@@36) SHARED) (= (select sx.R@7 x@@36) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@35 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@35) tid) (= (select shadow.VC@7 s@@35) (select shadow.VC@1 s@@35)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@37 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@37)) tid) (= (select sx.R@7 x@@37) (select sx.R@1 x@@37)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@38 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@38)) tid) (= (select sx.W@7 x@@38) (select sx.W@1 x@@38)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (= Civl_linear_tid_available@8 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= shadow.VC@8 shadow.VC@7))) (and (and (and (= shadow.Lock@14 shadow.Lock@13) (= sx.W@8 sx.W@7)) (and (= sx.R@8 sx.R@7) (= Civl_global_old_shadow.VC@1 shadow.VC@7))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@13) (= Civl_global_old_sx.W@1 sx.W@7)) (and (= Civl_global_old_sx.R@1 sx.R@7) (= Civl_linear_tid_available@9 Civl_linear_tid_available@8))))) (and (and (=> (= (ControlFlow 0 28) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 28) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 28) 17) Civl_UnchangedChecker_correct))))))))))))
(let ((anon11_Then_0_correct  (and (=> (= (ControlFlow 0 24) (- 0 27)) (and (forall ((s@@36 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@36))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@37 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@37))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (=> (= (ControlFlow 0 24) (- 0 26)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 24) (- 0 25)) (and (and (and (and (forall ((v@@21 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@21) tid) (= (select shadow.Lock@1 v@@21) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@39 T@Var) ) (!  (=> (= (select sx.R@1 x@@39) SHARED) (= (select sx.R@1 x@@39) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@38 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@38) tid) (= (select shadow.VC@1 s@@38) (select shadow.VC@1 s@@38)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@40 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@40)) tid) (= (select sx.R@1 x@@40) (select sx.R@1 x@@40)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@41 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@41)) tid) (= (select sx.W@1 x@@41) (select sx.W@1 x@@41)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@22 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@22) tid) (= (select shadow.Lock@1 v@@22) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@42 T@Var) ) (!  (=> (= (select sx.R@1 x@@42) SHARED) (= (select sx.R@1 x@@42) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@39 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@39) tid) (= (select shadow.VC@1 s@@39) (select shadow.VC@1 s@@39)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@43 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@43)) tid) (= (select sx.R@1 x@@43) (select sx.R@1 x@@43)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@44 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@44)) tid) (= (select sx.W@1 x@@44) (select sx.W@1 x@@44)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@40 T@Shadowable) ) (! (VCRepOk (select shadow.VC@6 s@@40))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@6 sx.R@6)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (and (forall ((v@@23 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@23) tid) (= (select shadow.Lock@12 v@@23) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@45 T@Var) ) (!  (=> (= (select sx.R@1 x@@45) SHARED) (= (select sx.R@6 x@@45) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@41 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@41) tid) (= (select shadow.VC@6 s@@41) (select shadow.VC@1 s@@41)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@46 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@46)) tid) (= (select sx.R@6 x@@46) (select sx.R@1 x@@46)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@47 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@47)) tid) (= (select sx.W@6 x@@47) (select sx.W@1 x@@47)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (= Civl_linear_tid_available@7 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= shadow.VC@8 shadow.VC@6))) (and (and (and (= shadow.Lock@14 shadow.Lock@12) (= sx.W@8 sx.W@6)) (and (= sx.R@8 sx.R@6) (= Civl_global_old_shadow.VC@1 shadow.VC@6))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@12) (= Civl_global_old_sx.W@1 sx.W@6)) (and (= Civl_global_old_sx.R@1 sx.R@6) (= Civl_linear_tid_available@9 Civl_linear_tid_available@7))))) (and (and (=> (= (ControlFlow 0 24) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 24) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 24) 17) Civl_UnchangedChecker_correct))))))))))))
(let ((anon10_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 18) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 18) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 18) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon11_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 16) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((anon9_LoopBody_correct  (=> ok@0 (and (and (and (and (and (and (and (and (=> (= (ControlFlow 0 76) 74) anon12_Then_correct) (=> (= (ControlFlow 0 76) 67) anon13_Then_correct)) (=> (= (ControlFlow 0 76) 58) anon14_Then_correct)) (=> (= (ControlFlow 0 76) 40) anon14_Else_correct)) (=> (= (ControlFlow 0 76) 24) anon11_Then_0_correct)) (=> (= (ControlFlow 0 76) 16) anon11_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 76) 17) Civl_UnchangedChecker_correct)) (=> (= (ControlFlow 0 76) 28) anon10_Then_0_correct)) (=> (= (ControlFlow 0 76) 18) anon10_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon9_LoopHead_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock@1 (ShadowableTid tid)) tid)) (and (and (forall ((s@@42 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@42))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 80) 79) anon9_LoopDone_correct) (=> (= (ControlFlow 0 80) 76) anon9_LoopBody_correct)))))
(let ((anon0_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 81) (- 0 84)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 81) (- 0 83)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 81) (- 0 82)) (and (forall ((s@@43 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@43))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@44 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@44))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (=> (= (ControlFlow 0 81) 80) anon9_LoopHead_correct)))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@0) (= sx.W@9 sx.W@0)) (and (= sx.R@9 sx.R@0) (= Civl_global_old_shadow.VC@2 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@0) (= Civl_global_old_sx.W@2 sx.W@0)) (and (= Civl_global_old_sx.R@2 sx.R@0) (= Civl_linear_tid_available@10 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_10$0$L0_correct) (=> (= (ControlFlow 0 15) 6) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 8) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_10$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_10$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (and (and (forall ((s@@45 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@45))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 85) 81) anon0_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 85) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 85) 1) Civl_RefinementChecker_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock (ShadowableTid tid)) tid)) (and (and (forall ((s@@46 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@46))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 86) 85))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun uid () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVC.Inc$0$v@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Join$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Join$0$v2@0 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Fork_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 43) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 19) (- 0 21)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@0 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@0 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s (ShadowableTid tid))) (not (= s (ShadowableTid uid)))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@3 s)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 (ShadowableTid tid))) (not (= s@@0 (ShadowableTid uid)))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@3 s@@0)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@3 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= (ControlFlow 0 17) (- 0 16))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@3 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (=> (= (ControlFlow 0 10) (- 0 11)) (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@3 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@0) SHARED) (= (select sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 6) (- 0 7)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (= (ControlFlow 0 6) (- 0 5)) (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@0 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@3 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@0 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (and (and (= (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid uid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))))) (VCRepOk (select shadow.VC@3 (ShadowableTid uid)))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (select (select shadow.VC@3 (ShadowableTid uid)) j@@2) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@2)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@2)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@2))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@2)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@2))))))
 :qid |verifiedftbpl.547:20|
 :skolemid |28|
))) (VCRepOk (select shadow.VC@3 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@3 Int) ) (!  (=> (and (<= 0 j@@3) (not (= j@@3 tid))) (= (select (select shadow.VC@3 (ShadowableTid tid)) j@@3) (select (select shadow.VC@0 (ShadowableTid tid)) j@@3)))
 :qid |verifiedftbpl.551:20|
 :skolemid |29|
))) (= (select (select shadow.VC@3 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@3 (store (store shadow.VC@0 (ShadowableTid uid) (select shadow.VC@3 (ShadowableTid uid))) (ShadowableTid tid) (select shadow.VC@3 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (and (and (= (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid uid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))))) (VCRepOk (select shadow.VC@3 (ShadowableTid uid)))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (select (select shadow.VC@3 (ShadowableTid uid)) j@@4) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@4)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@4)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@4))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@4)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@4))))))
 :qid |verifiedftbpl.547:20|
 :skolemid |28|
))) (VCRepOk (select shadow.VC@3 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@5 Int) ) (!  (=> (and (<= 0 j@@5) (not (= j@@5 tid))) (= (select (select shadow.VC@3 (ShadowableTid tid)) j@@5) (select (select shadow.VC@0 (ShadowableTid tid)) j@@5)))
 :qid |verifiedftbpl.551:20|
 :skolemid |29|
))) (= (select (select shadow.VC@3 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@3 (store (store shadow.VC@0 (ShadowableTid uid) (select shadow.VC@3 (ShadowableTid uid))) (ShadowableTid tid) (select shadow.VC@3 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@3 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (and (and (and (and (and (and (= (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid uid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))))) (VCRepOk (select shadow.VC@3 (ShadowableTid uid)))) (forall ((j@@6 Int) ) (!  (=> (<= 0 j@@6) (= (select (select shadow.VC@3 (ShadowableTid uid)) j@@6) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@6)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@6)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@6))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@6)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@6))))))
 :qid |verifiedftbpl.547:20|
 :skolemid |28|
))) (VCRepOk (select shadow.VC@3 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@3 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@7 Int) ) (!  (=> (and (<= 0 j@@7) (not (= j@@7 tid))) (= (select (select shadow.VC@3 (ShadowableTid tid)) j@@7) (select (select shadow.VC@0 (ShadowableTid tid)) j@@7)))
 :qid |verifiedftbpl.551:20|
 :skolemid |29|
))) (= (select (select shadow.VC@3 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@3 (store (store shadow.VC@0 (ShadowableTid uid) (select shadow.VC@3 (ShadowableTid uid))) (ShadowableTid tid) (select shadow.VC@3 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (and (= shadow.VC@2 (store shadow.VC@1 inline$AtomicVC.Inc$0$v@0 (store (select shadow.VC@1 inline$AtomicVC.Inc$0$v@0) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@1 inline$AtomicVC.Inc$0$v@0) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicVC.Inc$0$v@0) (- 0 1)))))))) (= shadow.VC@3 (store shadow.VC@2 inline$AtomicVC.Inc$0$v@0 (store (select shadow.VC@2 inline$AtomicVC.Inc$0$v@0) tid (epoch (|tid#epoch| (select (select shadow.VC@2 inline$AtomicVC.Inc$0$v@0) tid)) (+ (|clock#epoch| (select (select shadow.VC@2 inline$AtomicVC.Inc$0$v@0) tid)) 1)))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 10) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (= inline$AtomicVC.Inc$0$v@0 (ShadowableTid tid)) (= (ControlFlow 0 24) 23)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 25) (- 0 31)) (VCRepOk (select shadow.VC@1 (ShadowableTid tid)))) (=> (VCRepOk (select shadow.VC@1 (ShadowableTid tid))) (and (=> (= (ControlFlow 0 25) (- 0 30)) (>= tid 0)) (=> (>= tid 0) (and (=> (= (ControlFlow 0 25) (- 0 29)) (not (is-ShadowableVar (ShadowableTid tid)))) (=> (not (is-ShadowableVar (ShadowableTid tid))) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 27)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 26)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 25) 24) inline$AtomicVC.Inc$0$Entry_correct)))))))))))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@1 (store shadow.VC@0 inline$AtomicVC.Join$0$v1@0 (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0))) (= (ControlFlow 0 32) 25))) anon0$1_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (= inline$AtomicVC.Join$0$v1@0 (ShadowableTid uid)) (=> (and (= inline$AtomicVC.Join$0$v2@0 (ShadowableTid tid)) (= (ControlFlow 0 33) 32)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@6) tid) (= (select shadow.VC@0 s@@6) (select shadow.VC@@0 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (and (and (and (and (and (not (= tid uid)) (= (select shadow.Lock@0 (ShadowableTid uid)) tid)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (and (not (= uid nil)) (>= uid 0))) (and (not (= tid nil)) (>= tid 0))) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 34) (- 0 42)) (VCRepOk (select shadow.VC@0 (ShadowableTid tid)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableTid tid))) (and (=> (= (ControlFlow 0 34) (- 0 41)) (not (is-ShadowableVar (ShadowableTid tid)))) (=> (not (is-ShadowableVar (ShadowableTid tid))) (and (=> (= (ControlFlow 0 34) (- 0 40)) (not (is-ShadowableVar (ShadowableTid uid)))) (=> (not (is-ShadowableVar (ShadowableTid uid))) (and (=> (= (ControlFlow 0 34) (- 0 39)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 34) (- 0 38)) (= (select shadow.Lock@0 (ShadowableTid uid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid uid)) tid) (and (=> (= (ControlFlow 0 34) (- 0 37)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 34) (- 0 36)) (not (= (ShadowableTid uid) (ShadowableTid tid)))) (=> (not (= (ShadowableTid uid) (ShadowableTid tid))) (and (=> (= (ControlFlow 0 34) (- 0 35)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 34) 33) inline$AtomicVC.Join$0$Entry_correct)))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@9) tid) (= (select shadow.Lock v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R x@@9) SHARED) (= (select sx.R x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@8) tid) (= (select shadow.VC@@0 s@@8) (select shadow.VC@@0 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@10)) tid) (= (select sx.R x@@10) (select sx.R x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@11)) tid) (= (select sx.W x@@11) (select sx.W x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 43) 34))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun uid () Int)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun inline$AtomicVC.Join$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Join$0$v2@0 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Join_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 34) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 19) (- 0 21)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@0 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@0 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s (ShadowableTid tid))) (not (= s (ShadowableTid tid)))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@1 s)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 (ShadowableTid tid))) (not (= s@@0 (ShadowableTid tid)))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@1 s@@0)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= (ControlFlow 0 17) (- 0 16))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (=> (= (ControlFlow 0 10) (- 0 11)) (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@0) SHARED) (= (select sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 6) (- 0 7)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (= (ControlFlow 0 6) (- 0 5)) (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@0 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@1 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@0 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (|clock#epoch| (select (select shadow.VC@1 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))))) (VCRepOk (select shadow.VC@1 (ShadowableTid tid)))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (select (select shadow.VC@1 (ShadowableTid tid)) j@@2) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@2)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@2)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@2))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@2)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@2))))))
 :qid |verifiedftbpl.588:20|
 :skolemid |30|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid) (select shadow.VC@1 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (|clock#epoch| (select (select shadow.VC@1 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))))) (VCRepOk (select shadow.VC@1 (ShadowableTid tid)))) (forall ((j@@3 Int) ) (!  (=> (<= 0 j@@3) (= (select (select shadow.VC@1 (ShadowableTid tid)) j@@3) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@3)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@3)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@3))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@3)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@3))))))
 :qid |verifiedftbpl.588:20|
 :skolemid |30|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid) (select shadow.VC@1 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (and (and (= (|clock#epoch| (select (select shadow.VC@1 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) (- 0 1))))) (VCRepOk (select shadow.VC@1 (ShadowableTid tid)))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (select (select shadow.VC@1 (ShadowableTid tid)) j@@4) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@4)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@4)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@4))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid uid)) j@@4)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@4))))))
 :qid |verifiedftbpl.588:20|
 :skolemid |30|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid) (select shadow.VC@1 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (and (and (VCRepOk (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (= (|clock#epoch| (select (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) (- 0 1)))))) (and (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
)) (= shadow.VC@1 (store shadow.VC@0 inline$AtomicVC.Join$0$v1@0 (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 10) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (= inline$AtomicVC.Join$0$v1@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVC.Join$0$v2@0 (ShadowableTid uid)) (= (ControlFlow 0 24) 23)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@6) tid) (= (select shadow.VC@0 s@@6) (select shadow.VC@@0 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (and (and (and (and (and (not (= tid uid)) (= (select shadow.Lock@0 (ShadowableTid uid)) tid)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (and (not (= uid nil)) (>= uid 0))) (and (not (= tid nil)) (>= tid 0))) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 25) (- 0 33)) (VCRepOk (select shadow.VC@0 (ShadowableTid uid)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableTid uid))) (and (=> (= (ControlFlow 0 25) (- 0 32)) (not (is-ShadowableVar (ShadowableTid uid)))) (=> (not (is-ShadowableVar (ShadowableTid uid))) (and (=> (= (ControlFlow 0 25) (- 0 31)) (not (is-ShadowableVar (ShadowableTid tid)))) (=> (not (is-ShadowableVar (ShadowableTid tid))) (and (=> (= (ControlFlow 0 25) (- 0 30)) (= (select shadow.Lock@0 (ShadowableTid uid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid uid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 29)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 27)) (not (= (ShadowableTid tid) (ShadowableTid uid)))) (=> (not (= (ShadowableTid tid) (ShadowableTid uid))) (and (=> (= (ControlFlow 0 25) (- 0 26)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 25) 24) inline$AtomicVC.Join$0$Entry_correct)))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@9) tid) (= (select shadow.Lock v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R x@@9) SHARED) (= (select sx.R x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@8) tid) (= (select shadow.VC@@0 s@@8) (select shadow.VC@@0 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@10)) tid) (= (select sx.R x@@10) (select sx.R x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@11)) tid) (= (select sx.W x@@11) (select sx.W x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 34) 25))) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun l () T@Lock)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun inline$AtomicVC.Join$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Join$0$v2@0 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Acquire_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 34) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 19) (- 0 21)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@0 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@0 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s (ShadowableTid tid))) (not (= s (ShadowableTid tid)))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@1 s)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 (ShadowableTid tid))) (not (= s@@0 (ShadowableTid tid)))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@1 s@@0)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= (ControlFlow 0 17) (- 0 16))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (=> (= (ControlFlow 0 10) (- 0 11)) (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@0) SHARED) (= (select sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 6) (- 0 7)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (= (ControlFlow 0 6) (- 0 5)) (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@0 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@1 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@0 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 (ShadowableTid tid))) (= (|clock#epoch| (select (select shadow.VC@1 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (select (select shadow.VC@1 (ShadowableTid tid)) j@@2) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@2)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@2)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) j@@2))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) j@@2)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@2))))))
 :qid |verifiedftbpl.621:20|
 :skolemid |31|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid) (select shadow.VC@1 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 (ShadowableTid tid))) (= (|clock#epoch| (select (select shadow.VC@1 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@3 Int) ) (!  (=> (<= 0 j@@3) (= (select (select shadow.VC@1 (ShadowableTid tid)) j@@3) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@3)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@3)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) j@@3))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) j@@3)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@3))))))
 :qid |verifiedftbpl.621:20|
 :skolemid |31|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid) (select shadow.VC@1 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@1 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@1 (ShadowableTid tid))) (= (|clock#epoch| (select (select shadow.VC@1 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@4 Int) ) (!  (=> (<= 0 j@@4) (= (select (select shadow.VC@1 (ShadowableTid tid)) j@@4) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@4)) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@4)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) j@@4))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) j@@4)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@4))))))
 :qid |verifiedftbpl.621:20|
 :skolemid |31|
))) (= shadow.VC@1 (store shadow.VC@0 (ShadowableTid tid) (select shadow.VC@1 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (and (and (VCRepOk (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0)) (= (|clock#epoch| (select (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) (- 0 1)))))) (and (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v2@0) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Join$0$v1@0) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
)) (= shadow.VC@1 (store shadow.VC@0 inline$AtomicVC.Join$0$v1@0 (select shadow.VC@1 inline$AtomicVC.Join$0$v1@0))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 10) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (= inline$AtomicVC.Join$0$v1@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVC.Join$0$v2@0 (ShadowableLock l)) (= (ControlFlow 0 24) 23)) inline$AtomicVC.Join$0$anon0_correct))))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@6) tid) (= (select shadow.VC@0 s@@6) (select shadow.VC@@0 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (and (and (and (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (= (select shadow.Lock@0 (ShadowableLock l)) tid)) (and (not (= tid nil)) (>= tid 0))) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 25) (- 0 33)) (VCRepOk (select shadow.VC@0 (ShadowableLock l)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableLock l))) (and (=> (= (ControlFlow 0 25) (- 0 32)) (not (is-ShadowableVar (ShadowableLock l)))) (=> (not (is-ShadowableVar (ShadowableLock l))) (and (=> (= (ControlFlow 0 25) (- 0 31)) (not (is-ShadowableVar (ShadowableTid tid)))) (=> (not (is-ShadowableVar (ShadowableTid tid))) (and (=> (= (ControlFlow 0 25) (- 0 30)) (= (select shadow.Lock@0 (ShadowableLock l)) tid)) (=> (= (select shadow.Lock@0 (ShadowableLock l)) tid) (and (=> (= (ControlFlow 0 25) (- 0 29)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 27)) (not (= (ShadowableTid tid) (ShadowableLock l)))) (=> (not (= (ShadowableTid tid) (ShadowableLock l))) (and (=> (= (ControlFlow 0 25) (- 0 26)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 25) 24) inline$AtomicVC.Join$0$Entry_correct)))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@9) tid) (= (select shadow.Lock v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R x@@9) SHARED) (= (select sx.R x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@8) tid) (= (select shadow.VC@@0 s@@8) (select shadow.VC@@0 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@10)) tid) (= (select sx.R x@@10) (select sx.R x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@11)) tid) (= (select sx.W x@@11) (select sx.W x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 34) 25))) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun l () T@Lock)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVC.Inc$0$v@0 () T@Shadowable)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVC.Copy$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Copy$0$v2@0 () T@Shadowable)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Release_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 45) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 19) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 19) (- 0 21)) (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@0 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@2) tid) (= (select shadow.Lock@0 v@@2) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 19) (- 0 20)) (forall ((s T@Shadowable) ) (!  (=> (and (and (not (= s (ShadowableTid tid))) (not (= s (ShadowableLock l)))) (= (select shadow.Lock s) tid)) (= (select shadow.VC@@0 s) (select shadow.VC@5 s)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
))) (=> (forall ((s@@0 T@Shadowable) ) (!  (=> (and (and (not (= s@@0 (ShadowableTid tid))) (not (= s@@0 (ShadowableLock l)))) (= (select shadow.Lock s@@0) tid)) (= (select shadow.VC@@0 s@@0) (select shadow.VC@5 s@@0)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
)) (=> (= (ControlFlow 0 19) (- 0 18)) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@5 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= (ControlFlow 0 17) (- 0 16))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@5 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (=> (= (ControlFlow 0 10) (- 0 11)) (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@5 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@0 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@0) SHARED) (= (select sx.R@0 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@0 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@0 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@0 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 6) (- 0 7)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (= (ControlFlow 0 6) (- 0 5)) (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@0 v@@7) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@0 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@5 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@0 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@0 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 4)) (or false (or (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (and (and (and (and (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@5 (ShadowableLock l))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableLock l)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1)))))) (forall ((j@@2 Int) ) (!  (=> (<= 0 j@@2) (= (select (select shadow.VC@5 (ShadowableLock l)) j@@2) (select (select shadow.VC@0 (ShadowableTid tid)) j@@2)))
 :qid |verifiedftbpl.657:24|
 :skolemid |32|
))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@3 Int) ) (!  (=> (and (<= 0 j@@3) (not (= j@@3 tid))) (= (select (select shadow.VC@5 (ShadowableTid tid)) j@@3) (select (select shadow.VC@0 (ShadowableTid tid)) j@@3)))
 :qid |verifiedftbpl.664:20|
 :skolemid |33|
))) (= (select (select shadow.VC@5 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid) (select shadow.VC@5 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (select shadow.VC@5 (ShadowableLock l)) (select shadow.VC@0 (ShadowableTid tid))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@4 Int) ) (!  (=> (and (<= 0 j@@4) (not (= j@@4 tid))) (= (select (select shadow.VC@5 (ShadowableTid tid)) j@@4) (select (select shadow.VC@0 (ShadowableTid tid)) j@@4)))
 :qid |verifiedftbpl.664:20|
 :skolemid |33|
))) (= (select (select shadow.VC@5 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid) (select shadow.VC@5 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (and (and (and (and (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@5 (ShadowableLock l))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableLock l)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1)))))) (forall ((j@@5 Int) ) (!  (=> (<= 0 j@@5) (= (select (select shadow.VC@5 (ShadowableLock l)) j@@5) (select (select shadow.VC@0 (ShadowableTid tid)) j@@5)))
 :qid |verifiedftbpl.657:24|
 :skolemid |32|
))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@6 Int) ) (!  (=> (and (<= 0 j@@6) (not (= j@@6 tid))) (= (select (select shadow.VC@5 (ShadowableTid tid)) j@@6) (select (select shadow.VC@0 (ShadowableTid tid)) j@@6)))
 :qid |verifiedftbpl.664:20|
 :skolemid |33|
))) (= (select (select shadow.VC@5 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid) (select shadow.VC@5 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (select shadow.VC@5 (ShadowableLock l)) (select shadow.VC@0 (ShadowableTid tid))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@7 Int) ) (!  (=> (and (<= 0 j@@7) (not (= j@@7 tid))) (= (select (select shadow.VC@5 (ShadowableTid tid)) j@@7) (select (select shadow.VC@0 (ShadowableTid tid)) j@@7)))
 :qid |verifiedftbpl.664:20|
 :skolemid |33|
))) (= (select (select shadow.VC@5 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid) (select shadow.VC@5 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> false (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))) (=> (=> false (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (=> (and (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@5 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (or (and (and (and (and (and (and (and (and (and (and (and (and (and (VCRepOk (select shadow.VC@5 (ShadowableLock l))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableLock l)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableLock l)) (- 0 1)))))) (forall ((j@@8 Int) ) (!  (=> (<= 0 j@@8) (= (select (select shadow.VC@5 (ShadowableLock l)) j@@8) (select (select shadow.VC@0 (ShadowableTid tid)) j@@8)))
 :qid |verifiedftbpl.657:24|
 :skolemid |32|
))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@9 Int) ) (!  (=> (and (<= 0 j@@9) (not (= j@@9 tid))) (= (select (select shadow.VC@5 (ShadowableTid tid)) j@@9) (select (select shadow.VC@0 (ShadowableTid tid)) j@@9)))
 :qid |verifiedftbpl.664:20|
 :skolemid |33|
))) (= (select (select shadow.VC@5 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid) (select shadow.VC@5 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (select shadow.VC@5 (ShadowableLock l)) (select shadow.VC@0 (ShadowableTid tid))) (VCRepOk (select shadow.VC@5 (ShadowableTid tid)))) (= (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@5 (ShadowableTid tid)) (- 0 1)))))) (forall ((j@@10 Int) ) (!  (=> (and (<= 0 j@@10) (not (= j@@10 tid))) (= (select (select shadow.VC@5 (ShadowableTid tid)) j@@10) (select (select shadow.VC@0 (ShadowableTid tid)) j@@10)))
 :qid |verifiedftbpl.664:20|
 :skolemid |33|
))) (= (select (select shadow.VC@5 (ShadowableTid tid)) tid) (epoch (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (+ (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) tid)) 1)))) (= shadow.VC@5 (store (store shadow.VC@0 (ShadowableLock l) (select shadow.VC@5 (ShadowableLock l))) (ShadowableTid tid) (select shadow.VC@5 (ShadowableTid tid))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) false))) (= (ControlFlow 0 2) (- 0 1))) Civl_ok@0)))))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (and (= shadow.VC@4 (store shadow.VC@3 inline$AtomicVC.Inc$0$v@0 (store (select shadow.VC@3 inline$AtomicVC.Inc$0$v@0) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@3 inline$AtomicVC.Inc$0$v@0) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@3 inline$AtomicVC.Inc$0$v@0) (- 0 1)))))))) (= shadow.VC@5 (store shadow.VC@4 inline$AtomicVC.Inc$0$v@0 (store (select shadow.VC@4 inline$AtomicVC.Inc$0$v@0) tid (epoch (|tid#epoch| (select (select shadow.VC@4 inline$AtomicVC.Inc$0$v@0) tid)) (+ (|clock#epoch| (select (select shadow.VC@4 inline$AtomicVC.Inc$0$v@0) tid)) 1)))))) (and (and (and (and (and (and (=> (= (ControlFlow 0 23) 2) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 10) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 17) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 19) GeneratedUnifiedExit_correct)))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (and (= inline$AtomicVC.Inc$0$v@0 (ShadowableTid tid)) (= (ControlFlow 0 24) 23)) inline$AtomicVC.Inc$0$anon0_correct)))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 25) (- 0 31)) (VCRepOk (select shadow.VC@3 (ShadowableTid tid)))) (=> (VCRepOk (select shadow.VC@3 (ShadowableTid tid))) (and (=> (= (ControlFlow 0 25) (- 0 30)) (>= tid 0)) (=> (>= tid 0) (and (=> (= (ControlFlow 0 25) (- 0 29)) (not (is-ShadowableVar (ShadowableTid tid)))) (=> (not (is-ShadowableVar (ShadowableTid tid))) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 27)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 26)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 25) 24) inline$AtomicVC.Inc$0$Entry_correct)))))))))))))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (= shadow.VC@2 (store shadow.VC@0 inline$AtomicVC.Copy$0$v1@0 (select shadow.VC@0 inline$AtomicVC.Copy$0$v2@0))) (=> (and (= shadow.VC@3 shadow.VC@2) (= (ControlFlow 0 33) 25)) anon0$1_correct))))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (and (VCRepOk (select shadow.VC@1 inline$AtomicVC.Copy$0$v1@0)) (= (|clock#epoch| (select (select shadow.VC@1 inline$AtomicVC.Copy$0$v1@0) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Copy$0$v1@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Copy$0$v2@0) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Copy$0$v2@0) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicVC.Copy$0$v1@0) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@1 inline$AtomicVC.Copy$0$v1@0) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@0 inline$AtomicVC.Copy$0$v2@0) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
)) (= shadow.VC@1 (store shadow.VC@0 inline$AtomicVC.Copy$0$v1@0 (select shadow.VC@1 inline$AtomicVC.Copy$0$v1@0)))) (and (= shadow.VC@3 shadow.VC@1) (= (ControlFlow 0 32) 25))) anon0$1_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (= inline$AtomicVC.Copy$0$v1@0 (ShadowableLock l)) (= inline$AtomicVC.Copy$0$v2@0 (ShadowableTid tid))) (and (=> (= (ControlFlow 0 34) 32) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 34) 33) inline$AtomicVC.Copy$0$anon3_Else_correct)))))
(let ((anon0_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R x@@6) SHARED) (= (select sx.R@0 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@6) tid) (= (select shadow.VC@0 s@@6) (select shadow.VC@@0 s@@6)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@7)) tid) (= (select sx.R@0 x@@7) (select sx.R x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@8)) tid) (= (select sx.W@0 x@@8) (select sx.W x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (and (and (and (= (select shadow.Lock@0 (ShadowableLock l)) tid) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (and (not (= tid nil)) (>= tid 0))) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 35) (- 0 44)) (VCRepOk (select shadow.VC@0 (ShadowableLock l)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableLock l))) (and (=> (= (ControlFlow 0 35) (- 0 43)) (VCRepOk (select shadow.VC@0 (ShadowableTid tid)))) (=> (VCRepOk (select shadow.VC@0 (ShadowableTid tid))) (and (=> (= (ControlFlow 0 35) (- 0 42)) (not (is-ShadowableVar (ShadowableTid tid)))) (=> (not (is-ShadowableVar (ShadowableTid tid))) (and (=> (= (ControlFlow 0 35) (- 0 41)) (not (is-ShadowableVar (ShadowableLock l)))) (=> (not (is-ShadowableVar (ShadowableLock l))) (and (=> (= (ControlFlow 0 35) (- 0 40)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 35) (- 0 39)) (= (select shadow.Lock@0 (ShadowableLock l)) tid)) (=> (= (select shadow.Lock@0 (ShadowableLock l)) tid) (and (=> (= (ControlFlow 0 35) (- 0 38)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 35) (- 0 37)) (not (= (ShadowableLock l) (ShadowableTid tid)))) (=> (not (= (ShadowableLock l) (ShadowableTid tid))) (and (=> (= (ControlFlow 0 35) (- 0 36)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 35) 34) inline$AtomicVC.Copy$0$Entry_correct)))))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@9) tid) (= (select shadow.Lock v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R x@@9) SHARED) (= (select sx.R x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@8) tid) (= (select shadow.VC@@0 s@@8) (select shadow.VC@@0 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@10)) tid) (= (select sx.R x@@10) (select sx.R x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@11)) tid) (= (select sx.W x@@11) (select sx.W x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 45) 35))) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun Civl_pc@1 () Bool)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@2 () (Array Int Int))
(declare-fun Civl_global_old_thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@2 () (Array Int Int))
(declare-fun Civl_global_old_thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun Civl_global_old_thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun x@@0 () T@Var)
(declare-fun tid () Int)
(declare-fun ok@0 () Bool)
(declare-fun Civl_old_ok@0 () Bool)
(declare-fun Civl_pc@2 () Bool)
(declare-fun Civl_ok@2 () Bool)
(declare-fun Civl_ok@1 () Bool)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun ok () Bool)
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@8 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun sx.W@6 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@7 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$AtomicVarStateGetWNoLock$0$e@1 () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@1 () T@Epoch)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun inline$AtomicVCGetElem$1$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$i@0 () Int)
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun inline$AtomicVC.Leq$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicVC.Leq$0$v2@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$i@0 () Int)
(declare-fun call1formal@Civl_1_old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun call2formal@Civl_1_old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun call3formal@Civl_1_old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun call4formal@Civl_1_old.sx.R@0 () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Write_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 110) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 26) (- 0 28)) (or Civl_pc@1 (or (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@5 x@@0) (select (select shadow.VC@2 (ShadowableTid tid)) tid)) (= ok@0 true)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)))))) (not (= (select sx.R@2 x@@0) SHARED))) (and (= (|tid#epoch| (select sx.R@2 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))) (<= (|clock#epoch| (select sx.R@2 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@0 (select (select shadow.VC@2 (ShadowableTid tid)) tid)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)))))) (= (select sx.R@2 x@@0) SHARED)) (forall ((j@@2 Int) ) (!  (=> (and (and (<= 0 j@@2) (< j@@2 (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1)))))) (f j@@2)) (and (= (|tid#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@2)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@2))) (<= (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@2)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@2)))))
 :qid |verifiedftbpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@2))
))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@0 (select (select shadow.VC@2 (ShadowableTid tid)) tid)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@5 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.W@5 x@@0))))) (<= (|clock#epoch| (select sx.W@5 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.W@5 x@@0))))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@2 x@@0) SHARED)) (not (and (= (|tid#epoch| (select sx.R@2 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))) (<= (|clock#epoch| (select sx.R@2 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0)))))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@2 x@@0) SHARED) (not (forall ((j@@3 Int) ) (!  (=> (and (and (<= 0 j@@3) (< j@@3 (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1)))))) (f j@@3)) (and (= (|tid#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@3)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@3))) (<= (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@3)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@3)))))
 :qid |verifiedftbpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@3))
)))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)))))) (=> (or Civl_pc@1 (or (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@5 x@@0) (select (select shadow.VC@2 (ShadowableTid tid)) tid)) (= ok@0 true)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)))))) (not (= (select sx.R@2 x@@0) SHARED))) (and (= (|tid#epoch| (select sx.R@2 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))) (<= (|clock#epoch| (select sx.R@2 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@0 (select (select shadow.VC@2 (ShadowableTid tid)) tid)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)))))) (= (select sx.R@2 x@@0) SHARED)) (forall ((j@@4 Int) ) (!  (=> (and (and (<= 0 j@@4) (< j@@4 (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1)))))) (f j@@4)) (and (= (|tid#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@4)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@4))) (<= (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@4)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@4)))))
 :qid |verifiedftbpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@4))
))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@0 (select (select shadow.VC@2 (ShadowableTid tid)) tid)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@5 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.W@5 x@@0))))) (<= (|clock#epoch| (select sx.W@5 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.W@5 x@@0))))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@2 x@@0) SHARED)) (not (and (= (|tid#epoch| (select sx.R@2 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))) (<= (|clock#epoch| (select sx.R@2 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0)))))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@2 x@@0) SHARED) (not (forall ((j@@5 Int) ) (!  (=> (and (and (<= 0 j@@5) (< j@@5 (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1)))))) (f j@@5)) (and (= (|tid#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@5)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@5))) (<= (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@5)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@5)))))
 :qid |verifiedftbpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@5))
)))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))))) (and (=> (= (ControlFlow 0 26) (- 0 27)) (=> Civl_pc@1 (and (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (= ok@0 Civl_old_ok@0)))) (=> (=> Civl_pc@1 (and (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (= ok@0 Civl_old_ok@0))) (=> (and (and (= Civl_pc@2  (=> (and (and (and (and (and (and (= shadow.VC@2 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) Civl_pc@1)) (= Civl_ok@2  (or (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@5 x@@0) (select (select shadow.VC@2 (ShadowableTid tid)) tid)) (= ok@0 true)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)))))) (not (= (select sx.R@2 x@@0) SHARED))) (and (= (|tid#epoch| (select sx.R@2 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))) (<= (|clock#epoch| (select sx.R@2 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@0 (select (select shadow.VC@2 (ShadowableTid tid)) tid)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.W@0 x@@0)))))) (= (select sx.R@2 x@@0) SHARED)) (forall ((j@@6 Int) ) (!  (=> (and (and (<= 0 j@@6) (< j@@6 (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1)))))) (f j@@6)) (and (= (|tid#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@6)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@6))) (<= (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@6)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@6)))))
 :qid |verifiedftbpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@6))
))) (= ok@0 true)) (= sx.W@5 (store Civl_global_old_sx.W@0 x@@0 (select (select shadow.VC@2 (ShadowableTid tid)) tid)))) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@5 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.W@5 x@@0))))) (<= (|clock#epoch| (select sx.W@5 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.W@5 x@@0))))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@2 x@@0) SHARED)) (not (and (= (|tid#epoch| (select sx.R@2 x@@0)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0))))) (<= (|clock#epoch| (select sx.R@2 x@@0)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (|tid#epoch| (select sx.R@2 x@@0)))))))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@2 x@@0) SHARED) (not (forall ((j@@7 Int) ) (!  (=> (and (and (<= 0 j@@7) (< j@@7 (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) (- 0 1)))))) (f j@@7)) (and (= (|tid#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@7)) (|tid#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@7))) (<= (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) j@@7)) (|clock#epoch| (select (select shadow.VC@2 (ShadowableTid tid)) j@@7)))))
 :qid |verifiedftbpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@7))
)))) (= ok@0 false)) (= shadow.VC@2 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@5 Civl_global_old_sx.W@0)) (= sx.R@2 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (= ok@0 Civl_old_ok@0) Civl_ok@1)))) (= (ControlFlow 0 26) (- 0 25))) Civl_ok@2)))))))
(let ((anon12_Then_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@0) (=> (and (= sx.W@5 sx.W@0) (= ok@0 true)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@0) (= sx.R@2 sx.R@0)) (and (= thread.State@2 thread.State@0) (= thread.ForkedBy@2 thread.ForkedBy@0))) (and (and (= thread.HasJoined@2 thread.HasJoined@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_global_old_thread.State@0 thread.State@0)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@0) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@0))) (and (and (= Civl_pc@1 false) (= Civl_ok@1 false)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 99) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon13_Then$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@6) (=> (and (= sx.W@5 sx.W@1) (= ok@0 false)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@1) (= sx.R@2 sx.R@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 76) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon15_Then$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@5) (=> (and (= sx.W@5 sx.W@1) (= ok@0 false)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@1) (= sx.R@2 sx.R@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 60) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon16_Then$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@3) (=> (and (= sx.W@5 sx.W@1) (= ok@0 false)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@1) (= sx.R@2 sx.R@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 39) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon11$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.Lock@7 shadow.Lock@4) (=> (and (= sx.W@5 sx.W@4) (= ok@0 true)) (=> (and (and (and (and (= shadow.VC@2 shadow.VC@1) (= sx.R@2 sx.R@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 29) 26))))) Civl_ReturnChecker_correct)))))
(let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (and (forall ((s T@Shadowable) ) (! (VCRepOk (select shadow.VC@5 s))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@8 sx.R@5))) (=> (and (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select shadow.VC@5 s@@0))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@8 sx.R@5)) (and (=> (= (ControlFlow 0 20) (- 0 21)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 20) (- 0 19)) (and (and (and (and (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@10 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@1 T@Var) ) (!  (=> (= (select sx.R x@@1) SHARED) (= (select sx.R@5 x@@1) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@1) tid) (= (select shadow.VC@5 s@@1) (select shadow.VC@@0 s@@1)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@2)) tid) (= (select sx.R@5 x@@2) (select sx.R x@@2)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@3 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@3)) tid) (= (select sx.W@8 x@@3) (select sx.W x@@3)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@5 sx.R@3) (=> (and (and (= sx.W@8 sx.W@6) (= shadow.Lock@10 shadow.Lock@8)) (and (= shadow.VC@5 shadow.VC@3) (= (ControlFlow 0 23) 20))) GeneratedUnifiedExit_correct))))
(let ((anon12_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@0) (=> (and (and (= sx.W@6 sx.W@0) (= shadow.VC@3 shadow.VC@0)) (and (= sx.R@3 sx.R@0) (= (ControlFlow 0 100) 23))) Civl_UnifiedReturn_correct))))
(let ((anon13_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@6) (=> (and (and (= sx.W@6 sx.W@1) (= shadow.VC@3 shadow.VC@1)) (and (= sx.R@3 sx.R@1) (= (ControlFlow 0 77) 23))) Civl_UnifiedReturn_correct))))
(let ((anon15_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@5) (=> (and (and (= sx.W@6 sx.W@1) (= shadow.VC@3 shadow.VC@1)) (and (= sx.R@3 sx.R@1) (= (ControlFlow 0 61) 23))) Civl_UnifiedReturn_correct))))
(let ((anon16_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@3) (=> (and (and (= sx.W@6 sx.W@1) (= shadow.VC@3 shadow.VC@1)) (and (= sx.R@3 sx.R@1) (= (ControlFlow 0 40) 23))) Civl_UnifiedReturn_correct))))
(let ((anon11$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.Lock@8 shadow.Lock@4) (=> (and (and (= sx.W@6 sx.W@4) (= shadow.VC@3 shadow.VC@1)) (and (= sx.R@3 sx.R@1) (= (ControlFlow 0 24) 23))) Civl_UnifiedReturn_correct))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@1 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@1 Civl_global_old_sx.R@1)) (= (ControlFlow 0 16) (- 0 15))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@4 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@7 sx.R@4)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@1 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 13) (- 0 14)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (=> (= (ControlFlow 0 13) (- 0 12)) (= (select shadow.Lock@9 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select Civl_global_old_shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 9) (- 0 11)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (=> (= (ControlFlow 0 9) (- 0 10)) (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@9 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@9 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 9) (- 0 8)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@4 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@4) SHARED) (= (select Civl_global_old_sx.R@1 x@@4) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.VC@1 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_sx.R@1 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@5)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@6 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@6)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_sx.W@1 x@@6) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@6)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 5) (- 0 6)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (= (ControlFlow 0 5) (- 0 4)) (and (and (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@9 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@7 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@7) SHARED) (= (select sx.R@4 x@@7) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@4 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@8)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@4 x@@8) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@8)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@9 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@9)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@7 x@@9) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@9)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((anon12_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@7 sx.W@0)) (and (= sx.R@4 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 101) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 101) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 101) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 101) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 101) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon12_Then_correct  (=> (= inline$AtomicVarStateGetWNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 102) 99) anon12_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 102) 100) anon12_Then_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 102) 101) anon12_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@6) (= sx.W@7 sx.W@1)) (and (= sx.R@4 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 78) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 78) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 78) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 78) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 78) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$3$anon0_correct  (=> (= shadow.Lock@6 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 79) 76) anon13_Then$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 79) 77) anon13_Then$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 79) 78) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon13_Then_correct  (=> (not (and (= (|tid#epoch| inline$AtomicVarStateGetW$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$0$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetW$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$0$e@1)))) (and (=> (= (ControlFlow 0 80) (- 0 82)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 80) (- 0 81)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 80) 79) inline$AtomicReleaseVarLock$3$anon0_correct))))))))
(let ((anon15_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@5) (= sx.W@7 sx.W@1)) (and (= sx.R@4 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 62) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 62) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 62) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 62) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 62) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$2$anon0_correct  (=> (= shadow.Lock@5 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 63) 60) anon15_Then$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 63) 61) anon15_Then$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 63) 62) anon15_Then$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon15_Then_correct  (=> (not (and (= (|tid#epoch| inline$AtomicVarStateGetR$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$1$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetR$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$1$e@1)))) (and (=> (= (ControlFlow 0 64) (- 0 66)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 64) (- 0 65)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 64) 63) inline$AtomicReleaseVarLock$2$anon0_correct))))))))
(let ((anon16_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@3) (= sx.W@7 sx.W@1)) (and (= sx.R@4 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 41) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 41) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 41) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 41) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 41) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (= shadow.Lock@3 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 42) 39) anon16_Then$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 42) 40) anon16_Then$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 42) 41) anon16_Then$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon16_Then_correct  (=> (not inline$AtomicVC.Leq$0$res@1) (and (=> (= (ControlFlow 0 43) (- 0 45)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 43) (- 0 44)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 43) 42) inline$AtomicReleaseVarLock$1$anon0_correct))))))))
(let ((anon11$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@4) (= sx.W@7 sx.W@4)) (and (= sx.R@4 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 18) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 18) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (= shadow.Lock@4 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 30) 29) anon11$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 30) 24) anon11$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 30) 18) anon11$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon11_correct  (and (=> (= (ControlFlow 0 31) (- 0 33)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 31) (- 0 32)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 31) 30) inline$AtomicReleaseVarLock$0$anon0_correct)))))))
(let ((anon15_Else$1_correct  (=> (and (= sx.W@4 sx.W@3) (= (ControlFlow 0 55) 31)) anon11_correct)))
(let ((inline$AtomicVarStateSetW$1$anon0_correct  (=> (and (= sx.W@3 (store sx.W@1 x@@0 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 56) 55)) anon15_Else$1_correct)))
(let ((anon15_Else_correct  (=> (and (= (|tid#epoch| inline$AtomicVarStateGetR$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$1$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetR$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$1$e@1))) (and (=> (= (ControlFlow 0 57) (- 0 59)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 57) (- 0 58)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 57) 56) inline$AtomicVarStateSetW$1$anon0_correct))))))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@1 (select (select shadow.VC@1 inline$AtomicVCGetElem$1$r@0) inline$AtomicVCGetElem$1$i@0)) (and (=> (= (ControlFlow 0 67) 64) anon15_Then_correct) (=> (= (ControlFlow 0 67) 57) anon15_Else_correct)))))
(let ((inline$AtomicVCGetElem$1$Entry_correct  (=> (= inline$AtomicVCGetElem$1$r@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVCGetElem$1$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 68) 67)) inline$AtomicVCGetElem$1$anon0_correct))))
(let ((anon14_Then_correct  (=> (not (= inline$AtomicVarStateGetR$0$e@1 SHARED)) (and (=> (= (ControlFlow 0 69) (- 0 71)) (= (select shadow.Lock@2 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@2 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 69) (- 0 70)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 69) 68) inline$AtomicVCGetElem$1$Entry_correct))))))))
(let ((anon16_Else$1_correct  (=> (and (= sx.W@4 sx.W@2) (= (ControlFlow 0 34) 31)) anon11_correct)))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@2 (store sx.W@1 x@@0 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 35) 34)) anon16_Else$1_correct)))
(let ((anon16_Else_correct  (=> inline$AtomicVC.Leq$0$res@1 (and (=> (= (ControlFlow 0 36) (- 0 38)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 36) (- 0 37)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 36) 35) inline$AtomicVarStateSetW$0$anon0_correct))))))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@1 inline$AtomicVC.Leq$0$v1@0) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicVC.Leq$0$v2@0) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@1 inline$AtomicVC.Leq$0$v1@0) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicVC.Leq$0$v2@0) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (and (=> (= (ControlFlow 0 46) 43) anon16_Then_correct) (=> (= (ControlFlow 0 46) 36) anon16_Else_correct)))))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (= inline$AtomicVC.Leq$0$v1@0 (ShadowableVar x@@0)) (=> (and (= inline$AtomicVC.Leq$0$v2@0 (ShadowableTid tid)) (= (ControlFlow 0 47) 46)) inline$AtomicVC.Leq$0$anon0_correct))))
(let ((anon14_Else_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 SHARED) (and (=> (= (ControlFlow 0 48) (- 0 54)) (not (is-ShadowableVar (ShadowableTid tid)))) (=> (not (is-ShadowableVar (ShadowableTid tid))) (and (=> (= (ControlFlow 0 48) (- 0 53)) (=> (is-ShadowableVar (ShadowableVar x@@0)) (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED))) (=> (=> (is-ShadowableVar (ShadowableVar x@@0)) (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED)) (and (=> (= (ControlFlow 0 48) (- 0 52)) (= (select shadow.Lock@2 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@2 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 48) (- 0 51)) (= (select shadow.Lock@2 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@2 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 48) (- 0 50)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 48) (- 0 49)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 48) 47) inline$AtomicVC.Leq$0$Entry_correct))))))))))))))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@1 x@@0)) (and (=> (= (ControlFlow 0 72) 69) anon14_Then_correct) (=> (= (ControlFlow 0 72) 48) anon14_Else_correct)))))
(let ((anon13_Else_correct  (=> (and (= (|tid#epoch| inline$AtomicVarStateGetW$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$0$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetW$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$0$e@1))) (and (=> (= (ControlFlow 0 73) (- 0 75)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 73) (- 0 74)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 73) 72) inline$AtomicVarStateGetR$0$anon0_correct))))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 inline$AtomicVCGetElem$0$r@0) inline$AtomicVCGetElem$0$i@0)) (and (=> (= (ControlFlow 0 83) 80) anon13_Then_correct) (=> (= (ControlFlow 0 83) 73) anon13_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= inline$AtomicVCGetElem$0$r@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVCGetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetW$0$e@1)) (= (ControlFlow 0 84) 83)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((anon2_0$2_correct  (and (=> (= (ControlFlow 0 85) (- 0 87)) (= (select shadow.Lock@2 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@2 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 85) (- 0 86)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 85) 84) inline$AtomicVCGetElem$0$Entry_correct)))))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@1 x@@0)) (= (ControlFlow 0 88) 85)) anon2_0$2_correct)))
(let ((anon2_0$1_correct  (and (=> (= (ControlFlow 0 89) (- 0 91)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 89) (- 0 90)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 89) 88) inline$AtomicVarStateGetW$0$anon0_correct)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableVar x@@0)) nil) (=> (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableVar x@@0) tid)) (= (ControlFlow 0 92) 89)) anon2_0$1_correct))))
(let ((anon2_0_correct  (=> (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@0 x@@0) (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0)))))) (not (= (select sx.R@0 x@@0) SHARED))) (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0)))))) (= (select sx.R@0 x@@0) SHARED)) (forall ((j@@8 Int) ) (!  (=> (and (and (<= 0 j@@8) (< j@@8 (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1)))))) (f j@@8)) (and (= (|tid#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@8)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@8))) (<= (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@8)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@8)))))
 :qid |verifiedftbpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@8))
))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (not (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0)))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (not (forall ((j@@9 Int) ) (!  (=> (and (and (<= 0 j@@9) (< j@@9 (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))))) (f j@@9)) (and (= (|tid#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@9)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@9))) (<= (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@9)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@9)))))
 :qid |verifiedftbpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@9))
)))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (= ok ok) false)))) (=> (and (and (= call1formal@Civl_1_old.shadow.Lock@0 shadow.Lock) (= call2formal@Civl_1_old.shadow.VC@0 shadow.VC@@0)) (and (= call3formal@Civl_1_old.sx.W@0 sx.W) (= call4formal@Civl_1_old.sx.R@0 sx.R))) (and (=> (= (ControlFlow 0 93) (- 0 97)) (and (forall ((s@@6 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@6))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 93) (- 0 96)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 93) (- 0 95)) (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@7) tid) (= (select shadow.Lock@0 v@@7) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@10 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@10) SHARED) (= (select sx.R@0 x@@10) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@8) tid) (= (select shadow.VC@0 s@@8) (select call2formal@Civl_1_old.shadow.VC@0 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@11)) tid) (= (select sx.R@0 x@@11) (select call4formal@Civl_1_old.sx.R@0 x@@11)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@12 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@12)) tid) (= (select sx.W@0 x@@12) (select call3formal@Civl_1_old.sx.W@0 x@@12)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@13 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@13) SHARED) (= (select sx.R@0 x@@13) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@9 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@9) tid) (= (select shadow.VC@0 s@@9) (select call2formal@Civl_1_old.shadow.VC@0 s@@9)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@14)) tid) (= (select sx.R@0 x@@14) (select call4formal@Civl_1_old.sx.R@0 x@@14)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@15 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@15)) tid) (= (select sx.W@0 x@@15) (select call3formal@Civl_1_old.sx.W@0 x@@15)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@10 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@10))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@9) tid) (= (select shadow.Lock@1 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@16 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@16) SHARED) (= (select sx.R@1 x@@16) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@11) tid) (= (select shadow.VC@1 s@@11) (select call2formal@Civl_1_old.shadow.VC@0 s@@11)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@17)) tid) (= (select sx.R@1 x@@17) (select call4formal@Civl_1_old.sx.R@0 x@@17)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@18 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@18)) tid) (= (select sx.W@1 x@@18) (select call3formal@Civl_1_old.sx.W@0 x@@18)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (or Civl_pc@0 (and (not (= tid nil)) (>= tid 0))) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 93) (- 0 94)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 93) 92) inline$AtomicAcquireVarLock$0$anon0_correct)))))))))))))))
(let ((anon12_Else_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@4 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@7 sx.W@0)) (and (= sx.R@4 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 17) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 17) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 17) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 17) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@0 x@@0) (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0)))))) (not (= (select sx.R@0 x@@0) SHARED))) (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0)))))) (= (select sx.R@0 x@@0) SHARED)) (forall ((j@@10 Int) ) (!  (=> (and (and (<= 0 j@@10) (< j@@10 (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1)))))) (f j@@10)) (and (= (|tid#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@10)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@10))) (<= (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@10)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@10)))))
 :qid |verifiedftbpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@10))
))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (not (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0)))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (not (forall ((j@@11 Int) ) (!  (=> (and (and (<= 0 j@@11) (< j@@11 (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))))) (f j@@11)) (and (= (|tid#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@11)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@11))) (<= (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@11)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@11)))))
 :qid |verifiedftbpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@11))
)))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.W@0 x@@0) (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0)))))) (not (= (select sx.R@0 x@@0) SHARED))) (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0)))))) (= (select sx.R@0 x@@0) SHARED)) (forall ((j@@12 Int) ) (!  (=> (and (and (<= 0 j@@12) (< j@@12 (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1)))))) (f j@@12)) (and (= (|tid#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@12)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@12))) (<= (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@12)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@12)))))
 :qid |verifiedftbpl.712:29|
 :skolemid |34|
 :pattern ( (f j@@12))
))) (= ok true)) (= sx.W@0 (store sx.W@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (not (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0)))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (not (forall ((j@@13 Int) ) (!  (=> (and (and (<= 0 j@@13) (< j@@13 (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1))) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (- 0 1)))))) (f j@@13)) (and (= (|tid#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@13)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@13))) (<= (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) j@@13)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) j@@13)))))
 :qid |verifiedftbpl.729:30|
 :skolemid |35|
 :pattern ( (f j@@13))
)))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> false (and (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (= ok ok))))))))
(let ((anon12_Else_correct  (=> (not (= inline$AtomicVarStateGetWNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 98) 93) anon2_0_correct) (=> (= (ControlFlow 0 98) 17) anon12_Else_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 98) 2) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVarStateGetWNoLock$0$anon0_correct  (=> (= inline$AtomicVarStateGetWNoLock$0$e@1 (select sx.W@0 x@@0)) (and (=> (= (ControlFlow 0 103) 102) anon12_Then_correct) (=> (= (ControlFlow 0 103) 98) anon12_Else_correct)))))
(let ((anon0$1_correct  (and (=> (= (ControlFlow 0 104) (- 0 105)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 104) 103) inline$AtomicVarStateGetWNoLock$0$anon0_correct)))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (= (ControlFlow 0 106) 104)) anon0$1_correct)))
(let ((anon0_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (and (and (forall ((s@@12 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@12))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (not (= tid nil)) (>= tid 0)))) (=> (and (and (and (and (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@10) tid) (= (select shadow.Lock@0 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@19 T@Var) ) (!  (=> (= (select sx.R x@@19) SHARED) (= (select sx.R@0 x@@19) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@13) tid) (= (select shadow.VC@0 s@@13) (select shadow.VC@@0 s@@13)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@20 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@20)) tid) (= (select sx.R@0 x@@20) (select sx.R x@@20)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@21 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@21)) tid) (= (select sx.W@0 x@@21) (select sx.W x@@21)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (not (= tid nil)) (>= tid 0)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 107) (- 0 109)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 107) (- 0 108)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 107) 106) inline$AtomicThreadStateGetE$0$anon0_correct)))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock (ShadowableTid tid)) tid)) (and (and (forall ((s@@14 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@14))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (and (not (= tid nil)) (>= tid 0)))) (=> (and (and (and (and (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@11) tid) (= (select shadow.Lock v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@22 T@Var) ) (!  (=> (= (select sx.R x@@22) SHARED) (= (select sx.R x@@22) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@15) tid) (= (select shadow.VC@@0 s@@15) (select shadow.VC@@0 s@@15)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@23 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@23)) tid) (= (select sx.R x@@23) (select sx.R x@@23)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@24 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@24)) tid) (= (select sx.W x@@24) (select sx.W x@@24)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= (ControlFlow 0 110) 107)) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun Civl_pc@1 () Bool)
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@2 () (Array Int Int))
(declare-fun Civl_global_old_thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@2 () (Array Int Int))
(declare-fun Civl_global_old_thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun Civl_global_old_thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun x@@0 () T@Var)
(declare-fun tid () Int)
(declare-fun ok@0 () Bool)
(declare-fun Civl_old_ok@0 () Bool)
(declare-fun Civl_pc@2 () Bool)
(declare-fun Civl_ok@2 () Bool)
(declare-fun Civl_ok@1 () Bool)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun ok () Bool)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun shadow.VC@12 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun sx.R@7 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun shadow.VC@10 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@11 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun inline$AtomicVarStateGetRNoLock$0$e@1 () T@Epoch)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun Civl_linear_tid_available@1 () (Array Int Bool))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun inline$AtomicVCGetElem$1$e@1 () T@Epoch)
(declare-fun shadow.VC@7 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$1$r@0 () T@Shadowable)
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCSetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCSetElem$0$i@0 () Int)
(declare-fun inline$AtomicVCInit$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$1$i@0 () Int)
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicVCGetElem$0$r@0 () T@Shadowable)
(declare-fun inline$AtomicVCGetElem$0$i@0 () Int)
(declare-fun call1formal@Civl_1_old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun call2formal@Civl_1_old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun call3formal@Civl_1_old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun call4formal@Civl_1_old.sx.R@0 () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Read_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 138) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 26) (- 0 28)) (or Civl_pc@1 (or (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) (select (select shadow.VC@9 (ShadowableTid tid)) tid)) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) SHARED) (= (select (select shadow.VC@9 (ShadowableVar x@@0)) tid) (select (select shadow.VC@9 (ShadowableTid tid)) tid))) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (and (= (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0))))))) (= ok@0 true)) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@0 (select (select shadow.VC@9 (ShadowableTid tid)) tid)))) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) SHARED) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= ok@0 true)) (= shadow.VC@9 (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))))))))) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= shadow.VC@9 (store (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) 1) (+ tid 1)) (+ tid 1) (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) 1))))))) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@0 SHARED))) (= ok@0 true)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= ok@0 false)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)))))) (=> (or Civl_pc@1 (or (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) (select (select shadow.VC@9 (ShadowableTid tid)) tid)) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) SHARED) (= (select (select shadow.VC@9 (ShadowableVar x@@0)) tid) (select (select shadow.VC@9 (ShadowableTid tid)) tid))) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (and (= (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0))))))) (= ok@0 true)) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@0 (select (select shadow.VC@9 (ShadowableTid tid)) tid)))) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) SHARED) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= ok@0 true)) (= shadow.VC@9 (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))))))))) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= shadow.VC@9 (store (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) 1) (+ tid 1)) (+ tid 1) (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) 1))))))) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@0 SHARED))) (= ok@0 true)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= ok@0 false)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))))) (and (=> (= (ControlFlow 0 26) (- 0 27)) (=> Civl_pc@1 (and (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (= ok@0 Civl_old_ok@0)))) (=> (=> Civl_pc@1 (and (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (= ok@0 Civl_old_ok@0))) (=> (and (and (= Civl_pc@2  (=> (and (and (and (and (and (and (= shadow.VC@9 Civl_global_old_shadow.VC@0) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) Civl_pc@1)) (= Civl_ok@2  (or (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) (select (select shadow.VC@9 (ShadowableTid tid)) tid)) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) SHARED) (= (select (select shadow.VC@9 (ShadowableVar x@@0)) tid) (select (select shadow.VC@9 (ShadowableTid tid)) tid))) (= ok@0 true)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (and (= (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0))))) (<= (|clock#epoch| (select Civl_global_old_sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0))))))) (= ok@0 true)) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@0 (select (select shadow.VC@9 (ShadowableTid tid)) tid)))) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@4 x@@0) SHARED) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= ok@0 true)) (= shadow.VC@9 (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store (select Civl_global_old_shadow.VC@0 (ShadowableVar x@@0)) tid (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))))))))) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select Civl_global_old_sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select Civl_global_old_shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= shadow.VC@9 (store (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store Civl_global_old_shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) (select Civl_global_old_sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) 1) (+ tid 1)) (+ tid 1) (+ (|tid#epoch| (select Civl_global_old_sx.R@0 x@@0)) 1))))))) (= sx.R@4 (store Civl_global_old_sx.R@0 x@@0 SHARED))) (= ok@0 true)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@2 x@@0)) (|tid#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))) (<= (|clock#epoch| (select sx.W@2 x@@0)) (|clock#epoch| (select (select shadow.VC@9 (ShadowableTid tid)) (|tid#epoch| (select sx.W@2 x@@0))))))) (= ok@0 false)) (= shadow.VC@9 Civl_global_old_shadow.VC@0)) (= shadow.Lock@7 Civl_global_old_shadow.Lock@0)) (= sx.W@2 Civl_global_old_sx.W@0)) (= sx.R@4 Civl_global_old_sx.R@0)) (= thread.State@2 Civl_global_old_thread.State@0)) (= thread.ForkedBy@2 Civl_global_old_thread.ForkedBy@0)) (= thread.HasJoined@2 Civl_global_old_thread.HasJoined@0))) (and (= ok@0 Civl_old_ok@0) Civl_ok@1)))) (= (ControlFlow 0 26) (- 0 25))) Civl_ok@2)))))))
(let ((anon13_Then_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (= shadow.Lock@7 shadow.Lock@0) (= sx.R@4 sx.R@0)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@0)) (and (= thread.State@2 thread.State@0) (= thread.ForkedBy@2 thread.ForkedBy@0))) (and (and (= thread.HasJoined@2 thread.HasJoined@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_global_old_thread.State@0 thread.State@0)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@0) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@0))) (and (and (= Civl_pc@1 false) (= Civl_ok@1 false)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 126) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon14_Then_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (= shadow.Lock@7 shadow.Lock@0) (= sx.R@4 sx.R@0)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@0)) (and (= thread.State@2 thread.State@0) (= thread.ForkedBy@2 thread.ForkedBy@0))) (and (and (= thread.HasJoined@2 thread.HasJoined@0) (= Civl_global_old_shadow.VC@0 shadow.VC@0)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@0) (= Civl_global_old_sx.W@0 sx.W@0)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@0) (= Civl_global_old_thread.State@0 thread.State@0)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@0) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@0))) (and (and (= Civl_pc@1 false) (= Civl_ok@1 false)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 114) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon15_Then$1_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (= shadow.Lock@7 shadow.Lock@6) (= sx.R@4 sx.R@1)) (=> (and (and (and (and (= ok@0 false) (= sx.W@2 sx.W@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 91) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon17_Then$2_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (= shadow.Lock@7 shadow.Lock@5) (= sx.R@4 sx.R@3)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 69) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon17_Else$5_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@8) (=> (and (= shadow.Lock@7 shadow.Lock@4) (= sx.R@4 sx.R@2)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 39) 26))))) Civl_ReturnChecker_correct)))))
(let ((anon16_Else$2_@2_Civl_ReturnChecker_correct  (=> (= shadow.VC@9 shadow.VC@3) (=> (and (= shadow.Lock@7 shadow.Lock@3) (= sx.R@4 sx.R@1)) (=> (and (and (and (and (= ok@0 true) (= sx.W@2 sx.W@1)) (and (= thread.State@2 thread.State@1) (= thread.ForkedBy@2 thread.ForkedBy@1))) (and (and (= thread.HasJoined@2 thread.HasJoined@1) (= Civl_global_old_shadow.VC@0 shadow.VC@1)) (and (= Civl_global_old_shadow.Lock@0 shadow.Lock@1) (= Civl_global_old_sx.W@0 sx.W@1)))) (and (and (and (= Civl_global_old_sx.R@0 sx.R@1) (= Civl_global_old_thread.State@0 thread.State@1)) (and (= Civl_global_old_thread.ForkedBy@0 thread.ForkedBy@1) (= Civl_global_old_thread.HasJoined@0 thread.HasJoined@1))) (and (and (= Civl_pc@1 Civl_pc@0) (= Civl_ok@1 Civl_ok@0)) (and (= Civl_old_ok@0 ok) (= (ControlFlow 0 29) 26))))) Civl_ReturnChecker_correct)))))
(let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (and (forall ((s T@Shadowable) ) (! (VCRepOk (select shadow.VC@12 s))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@5 sx.R@7))) (=> (and (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select shadow.VC@12 s@@0))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@5 sx.R@7)) (and (=> (= (ControlFlow 0 20) (- 0 21)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 20) (- 0 19)) (and (and (and (and (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock@10 v@@1) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@1 T@Var) ) (!  (=> (= (select sx.R x@@1) SHARED) (= (select sx.R@7 x@@1) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@1 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@1) tid) (= (select shadow.VC@12 s@@1) (select shadow.VC@@0 s@@1)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@2)) tid) (= (select sx.R@7 x@@2) (select sx.R x@@2)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@3 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@3)) tid) (= (select sx.W@5 x@@3) (select sx.W x@@3)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))))))))))
(let ((Civl_UnifiedReturn_correct  (=> (= sx.R@7 sx.R@5) (=> (and (and (= sx.W@5 sx.W@3) (= shadow.Lock@10 shadow.Lock@8)) (and (= shadow.VC@12 shadow.VC@10) (= (ControlFlow 0 23) 20))) GeneratedUnifiedExit_correct))))
(let ((anon13_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.R@5 sx.R@0)) (and (= sx.W@3 sx.W@0) (= (ControlFlow 0 127) 23))) Civl_UnifiedReturn_correct))))
(let ((anon14_Then_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@0) (=> (and (and (= shadow.Lock@8 shadow.Lock@0) (= sx.R@5 sx.R@0)) (and (= sx.W@3 sx.W@0) (= (ControlFlow 0 115) 23))) Civl_UnifiedReturn_correct))))
(let ((anon15_Then$1_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@1) (=> (and (and (= shadow.Lock@8 shadow.Lock@6) (= sx.R@5 sx.R@1)) (and (= sx.W@3 sx.W@1) (= (ControlFlow 0 92) 23))) Civl_UnifiedReturn_correct))))
(let ((anon17_Then$2_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@1) (=> (and (and (= shadow.Lock@8 shadow.Lock@5) (= sx.R@5 sx.R@3)) (and (= sx.W@3 sx.W@1) (= (ControlFlow 0 70) 23))) Civl_UnifiedReturn_correct))))
(let ((anon17_Else$5_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@8) (=> (and (and (= shadow.Lock@8 shadow.Lock@4) (= sx.R@5 sx.R@2)) (and (= sx.W@3 sx.W@1) (= (ControlFlow 0 40) 23))) Civl_UnifiedReturn_correct))))
(let ((anon16_Else$2_@2_Civl_UnifiedReturn_correct  (=> (= shadow.VC@10 shadow.VC@3) (=> (and (and (= shadow.Lock@8 shadow.Lock@3) (= sx.R@5 sx.R@1)) (and (= sx.W@3 sx.W@1) (= (ControlFlow 0 24) 23))) Civl_UnifiedReturn_correct))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (and (forall ((s@@2 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@1 s@@2))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@1 Civl_global_old_sx.R@1)) (= (ControlFlow 0 16) (- 0 15))) (and (forall ((s@@3 T@Shadowable) ) (! (VCRepOk (select shadow.VC@11 s@@3))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@4 sx.R@6)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@1 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 13) (- 0 14)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (=> (= (ControlFlow 0 13) (- 0 12)) (= (select shadow.Lock@9 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select Civl_global_old_shadow.VC@1 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 9) (- 0 11)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (=> (= (ControlFlow 0 9) (- 0 10)) (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@9 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@9 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 9) (- 0 8)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@11 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@2 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@1 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@4) SHARED) (= (select Civl_global_old_sx.R@1 x@@4) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.VC@1 s@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_sx.R@1 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@5)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@6 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@6)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_sx.W@1 x@@6) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@6)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 5) (- 0 6)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (= (ControlFlow 0 5) (- 0 4)) (and (and (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@9 v@@6) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@7 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@7) SHARED) (= (select sx.R@6 x@@7) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@11 s@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@8)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@6 x@@8) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@8)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@9 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@9)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@4 x@@9) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@9)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((anon13_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@4 sx.W@0)) (and (= sx.R@6 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 128) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 128) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 128) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 128) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 128) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon13_Then_correct  (=> (= inline$AtomicVarStateGetRNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 129) 126) anon13_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 129) 127) anon13_Then_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 129) 128) anon13_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon14_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@4 sx.W@0)) (and (= sx.R@6 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 116) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 116) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 116) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 116) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 116) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon14_Then_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 inline$AtomicThreadStateGetE$0$e@1) (and (and (=> (= (ControlFlow 0 117) 114) anon14_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 117) 115) anon14_Then_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 117) 116) anon14_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon15_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@6) (= sx.W@4 sx.W@1)) (and (= sx.R@6 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 93) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 93) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 93) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 93) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 93) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$3$anon0_correct  (=> (= shadow.Lock@6 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 94) 91) anon15_Then$1_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 94) 92) anon15_Then$1_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 94) 93) anon15_Then$1_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon15_Then_correct  (=> (not (and (= (|tid#epoch| inline$AtomicVarStateGetW$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$0$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetW$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$0$e@1)))) (and (=> (= (ControlFlow 0 95) (- 0 97)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 95) (- 0 96)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 95) 94) inline$AtomicReleaseVarLock$3$anon0_correct))))))))
(let ((anon17_Then$2_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@1) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@5) (= sx.W@4 sx.W@1)) (and (= sx.R@6 sx.R@3) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 71) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 71) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 71) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 71) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 71) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$2$anon0_correct  (=> (= shadow.Lock@5 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 72) 69) anon17_Then$2_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 72) 70) anon17_Then$2_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 72) 71) anon17_Then$2_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon17_Then$1_correct  (and (=> (= (ControlFlow 0 73) (- 0 75)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 73) (- 0 74)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 73) 72) inline$AtomicReleaseVarLock$2$anon0_correct)))))))
(let ((inline$AtomicVarStateSetR$1$anon0_correct  (=> (and (= sx.R@3 (store sx.R@1 x@@0 inline$AtomicThreadStateGetE$0$e@1)) (= (ControlFlow 0 76) 73)) anon17_Then$1_correct)))
(let ((anon17_Then_correct  (=> (and (= (|tid#epoch| inline$AtomicVarStateGetR$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$1$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetR$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$1$e@1))) (and (=> (= (ControlFlow 0 77) (- 0 81)) (>= (|tid#epoch| inline$AtomicThreadStateGetE$0$e@1) 0)) (=> (>= (|tid#epoch| inline$AtomicThreadStateGetE$0$e@1) 0) (and (=> (= (ControlFlow 0 77) (- 0 80)) (not (= (select sx.R@1 x@@0) SHARED))) (=> (not (= (select sx.R@1 x@@0) SHARED)) (and (=> (= (ControlFlow 0 77) (- 0 79)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 77) (- 0 78)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 77) 76) inline$AtomicVarStateSetR$1$anon0_correct))))))))))))
(let ((anon17_Else$5_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@8) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@4) (= sx.W@4 sx.W@1)) (and (= sx.R@6 sx.R@2) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 41) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 41) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 41) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 41) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 41) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$1$anon0_correct  (=> (= shadow.Lock@4 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 42) 39) anon17_Else$5_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 42) 40) anon17_Else$5_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 42) 41) anon17_Else$5_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon17_Else$4_correct  (and (=> (= (ControlFlow 0 43) (- 0 45)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 43) (- 0 44)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 43) 42) inline$AtomicReleaseVarLock$1$anon0_correct)))))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@2 (store sx.R@1 x@@0 SHARED)) (= (ControlFlow 0 46) 43)) anon17_Else$4_correct)))
(let ((anon17_Else$3_correct  (and (=> (= (ControlFlow 0 47) (- 0 50)) (not (= (select sx.R@1 x@@0) SHARED))) (=> (not (= (select sx.R@1 x@@0) SHARED)) (and (=> (= (ControlFlow 0 47) (- 0 49)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 47) (- 0 48)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 47) 46) inline$AtomicVarStateSetR$0$anon0_correct)))))))))
(let ((inline$AtomicVCSetElem$1$anon0_correct  (=> (= shadow.VC@7 (store shadow.VC@6 inline$AtomicVCSetElem$1$r@0 (store (select shadow.VC@6 inline$AtomicVCSetElem$1$r@0) tid inline$AtomicThreadStateGetE$0$e@1))) (=> (and (= shadow.VC@8 (store shadow.VC@7 inline$AtomicVCSetElem$1$r@0 (store (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@7 inline$AtomicVCSetElem$1$r@0) (- 0 1)))))))) (= (ControlFlow 0 51) 47)) anon17_Else$3_correct))))
(let ((inline$AtomicVCSetElem$1$Entry_correct  (=> (and (= inline$AtomicVCSetElem$1$r@0 (ShadowableVar x@@0)) (= (ControlFlow 0 52) 51)) inline$AtomicVCSetElem$1$anon0_correct)))
(let ((anon17_Else$2_correct  (and (=> (= (ControlFlow 0 53) (- 0 56)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 53) (- 0 55)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 53) (- 0 54)) (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED)))) (=> (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED))) (=> (= (ControlFlow 0 53) 52) inline$AtomicVCSetElem$1$Entry_correct)))))))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@5 (store shadow.VC@4 inline$AtomicVCSetElem$0$r@0 (store (select shadow.VC@4 inline$AtomicVCSetElem$0$r@0) inline$AtomicVCSetElem$0$i@0 inline$AtomicVarStateGetR$0$e@1))) (=> (and (= shadow.VC@6 (store shadow.VC@5 inline$AtomicVCSetElem$0$r@0 (store (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0) (- 0 1))) (+ inline$AtomicVCSetElem$0$i@0 1)) (+ inline$AtomicVCSetElem$0$i@0 1) (|clock#epoch| (select (select shadow.VC@5 inline$AtomicVCSetElem$0$r@0) (- 0 1)))))))) (= (ControlFlow 0 57) 53)) anon17_Else$2_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (= inline$AtomicVCSetElem$0$r@0 (ShadowableVar x@@0)) (=> (and (= inline$AtomicVCSetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 58) 57)) inline$AtomicVCSetElem$0$anon0_correct))))
(let ((anon17_Else$1_correct  (and (=> (= (ControlFlow 0 59) (- 0 62)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 59) (- 0 61)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 59) (- 0 60)) (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED)))) (=> (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED))) (=> (= (ControlFlow 0 59) 58) inline$AtomicVCSetElem$0$Entry_correct)))))))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@4 (store shadow.VC@1 inline$AtomicVCInit$0$r@0 (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 63) 59)) anon17_Else$1_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (= inline$AtomicVCInit$0$r@0 (ShadowableVar x@@0)) (= (ControlFlow 0 64) 63)) inline$AtomicVCInit$0$anon0_correct)))
(let ((anon17_Else_correct  (=> (not (and (= (|tid#epoch| inline$AtomicVarStateGetR$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$1$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetR$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$1$e@1)))) (and (=> (= (ControlFlow 0 65) (- 0 68)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 65) (- 0 67)) (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED)))) (=> (=> (is-ShadowableVar (ShadowableVar x@@0)) (not (= (select sx.R@1 (|x#ShadowableVar| (ShadowableVar x@@0))) SHARED))) (and (=> (= (ControlFlow 0 65) (- 0 66)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 65) 64) inline$AtomicVCInit$0$Entry_correct))))))))))
(let ((inline$AtomicVCGetElem$1$anon0_correct  (=> (= inline$AtomicVCGetElem$1$e@1 (select (select shadow.VC@1 inline$AtomicVCGetElem$1$r@0) inline$AtomicVCGetElem$1$i@0)) (and (=> (= (ControlFlow 0 82) 77) anon17_Then_correct) (=> (= (ControlFlow 0 82) 65) anon17_Else_correct)))))
(let ((inline$AtomicVCGetElem$1$Entry_correct  (=> (= inline$AtomicVCGetElem$1$r@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVCGetElem$1$i@0 (|tid#epoch| inline$AtomicVarStateGetR$0$e@1)) (= (ControlFlow 0 83) 82)) inline$AtomicVCGetElem$1$anon0_correct))))
(let ((anon16_Then_correct  (=> (not (= inline$AtomicVarStateGetR$0$e@1 SHARED)) (and (=> (= (ControlFlow 0 84) (- 0 86)) (= (select shadow.Lock@2 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@2 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 84) (- 0 85)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 84) 83) inline$AtomicVCGetElem$1$Entry_correct))))))))
(let ((anon16_Else$2_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@3) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@3) (= sx.W@4 sx.W@1)) (and (= sx.R@6 sx.R@1) (= Civl_global_old_shadow.VC@1 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_sx.W@1 sx.W@1)) (and (= Civl_global_old_sx.R@1 sx.R@1) (= Civl_linear_tid_available@2 Civl_linear_tid_available@1)))) (and (and (and (and (=> (= (ControlFlow 0 18) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 18) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (= shadow.Lock@3 (store shadow.Lock@2 (ShadowableVar x@@0) nil)) (and (and (=> (= (ControlFlow 0 30) 29) anon16_Else$2_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 30) 24) anon16_Else$2_@2_Civl_UnifiedReturn_correct)) (=> (= (ControlFlow 0 30) 18) anon16_Else$2_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon16_Else$1_correct  (and (=> (= (ControlFlow 0 31) (- 0 33)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 31) (- 0 32)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 31) 30) inline$AtomicReleaseVarLock$0$anon0_correct)))))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@2 (store shadow.VC@1 (ShadowableVar x@@0) (store (select shadow.VC@1 (ShadowableVar x@@0)) tid inline$AtomicThreadStateGetE$0$e@1))) (=> (and (= shadow.VC@3 (store shadow.VC@2 (ShadowableVar x@@0) (store (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@2 (ShadowableVar x@@0)) (- 0 1)))))))) (= (ControlFlow 0 34) 31)) anon16_Else$1_correct))))
(let ((anon16_Else_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 SHARED) (and (=> (= (ControlFlow 0 35) (- 0 38)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 35) (- 0 37)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 35) (- 0 36)) (= (select sx.R@1 x@@0) SHARED)) (=> (= (select sx.R@1 x@@0) SHARED) (=> (= (ControlFlow 0 35) 34) inline$AtomicVCSetElemShared$0$anon0_correct))))))))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (= inline$AtomicVarStateGetR$0$e@1 (select sx.R@1 x@@0)) (and (=> (= (ControlFlow 0 87) 84) anon16_Then_correct) (=> (= (ControlFlow 0 87) 35) anon16_Else_correct)))))
(let ((anon15_Else_correct  (=> (and (= (|tid#epoch| inline$AtomicVarStateGetW$0$e@1) (|tid#epoch| inline$AtomicVCGetElem$0$e@1)) (<= (|clock#epoch| inline$AtomicVarStateGetW$0$e@1) (|clock#epoch| inline$AtomicVCGetElem$0$e@1))) (and (=> (= (ControlFlow 0 88) (- 0 90)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 88) (- 0 89)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 88) 87) inline$AtomicVarStateGetR$0$anon0_correct))))))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@1 inline$AtomicVCGetElem$0$r@0) inline$AtomicVCGetElem$0$i@0)) (and (=> (= (ControlFlow 0 98) 95) anon15_Then_correct) (=> (= (ControlFlow 0 98) 88) anon15_Else_correct)))))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= inline$AtomicVCGetElem$0$r@0 (ShadowableTid tid)) (=> (and (= inline$AtomicVCGetElem$0$i@0 (|tid#epoch| inline$AtomicVarStateGetW$0$e@1)) (= (ControlFlow 0 99) 98)) inline$AtomicVCGetElem$0$anon0_correct))))
(let ((anon5_0$2_correct  (and (=> (= (ControlFlow 0 100) (- 0 102)) (= (select shadow.Lock@2 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@2 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 100) (- 0 101)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 100) 99) inline$AtomicVCGetElem$0$Entry_correct)))))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W@1 x@@0)) (= (ControlFlow 0 103) 100)) anon5_0$2_correct)))
(let ((anon5_0$1_correct  (and (=> (= (ControlFlow 0 104) (- 0 106)) (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid)) (=> (= (select shadow.Lock@2 (ShadowableVar x@@0)) tid) (and (=> (= (ControlFlow 0 104) (- 0 105)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 104) 103) inline$AtomicVarStateGetW$0$anon0_correct)))))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableVar x@@0)) nil) (=> (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableVar x@@0) tid)) (= (ControlFlow 0 107) 104)) anon5_0$1_correct))))
(let ((anon5_0_correct  (=> (and (= Civl_pc@0  (=> (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) false)) (= Civl_ok@0  (or (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (= (select (select shadow.VC@0 (ShadowableVar x@@0)) tid) (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))))) (= ok true)) (= sx.R@0 (store sx.R@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok true)) (= shadow.VC@0 (store (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))))))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= shadow.VC@0 (store (store (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (+ (|tid#epoch| (select sx.R@0 x@@0)) 1) (+ tid 1)) (+ tid 1) (+ (|tid#epoch| (select sx.R@0 x@@0)) 1))))))) (= sx.R@0 (store sx.R@0 x@@0 SHARED))) (= ok true)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (= ok ok) false)))) (=> (and (and (= call1formal@Civl_1_old.shadow.Lock@0 shadow.Lock) (= call2formal@Civl_1_old.shadow.VC@0 shadow.VC@@0)) (and (= call3formal@Civl_1_old.sx.W@0 sx.W) (= call4formal@Civl_1_old.sx.R@0 sx.R))) (and (=> (= (ControlFlow 0 108) (- 0 112)) (and (forall ((s@@6 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@6))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (=> (= (ControlFlow 0 108) (- 0 111)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 108) (- 0 110)) (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@7) tid) (= (select shadow.Lock@0 v@@7) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@10 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@10) SHARED) (= (select sx.R@0 x@@10) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@8 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@8) tid) (= (select shadow.VC@0 s@@8) (select call2formal@Civl_1_old.shadow.VC@0 s@@8)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@11)) tid) (= (select sx.R@0 x@@11) (select call4formal@Civl_1_old.sx.R@0 x@@11)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@12 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@12)) tid) (= (select sx.W@0 x@@12) (select call3formal@Civl_1_old.sx.W@0 x@@12)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@8) tid) (= (select shadow.Lock@0 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@13 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@13) SHARED) (= (select sx.R@0 x@@13) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@9 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@9) tid) (= (select shadow.VC@0 s@@9) (select call2formal@Civl_1_old.shadow.VC@0 s@@9)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@14)) tid) (= (select sx.R@0 x@@14) (select call4formal@Civl_1_old.sx.R@0 x@@14)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@15 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@15)) tid) (= (select sx.W@0 x@@15) (select call3formal@Civl_1_old.sx.W@0 x@@15)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@10 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@10))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 v@@9) tid) (= (select shadow.Lock@1 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@16 T@Var) ) (!  (=> (= (select call4formal@Civl_1_old.sx.R@0 x@@16) SHARED) (= (select sx.R@1 x@@16) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 s@@11) tid) (= (select shadow.VC@1 s@@11) (select call2formal@Civl_1_old.shadow.VC@0 s@@11)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@17)) tid) (= (select sx.R@1 x@@17) (select call4formal@Civl_1_old.sx.R@0 x@@17)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@18 T@Var) ) (!  (=> (= (select call1formal@Civl_1_old.shadow.Lock@0 (ShadowableVar x@@18)) tid) (= (select sx.W@1 x@@18) (select call3formal@Civl_1_old.sx.W@0 x@@18)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (or Civl_pc@0 (and (and (and (not (= tid nil)) (>= tid 0)) (>= tid 0)) (and (not (= tid nil)) (>= tid 0)))) (= Civl_linear_tid_available@1 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 108) (- 0 109)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 108) 107) inline$AtomicAcquireVarLock$0$anon0_correct)))))))))))))))
(let ((anon5_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@11 shadow.VC@0) (=> (and (and (and (= shadow.Lock@9 shadow.Lock@0) (= sx.W@4 sx.W@0)) (and (= sx.R@6 sx.R@0) (= Civl_global_old_shadow.VC@1 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@0) (= Civl_global_old_sx.W@1 sx.W@0)) (and (= Civl_global_old_sx.R@1 sx.R@0) (= Civl_linear_tid_available@2 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 17) 5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 17) 7) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 9) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 17) 13) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 17) 16) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (= (select (select shadow.VC@0 (ShadowableVar x@@0)) tid) (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))))) (= ok true)) (= sx.R@0 (store sx.R@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok true)) (= shadow.VC@0 (store (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))))))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= shadow.VC@0 (store (store (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (+ (|tid#epoch| (select sx.R@0 x@@0)) 1) (+ tid 1)) (+ tid 1) (+ (|tid#epoch| (select sx.R@0 x@@0)) 1))))))) (= sx.R@0 (store sx.R@0 x@@0 SHARED))) (= ok true)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)))))) (=> (or false (or (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (or (or (or (or (or (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (= (select (select shadow.VC@0 (ShadowableVar x@@0)) tid) (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (= ok true)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (and (= (|tid#epoch| (select sx.R@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))) (<= (|clock#epoch| (select sx.R@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.R@0 x@@0))))))) (= ok true)) (= sx.R@0 (store sx.R@0 x@@0 (select (select shadow.VC@0 (ShadowableTid tid)) tid)))) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (= (select sx.R@0 x@@0) SHARED) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok true)) (= shadow.VC@0 (store (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) tid (select (select shadow.VC@0 (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1))))))))) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (and (not (= (select sx.R@0 x@@0) SHARED)) (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= shadow.VC@0 (store (store (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0) (store (select (store (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0) (store (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableVar x@@0)) tid (select (select (store (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0) (store (select (store shadow.VC@0 (ShadowableVar x@@0) (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))) (ShadowableVar x@@0)) (|tid#epoch| (select sx.R@0 x@@0)) (select sx.R@0 x@@0))) (ShadowableTid tid)) tid))) (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (+ (|tid#epoch| (select sx.R@0 x@@0)) 1) (+ tid 1)) (+ tid 1) (+ (|tid#epoch| (select sx.R@0 x@@0)) 1))))))) (= sx.R@0 (store sx.R@0 x@@0 SHARED))) (= ok true)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))) (and (and (and (and (and (and (and (and (not (and (= (|tid#epoch| (select sx.W@0 x@@0)) (|tid#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))) (<= (|clock#epoch| (select sx.W@0 x@@0)) (|clock#epoch| (select (select shadow.VC@0 (ShadowableTid tid)) (|tid#epoch| (select sx.W@0 x@@0))))))) (= ok false)) (= shadow.VC@0 shadow.VC@0)) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0))))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> false (and (and (and (and (and (and (and (= shadow.VC@0 shadow.VC@0) (= shadow.Lock@0 shadow.Lock@0)) (= sx.W@0 sx.W@0)) (= sx.R@0 sx.R@0)) (= thread.State@0 thread.State@0)) (= thread.ForkedBy@0 thread.ForkedBy@0)) (= thread.HasJoined@0 thread.HasJoined@0)) (= ok ok))))))))
(let ((anon13_Else_correct  (=> (not (= inline$AtomicVarStateGetRNoLock$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 125) 108) anon5_0_correct) (=> (= (ControlFlow 0 125) 17) anon5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 125) 2) Civl_RefinementChecker_correct)))))
(let ((anon12_Then$1_correct  (=> (not (= inline$AtomicVarStateGetRNoLock$0$e@1 SHARED)) (and (=> (= (ControlFlow 0 130) 129) anon13_Then_correct) (=> (= (ControlFlow 0 130) 125) anon13_Else_correct)))))
(let ((inline$AtomicVarStateGetRNoLock$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetRNoLock$0$e@1 (select sx.R@0 x@@0)) (= (ControlFlow 0 131) 130)) anon12_Then$1_correct)))
(let ((anon12_Then_correct  (and (=> (= (ControlFlow 0 132) (- 0 133)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 132) 131) inline$AtomicVarStateGetRNoLock$0$anon0_correct)))))
(let ((anon14_Else_correct  (=> (not (= inline$AtomicVCGetElemShared$0$e@1 inline$AtomicThreadStateGetE$0$e@1)) (and (and (=> (= (ControlFlow 0 113) 108) anon5_0_correct) (=> (= (ControlFlow 0 113) 17) anon5_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 113) 2) Civl_RefinementChecker_correct)))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@0 (ShadowableVar x@@0)) tid)) (and (=> (= (ControlFlow 0 118) 117) anon14_Then_correct) (=> (= (ControlFlow 0 118) 113) anon14_Else_correct)))))
(let ((anon12_Else$1_correct  (=> (= SHARED SHARED) (and (=> (= (ControlFlow 0 119) (- 0 121)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 119) (- 0 120)) (= (select sx.R@0 x@@0) SHARED)) (=> (= (select sx.R@0 x@@0) SHARED) (=> (= (ControlFlow 0 119) 118) inline$AtomicVCGetElemShared$0$anon0_correct))))))))
(let ((inline$AtomicVarStateGetRShared$0$anon0_correct  (=> (and (= (select sx.R@0 x@@0) SHARED) (= (ControlFlow 0 122) 119)) anon12_Else$1_correct)))
(let ((anon12_Else_correct  (and (=> (= (ControlFlow 0 123) (- 0 124)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 123) 122) inline$AtomicVarStateGetRShared$0$anon0_correct)))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@0 (ShadowableTid tid)) tid)) (and (=> (= (ControlFlow 0 134) 132) anon12_Then_correct) (=> (= (ControlFlow 0 134) 123) anon12_Else_correct)))))
(let ((anon0_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (and (and (forall ((s@@12 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@12))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (and (not (= tid nil)) (>= tid 0)))) (=> (and (and (and (and (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@10) tid) (= (select shadow.Lock@0 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@19 T@Var) ) (!  (=> (= (select sx.R x@@19) SHARED) (= (select sx.R@0 x@@19) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@13) tid) (= (select shadow.VC@0 s@@13) (select shadow.VC@@0 s@@13)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@20 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@20)) tid) (= (select sx.R@0 x@@20) (select sx.R x@@20)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@21 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@21)) tid) (= (select sx.W@0 x@@21) (select sx.W x@@21)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (and (and (and (not (= tid nil)) (>= tid 0)) (>= tid 0)) (and (not (= tid nil)) (>= tid 0))) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 135) (- 0 137)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 135) (- 0 136)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 135) 134) inline$AtomicThreadStateGetE$0$anon0_correct)))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock (ShadowableTid tid)) tid)) (and (and (forall ((s@@14 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@14))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (and (not (= tid nil)) (>= tid 0)))) (=> (and (and (and (and (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock v@@11) tid) (= (select shadow.Lock v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@22 T@Var) ) (!  (=> (= (select sx.R x@@22) SHARED) (= (select sx.R x@@22) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock s@@15) tid) (= (select shadow.VC@@0 s@@15) (select shadow.VC@@0 s@@15)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@23 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@23)) tid) (= (select sx.R x@@23) (select sx.R x@@23)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@24 T@Var) ) (!  (=> (= (select shadow.Lock (ShadowableVar x@@24)) tid) (= (select sx.W x@@24) (select sx.W x@@24)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= (ControlFlow 0 138) 135)) anon0_correct))))
PreconditionGeneratedEntry_correct))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock@14 () (Array T@Shadowable Int))
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@8 () (Array T@Var T@Epoch))
(declare-fun sx.R@8 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_sx.W@2 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@9 () (Array T@Var T@Epoch))
(declare-fun sx.R@9 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@10 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@15 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0 () T@Shadowable)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 () (Array T@Var T@Epoch))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun ok@0 () Bool)
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_sx.W@1 () (Array T@Var T@Epoch))
(declare-fun Civl_global_old_sx.R@1 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@9 () (Array Int Bool))
(declare-fun shadow.Lock@11 () (Array T@Shadowable Int))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@5 () (Array T@Var T@Epoch))
(declare-fun sx.R@5 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@6 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@1 () T@Lock)
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun sx.W@4 () (Array T@Var T@Epoch))
(declare-fun sx.R@4 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@5 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToRelease$0$l@1 () T@Lock)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun sx.W@3 () (Array T@Var T@Epoch))
(declare-fun sx.R@3 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@4 () (Array Int Bool))
(declare-fun thread.State@5 () (Array Int Int))
(declare-fun thread.State@4 () (Array Int Int))
(declare-fun inline$AtomicAllocTid$0$uid@1 () Int)
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun thread.State@3 () (Array Int Int))
(declare-fun thread.ForkedBy@3 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun sx.W@2 () (Array T@Var T@Epoch))
(declare-fun sx.R@2 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@1 () Int)
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.VC@7 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@7 () (Array T@Var T@Epoch))
(declare-fun sx.R@7 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@13 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@8 () (Array Int Bool))
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@6 () (Array T@Var T@Epoch))
(declare-fun sx.R@6 () (Array T@Var T@Epoch))
(declare-fun shadow.Lock@12 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@7 () (Array Int Bool))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_Driver_20)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 92) (let ((Civl_ReturnChecker_correct true))
(let ((anon8_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 20) (- 0 22)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 20) (- 0 21)) (= (select shadow.Lock@14 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@14 (ShadowableTid tid)) tid) (=> (= (ControlFlow 0 20) (- 0 19)) (and (forall ((s T@Shadowable) ) (! (VCRepOk (select shadow.VC@8 s))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@8 sx.R@8)))))))))
(let ((Civl_UnchangedChecker_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct  (=> (and (and (forall ((s@@0 T@Shadowable) ) (! (VCRepOk (select Civl_global_old_shadow.VC@2 s@@0))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk Civl_global_old_sx.W@2 Civl_global_old_sx.R@2)) (= (ControlFlow 0 14) (- 0 13))) (and (forall ((s@@1 T@Shadowable) ) (! (VCRepOk (select shadow.VC@9 s@@1))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@9 sx.R@9)))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |331|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0)) (and (=> (= (ControlFlow 0 11) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0 0)) (=> (= (ControlFlow 0 11) (- 0 10)) (= (select shadow.Lock@15 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |332|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@1) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@2 v@@1) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s) (select Civl_global_old_shadow.VC@2 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s)))
 :qid |unknown.0:0|
 :skolemid |27|
)))) (and (=> (= (ControlFlow 0 7) (- 0 9)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0 0)) (and (=> (= (ControlFlow 0 7) (- 0 8)) (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@15 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0) (= (select shadow.Lock@15 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 7) (- 0 6)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 T@Shadowable) ) (!  (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v1@0)) (not (= inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$v2@0))) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.Lock@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$tid@0)) (= (select inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$old.shadow.VC@0 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0) (select shadow.VC@9 inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$s@@0)))
 :qid |unknown.0:0|
 :skolemid |27|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@10 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |333|
)) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (and (and (and (and (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.Lock@2 v@@4) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@0 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@0) SHARED) (= (select Civl_global_old_sx.R@2 x@@0) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@2) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_shadow.VC@2 s@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@2)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@1 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@1)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_sx.R@2 x@@1) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@1)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@2 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@2)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select Civl_global_old_sx.W@2 x@@2) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@2)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 3) (- 0 4)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0 0)) (=> (= (ControlFlow 0 3) (- 0 2)) (and (and (and (and (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.Lock@15 v@@5) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@3 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@3) SHARED) (= (select sx.R@9 x@@3) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 s@@3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select shadow.VC@9 s@@3) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.VC@0 s@@3)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@4 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@4)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.R@9 x@@4) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.R@0 x@@4)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@5 T@Var) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.shadow.Lock@0 (ShadowableVar x@@5)) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$tid@0) (= (select sx.W@9 x@@5) (select inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$old.sx.W@0 x@@5)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))))))))))
(let ((anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 84) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 84) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 84) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 84) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 84) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon9_LoopDone_correct  (=> (not ok@0) (and (=> (= (ControlFlow 0 85) 83) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 85) 84) anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon12_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@10) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 78) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 78) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 78) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 78) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 78) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 65) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 65) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 65) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 65) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 65) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon14_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@5) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 47) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 47) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 47) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 47) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 47) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon14_Else$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@2) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 38) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 38) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 38) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 38) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 38) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon8_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@8) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@14) (= sx.W@9 sx.W@8)) (and (= sx.R@9 sx.R@8) (= Civl_global_old_shadow.VC@2 Civl_global_old_shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 Civl_global_old_shadow.Lock@1) (= Civl_global_old_sx.W@2 Civl_global_old_sx.W@1)) (and (= Civl_global_old_sx.R@2 Civl_global_old_sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@9)))) (and (and (and (and (=> (= (ControlFlow 0 23) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 23) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 23) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 23) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon8_correct  (and (=> (= (ControlFlow 0 24) (- 0 25)) (= (select shadow.Lock@14 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@14 (ShadowableTid tid)) tid) (and (and (=> (= (ControlFlow 0 24) 20) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 24) 23) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 24) 17) Civl_UnchangedChecker_correct))))))
(let ((anon12_Then_0_correct  (and (=> (= (ControlFlow 0 74) (- 0 77)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 74) (- 0 76)) (and (and (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@6) tid) (= (select shadow.Lock@10 v@@6) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@6 T@Var) ) (!  (=> (= (select sx.R@1 x@@6) SHARED) (= (select sx.R@1 x@@6) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@4 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 s@@4) tid) (= (select shadow.VC@1 s@@4) (select shadow.VC@1 s@@4)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@7 T@Var) ) (!  (=> (= (select shadow.Lock@10 (ShadowableVar x@@7)) tid) (= (select sx.R@1 x@@7) (select sx.R@1 x@@7)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@8 T@Var) ) (!  (=> (= (select shadow.Lock@10 (ShadowableVar x@@8)) tid) (= (select sx.W@1 x@@8) (select sx.W@1 x@@8)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@7) tid) (= (select shadow.Lock@10 v@@7) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@9 T@Var) ) (!  (=> (= (select sx.R@1 x@@9) SHARED) (= (select sx.R@1 x@@9) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@5 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 s@@5) tid) (= (select shadow.VC@1 s@@5) (select shadow.VC@1 s@@5)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@10 T@Var) ) (!  (=> (= (select shadow.Lock@10 (ShadowableVar x@@10)) tid) (= (select sx.R@1 x@@10) (select sx.R@1 x@@10)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@11 T@Var) ) (!  (=> (= (select shadow.Lock@10 (ShadowableVar x@@11)) tid) (= (select sx.W@1 x@@11) (select sx.W@1 x@@11)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 74) (- 0 75)) (and (forall ((s@@6 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@6))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@7 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@7))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@8) tid) (= (select shadow.Lock@11 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@8 T@Shadowable) ) (!  (=> (and (and (not (= s@@8 (ShadowableTid tid))) (not (= s@@8 (ShadowableTid tid)))) (= (select shadow.Lock@10 s@@8) tid)) (= (select shadow.VC@1 s@@8) (select shadow.VC@5 s@@8)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
)))) (=> (and (and (and (and (forall ((s@@9 T@Shadowable) ) (! (VCRepOk (select shadow.VC@5 s@@9))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@5 sx.R@5)) (= Civl_linear_tid_available@6 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))) (and (= shadow.VC@8 shadow.VC@5) (= shadow.Lock@14 shadow.Lock@11))) (and (and (and (= sx.W@8 sx.W@5) (= sx.R@8 sx.R@5)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@5) (= Civl_global_old_shadow.Lock@1 shadow.Lock@11))) (and (and (= Civl_global_old_sx.W@1 sx.W@5) (= Civl_global_old_sx.R@1 sx.R@5)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@6) (= (ControlFlow 0 74) 24))))) anon8_correct))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (and (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) nil) (= shadow.Lock@10 (store shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1) tid))) (and (and (=> (= (ControlFlow 0 79) 74) anon12_Then_0_correct) (=> (= (ControlFlow 0 79) 78) anon12_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 79) 17) Civl_UnchangedChecker_correct)))))
(let ((anon12_Then_correct  (and (=> (= (ControlFlow 0 80) (- 0 81)) (= (select shadow.Lock@1 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@1 (ShadowableTid tid)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 80) 79)) inline$AtomicChooseLockToAcquire$0$anon0_correct)))))
(let ((anon13_Then_0$1_correct  (=> (and (= shadow.VC@8 shadow.VC@4) (= shadow.Lock@14 shadow.Lock@9)) (=> (and (and (and (= sx.W@8 sx.W@4) (= sx.R@8 sx.R@4)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@4) (= Civl_global_old_shadow.Lock@1 shadow.Lock@8))) (and (and (= Civl_global_old_sx.W@1 sx.W@4) (= Civl_global_old_sx.R@1 sx.R@4)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@5) (= (ControlFlow 0 66) 24)))) anon8_correct))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@9 (store shadow.Lock@8 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1) nil)) (= (ControlFlow 0 67) 66)) anon13_Then_0$1_correct)))
(let ((anon13_Then_0_correct  (and (=> (= (ControlFlow 0 68) (- 0 71)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 68) (- 0 70)) (and (and (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@9) tid) (= (select shadow.Lock@1 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@12 T@Var) ) (!  (=> (= (select sx.R@1 x@@12) SHARED) (= (select sx.R@1 x@@12) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@10) tid) (= (select shadow.VC@1 s@@10) (select shadow.VC@1 s@@10)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@13 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@13)) tid) (= (select sx.R@1 x@@13) (select sx.R@1 x@@13)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@14 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@14)) tid) (= (select sx.W@1 x@@14) (select sx.W@1 x@@14)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@10) tid) (= (select shadow.Lock@1 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@15 T@Var) ) (!  (=> (= (select sx.R@1 x@@15) SHARED) (= (select sx.R@1 x@@15) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@11) tid) (= (select shadow.VC@1 s@@11) (select shadow.VC@1 s@@11)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@16 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@16)) tid) (= (select sx.R@1 x@@16) (select sx.R@1 x@@16)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@17 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@17)) tid) (= (select sx.W@1 x@@17) (select sx.W@1 x@@17)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 68) (- 0 69)) (and (forall ((s@@12 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@12))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@13 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@13))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@11) tid) (= (select shadow.Lock@8 v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@14 T@Shadowable) ) (!  (=> (and (and (not (= s@@14 (ShadowableTid tid))) (not (= s@@14 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)))) (= (select shadow.Lock@1 s@@14) tid)) (= (select shadow.VC@1 s@@14) (select shadow.VC@4 s@@14)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
)))) (=> (and (and (and (forall ((s@@15 T@Shadowable) ) (! (VCRepOk (select shadow.VC@4 s@@15))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@4 sx.R@4)) (and (= Civl_linear_tid_available@5 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= (select shadow.Lock@8 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 68) 67))) inline$AtomicReleaseChosenLock$0$anon0_correct))))))))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid) (and (and (=> (= (ControlFlow 0 72) 68) anon13_Then_0_correct) (=> (= (ControlFlow 0 72) 65) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 72) 17) Civl_UnchangedChecker_correct)))))
(let ((anon13_Then_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 73) 72)) inline$AtomicChooseLockToRelease$0$anon0_correct)))
(let ((anon14_Then_0$1_correct  (=> (and (= shadow.VC@8 shadow.VC@3) (= shadow.Lock@14 shadow.Lock@7)) (=> (and (and (and (= sx.W@8 sx.W@3) (= sx.R@8 sx.R@3)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@3) (= Civl_global_old_shadow.Lock@1 shadow.Lock@6))) (and (and (= Civl_global_old_sx.W@1 sx.W@3) (= Civl_global_old_sx.R@1 sx.R@3)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@4) (= (ControlFlow 0 48) 24)))) anon8_correct))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@5 (store thread.State@4 inline$AtomicAllocTid$0$uid@1 2)) (=> (and (= shadow.Lock@7 (store shadow.Lock@6 (ShadowableTid inline$AtomicAllocTid$0$uid@1) inline$AtomicAllocTid$0$uid@1)) (= (ControlFlow 0 49) 48)) anon14_Then_0$1_correct))))
(let ((anon14_Then_0_correct  (and (=> (= (ControlFlow 0 50) (- 0 53)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 50) (- 0 52)) (and (and (and (and (forall ((v@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 v@@12) tid) (= (select shadow.Lock@5 v@@12) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@18 T@Var) ) (!  (=> (= (select sx.R@1 x@@18) SHARED) (= (select sx.R@1 x@@18) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@16 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 s@@16) tid) (= (select shadow.VC@1 s@@16) (select shadow.VC@1 s@@16)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@19 T@Var) ) (!  (=> (= (select shadow.Lock@5 (ShadowableVar x@@19)) tid) (= (select sx.R@1 x@@19) (select sx.R@1 x@@19)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@20 T@Var) ) (!  (=> (= (select shadow.Lock@5 (ShadowableVar x@@20)) tid) (= (select sx.W@1 x@@20) (select sx.W@1 x@@20)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 v@@13) tid) (= (select shadow.Lock@5 v@@13) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@21 T@Var) ) (!  (=> (= (select sx.R@1 x@@21) SHARED) (= (select sx.R@1 x@@21) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@17 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 s@@17) tid) (= (select shadow.VC@1 s@@17) (select shadow.VC@1 s@@17)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@22 T@Var) ) (!  (=> (= (select shadow.Lock@5 (ShadowableVar x@@22)) tid) (= (select sx.R@1 x@@22) (select sx.R@1 x@@22)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@23 T@Var) ) (!  (=> (= (select shadow.Lock@5 (ShadowableVar x@@23)) tid) (= (select sx.W@1 x@@23) (select sx.W@1 x@@23)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 50) (- 0 51)) (and (forall ((s@@18 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@18))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@19 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@19))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock@5 v@@14) tid) (= (select shadow.Lock@6 v@@14) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@20 T@Shadowable) ) (!  (=> (and (and (not (= s@@20 (ShadowableTid tid))) (not (= s@@20 (ShadowableTid inline$AtomicAllocTid$0$uid@1)))) (= (select shadow.Lock@5 s@@20) tid)) (= (select shadow.VC@1 s@@20) (select shadow.VC@3 s@@20)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
)))) (and (and (forall ((s@@21 T@Shadowable) ) (! (VCRepOk (select shadow.VC@3 s@@21))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@3 sx.R@3)) (and (= Civl_linear_tid_available@4 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))) (= (select thread.State@4 inline$AtomicAllocTid$0$uid@1) 1)))) (and (and (and (= (select shadow.Lock@6 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid) (not (= tid inline$AtomicAllocTid$0$uid@1))) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 50) 49)))) inline$AtomicStartThread$0$anon0_correct)))))))))
(let ((anon14_Then$1_correct  (and (=> (= (ControlFlow 0 54) (- 0 62)) (= (select shadow.Lock@5 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@5 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 54) (- 0 61)) (= (select shadow.Lock@5 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid)) (=> (= (select shadow.Lock@5 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid) (and (=> (= (ControlFlow 0 54) (- 0 60)) (forall ((s@@22 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@22))
 :qid |verifiedftbpl.976:37|
 :skolemid |38|
))) (=> (forall ((s@@23 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@23))
 :qid |verifiedftbpl.976:37|
 :skolemid |38|
)) (and (=> (= (ControlFlow 0 54) (- 0 59)) (not (= tid inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 54) (- 0 58)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 54) (- 0 57)) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (=> (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0)) (and (=> (= (ControlFlow 0 54) (- 0 56)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 54) (- 0 55)) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (=> (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0)) (and (and (=> (= (ControlFlow 0 54) 50) anon14_Then_0_correct) (=> (= (ControlFlow 0 54) 47) anon14_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 54) 17) Civl_UnchangedChecker_correct))))))))))))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= tid inline$AtomicAllocTid$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicAllocTid$0$uid@1) 0) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (= thread.State@3 (store thread.State@1 inline$AtomicAllocTid$0$uid@1 1))) (and (and (= thread.ForkedBy@3 (store thread.ForkedBy@1 inline$AtomicAllocTid$0$uid@1 tid)) (= shadow.Lock@5 (store shadow.Lock@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1) tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1))) (= (ControlFlow 0 63) 54)))) anon14_Then$1_correct))))
(let ((anon14_Then_correct  (=> (forall ((t Int) ) (!  (=> (= (select thread.State@1 t) 0) (= (select shadow.Lock@1 (ShadowableTid t)) nil))
 :qid |verifiedftbpl.1025:20|
 :skolemid |39|
)) (=> (and (and (= (select thread.State@1 tid) 2) (and (not (= tid nil)) (>= tid 0))) (= (ControlFlow 0 64) 63)) inline$AtomicAllocTid$0$anon0_correct))))
(let ((anon14_Else_0$1_correct  (=> (and (= shadow.VC@8 shadow.VC@2) (= shadow.Lock@14 shadow.Lock@4)) (=> (and (and (and (= sx.W@8 sx.W@2) (= sx.R@8 sx.R@2)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@2) (= Civl_global_old_shadow.Lock@1 shadow.Lock@3))) (and (and (= Civl_global_old_sx.W@1 sx.W@2) (= Civl_global_old_sx.R@1 sx.R@2)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@3) (= (ControlFlow 0 39) 24)))) anon8_correct))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@4 (store shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) nil)) (= (ControlFlow 0 40) 39)) anon14_Else_0$1_correct)))
(let ((anon14_Else_0_correct  (and (=> (= (ControlFlow 0 41) (- 0 44)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 41) (- 0 43)) (and (and (and (and (forall ((v@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@15) tid) (= (select shadow.Lock@2 v@@15) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@24 T@Var) ) (!  (=> (= (select sx.R@1 x@@24) SHARED) (= (select sx.R@1 x@@24) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@24 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 s@@24) tid) (= (select shadow.VC@1 s@@24) (select shadow.VC@1 s@@24)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@25 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@25)) tid) (= (select sx.R@1 x@@25) (select sx.R@1 x@@25)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@26 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@26)) tid) (= (select sx.W@1 x@@26) (select sx.W@1 x@@26)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@16 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@16) tid) (= (select shadow.Lock@2 v@@16) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@27 T@Var) ) (!  (=> (= (select sx.R@1 x@@27) SHARED) (= (select sx.R@1 x@@27) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@25 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 s@@25) tid) (= (select shadow.VC@1 s@@25) (select shadow.VC@1 s@@25)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@28 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@28)) tid) (= (select sx.R@1 x@@28) (select sx.R@1 x@@28)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@29 T@Var) ) (!  (=> (= (select shadow.Lock@2 (ShadowableVar x@@29)) tid) (= (select sx.W@1 x@@29) (select sx.W@1 x@@29)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (and (=> (= (ControlFlow 0 41) (- 0 42)) (and (forall ((s@@26 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@26))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@27 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@27))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (=> (and (and (and (and (not (= tid nil)) (>= tid 0)) (and (forall ((v@@17 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@17) tid) (= (select shadow.Lock@3 v@@17) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((s@@28 T@Shadowable) ) (!  (=> (and (and (not (= s@@28 (ShadowableTid tid))) (not (= s@@28 (ShadowableTid tid)))) (= (select shadow.Lock@2 s@@28) tid)) (= (select shadow.VC@1 s@@28) (select shadow.VC@2 s@@28)))
 :qid |verifiedftbpl.523:18|
 :skolemid |27|
)))) (and (and (forall ((s@@29 T@Shadowable) ) (! (VCRepOk (select shadow.VC@2 s@@29))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@2 sx.R@2)) (= Civl_linear_tid_available@3 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (and (= (select shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid) (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1))) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 41) 40)))) inline$AtomicReleaseJoinLock$0$anon0_correct)))))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicChooseThreadToJoin$0$uid@1) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0))) (= (select shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) nil)) (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) tid)) (= thread.HasJoined@2 (store thread.HasJoined@1 tid inline$AtomicChooseThreadToJoin$0$uid@1 true)))) (and (and (=> (= (ControlFlow 0 45) 41) anon14_Else_0_correct) (=> (= (ControlFlow 0 45) 38) anon14_Else$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 45) 17) Civl_UnchangedChecker_correct))))))
(let ((anon14_Else_correct  (=> (and (and (= (select thread.State@1 tid) 2) (and (not (= tid nil)) (>= tid 0))) (= (ControlFlow 0 46) 45)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
(let ((anon10_Then_0_correct  (and (=> (= (ControlFlow 0 32) (- 0 37)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 32) (- 0 36)) (= (select shadow.Lock@1 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@1 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 32) (- 0 35)) (and (forall ((s@@30 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@30))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@31 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@31))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (=> (= (ControlFlow 0 32) (- 0 34)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 32) (- 0 33)) (and (and (and (and (forall ((v@@18 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@18) tid) (= (select shadow.Lock@1 v@@18) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@30 T@Var) ) (!  (=> (= (select sx.R@1 x@@30) SHARED) (= (select sx.R@1 x@@30) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@32 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@32) tid) (= (select shadow.VC@1 s@@32) (select shadow.VC@1 s@@32)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@31 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@31)) tid) (= (select sx.R@1 x@@31) (select sx.R@1 x@@31)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@32 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@32)) tid) (= (select sx.W@1 x@@32) (select sx.W@1 x@@32)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@19 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@19) tid) (= (select shadow.Lock@1 v@@19) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@33 T@Var) ) (!  (=> (= (select sx.R@1 x@@33) SHARED) (= (select sx.R@1 x@@33) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@33 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@33) tid) (= (select shadow.VC@1 s@@33) (select shadow.VC@1 s@@33)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@34 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@34)) tid) (= (select sx.R@1 x@@34) (select sx.R@1 x@@34)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@35 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@35)) tid) (= (select sx.W@1 x@@35) (select sx.W@1 x@@35)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@34 T@Shadowable) ) (! (VCRepOk (select shadow.VC@7 s@@34))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@7 sx.R@7)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (and (and (forall ((v@@20 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@20) tid) (= (select shadow.Lock@13 v@@20) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@36 T@Var) ) (!  (=> (= (select sx.R@1 x@@36) SHARED) (= (select sx.R@7 x@@36) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@35 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@35) tid) (= (select shadow.VC@7 s@@35) (select shadow.VC@1 s@@35)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@37 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@37)) tid) (= (select sx.R@7 x@@37) (select sx.R@1 x@@37)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@38 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@38)) tid) (= (select sx.W@7 x@@38) (select sx.W@1 x@@38)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= Civl_linear_tid_available@8 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))) (and (= shadow.VC@8 shadow.VC@7) (= shadow.Lock@14 shadow.Lock@13))) (and (and (and (= sx.W@8 sx.W@7) (= sx.R@8 sx.R@7)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@7) (= Civl_global_old_shadow.Lock@1 shadow.Lock@13))) (and (and (= Civl_global_old_sx.W@1 sx.W@7) (= Civl_global_old_sx.R@1 sx.R@7)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@8) (= (ControlFlow 0 32) 24))))) anon8_correct))))))))))))))
(let ((anon11_Then_0_correct  (and (=> (= (ControlFlow 0 26) (- 0 31)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 26) (- 0 30)) (= (select shadow.Lock@1 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@1 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 26) (- 0 29)) (and (forall ((s@@36 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@36))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1))) (=> (and (forall ((s@@37 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@37))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (and (=> (= (ControlFlow 0 26) (- 0 28)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 26) (- 0 27)) (and (and (and (and (forall ((v@@21 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@21) tid) (= (select shadow.Lock@1 v@@21) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@39 T@Var) ) (!  (=> (= (select sx.R@1 x@@39) SHARED) (= (select sx.R@1 x@@39) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@38 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@38) tid) (= (select shadow.VC@1 s@@38) (select shadow.VC@1 s@@38)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@40 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@40)) tid) (= (select sx.R@1 x@@40) (select sx.R@1 x@@40)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@41 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@41)) tid) (= (select sx.W@1 x@@41) (select sx.W@1 x@@41)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
)))) (=> (and (and (and (and (forall ((v@@22 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@22) tid) (= (select shadow.Lock@1 v@@22) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@42 T@Var) ) (!  (=> (= (select sx.R@1 x@@42) SHARED) (= (select sx.R@1 x@@42) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@39 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@39) tid) (= (select shadow.VC@1 s@@39) (select shadow.VC@1 s@@39)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@43 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@43)) tid) (= (select sx.R@1 x@@43) (select sx.R@1 x@@43)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@44 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@44)) tid) (= (select sx.W@1 x@@44) (select sx.W@1 x@@44)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (=> (and (and (forall ((s@@40 T@Shadowable) ) (! (VCRepOk (select shadow.VC@6 s@@40))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@6 sx.R@6)) (and (not (= tid nil)) (>= tid 0))) (=> (and (and (and (and (and (and (and (forall ((v@@23 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@23) tid) (= (select shadow.Lock@12 v@@23) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((x@@45 T@Var) ) (!  (=> (= (select sx.R@1 x@@45) SHARED) (= (select sx.R@6 x@@45) SHARED))
 :qid |verifiedftbpl.177:11|
 :skolemid |10|
))) (forall ((s@@41 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 s@@41) tid) (= (select shadow.VC@6 s@@41) (select shadow.VC@1 s@@41)))
 :qid |verifiedftbpl.185:11|
 :skolemid |11|
))) (forall ((x@@46 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@46)) tid) (= (select sx.R@6 x@@46) (select sx.R@1 x@@46)))
 :qid |verifiedftbpl.186:11|
 :skolemid |12|
))) (forall ((x@@47 T@Var) ) (!  (=> (= (select shadow.Lock@1 (ShadowableVar x@@47)) tid) (= (select sx.W@6 x@@47) (select sx.W@1 x@@47)))
 :qid |verifiedftbpl.187:11|
 :skolemid |13|
))) (= Civl_linear_tid_available@7 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))) (and (= shadow.VC@8 shadow.VC@6) (= shadow.Lock@14 shadow.Lock@12))) (and (and (and (= sx.W@8 sx.W@6) (= sx.R@8 sx.R@6)) (and (= Civl_global_old_shadow.VC@1 shadow.VC@6) (= Civl_global_old_shadow.Lock@1 shadow.Lock@12))) (and (and (= Civl_global_old_sx.W@1 sx.W@6) (= Civl_global_old_sx.R@1 sx.R@6)) (and (= Civl_linear_tid_available@9 Civl_linear_tid_available@7) (= (ControlFlow 0 26) 24))))) anon8_correct))))))))))))))
(let ((anon10_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 18) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 18) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 18) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 18) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon11_Then_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@1) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@1) (= sx.W@9 sx.W@1)) (and (= sx.R@9 sx.R@1) (= Civl_global_old_shadow.VC@2 shadow.VC@1))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@1) (= Civl_global_old_sx.W@2 sx.W@1)) (and (= Civl_global_old_sx.R@2 sx.R@1) (= Civl_linear_tid_available@10 Civl_linear_tid_available@2)))) (and (and (and (and (=> (= (ControlFlow 0 16) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 16) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 16) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((anon9_LoopBody_correct  (=> ok@0 (and (and (and (and (and (and (and (and (=> (= (ControlFlow 0 82) 80) anon12_Then_correct) (=> (= (ControlFlow 0 82) 73) anon13_Then_correct)) (=> (= (ControlFlow 0 82) 64) anon14_Then_correct)) (=> (= (ControlFlow 0 82) 46) anon14_Else_correct)) (=> (= (ControlFlow 0 82) 26) anon11_Then_0_correct)) (=> (= (ControlFlow 0 82) 16) anon11_Then_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 82) 17) Civl_UnchangedChecker_correct)) (=> (= (ControlFlow 0 82) 32) anon10_Then_0_correct)) (=> (= (ControlFlow 0 82) 18) anon10_Then_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon9_LoopHead_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock@1 (ShadowableTid tid)) tid)) (and (and (forall ((s@@42 T@Shadowable) ) (! (VCRepOk (select shadow.VC@1 s@@42))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@1 sx.R@1)) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 86) 85) anon9_LoopDone_correct) (=> (= (ControlFlow 0 86) 82) anon9_LoopBody_correct)))))
(let ((anon0_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 87) (- 0 90)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 87) (- 0 89)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 87) (- 0 88)) (and (forall ((s@@43 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@43))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0))) (=> (and (forall ((s@@44 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@44))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (=> (= (ControlFlow 0 87) 86) anon9_LoopHead_correct)))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.VC@9 shadow.VC@0) (=> (and (and (and (= shadow.Lock@15 shadow.Lock@0) (= sx.W@9 sx.W@0)) (and (= sx.R@9 sx.R@0) (= Civl_global_old_shadow.VC@2 shadow.VC@0))) (and (and (= Civl_global_old_shadow.Lock@2 shadow.Lock@0) (= Civl_global_old_sx.W@2 sx.W@0)) (and (= Civl_global_old_sx.R@2 sx.R@0) (= Civl_linear_tid_available@10 Civl_linear_tid_available@0)))) (and (and (and (and (=> (= (ControlFlow 0 15) 3) inline$Civl_NoninterferenceChecker_yield_Yield_FTPreserved_20$0$L0_correct) (=> (= (ControlFlow 0 15) 5) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 15) 7) inline$Civl_NoninterferenceChecker_yield_Yield_VCPreserved_20$0$L0_correct)) (=> (= (ControlFlow 0 15) 11) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_20$0$L0_correct)) (=> (= (ControlFlow 0 15) 14) inline$Civl_NoninterferenceChecker_yield_Yield_FTRepOk_20$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct true))
(let ((anon0_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (and (and (forall ((s@@45 T@Shadowable) ) (! (VCRepOk (select shadow.VC@0 s@@45))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W@0 sx.R@0)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 91) 87) anon0_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 91) 15) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 91) 1) Civl_RefinementChecker_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock (ShadowableTid tid)) tid)) (and (and (forall ((s@@46 T@Shadowable) ) (! (VCRepOk (select shadow.VC@@0 s@@46))
 :qid |verifiedftbpl.160:11|
 :skolemid |8|
)) (VarsRepOk sx.W sx.R)) (= (ControlFlow 0 92) 91))) anon0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun ok@0 () Bool)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun tid () Int)
(declare-fun shadow.Lock@15 () (Array T@Shadowable Int))
(declare-fun thread.State@11 () (Array Int Int))
(declare-fun ok@2 () Bool)
(declare-fun ok@1 () Bool)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 () Int)
(declare-fun Civl_linear_tid_available@11 () (Array Int Bool))
(declare-fun Civl_global_old_shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$v@0 () T@Shadowable)
(declare-fun shadow.Lock@16 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 () Int)
(declare-fun Civl_global_old_thread.State@2 () (Array Int Int))
(declare-fun thread.State@12 () (Array Int Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 () Int)
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.thread.State@0 () (Array Int Int))
(declare-fun shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun thread.State@1 () (Array Int Int))
(declare-fun Civl_linear_tid_available@2 () (Array Int Bool))
(declare-fun shadow.Lock@13 () (Array T@Shadowable Int))
(declare-fun shadow.Lock@10 () (Array T@Shadowable Int))
(declare-fun thread.State@8 () (Array Int Int))
(declare-fun Civl_linear_tid_available@7 () (Array Int Bool))
(declare-fun shadow.Lock@7 () (Array T@Shadowable Int))
(declare-fun thread.State@5 () (Array Int Int))
(declare-fun Civl_linear_tid_available@5 () (Array Int Bool))
(declare-fun shadow.Lock@6 () (Array T@Shadowable Int))
(declare-fun thread.State@4 () (Array Int Int))
(declare-fun Civl_global_old_shadow.Lock@1 () (Array T@Shadowable Int))
(declare-fun Civl_global_old_thread.State@1 () (Array Int Int))
(declare-fun Civl_linear_tid_available@10 () (Array Int Bool))
(declare-fun inline$AtomicWrite$0$ok@2 () Bool)
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun x@1 () T@Var)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicWrite$0$st@2 () T@Shadowable)
(declare-fun inline$AtomicWrite$0$sx@2 () T@Shadowable)
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@10 () (Array T@Var T@Epoch))
(declare-fun sx.W@9 () (Array T@Var T@Epoch))
(declare-fun Trigger_AtomicWrite_sx (T@Shadowable) Bool)
(declare-fun inline$AtomicWrite$0$sx@1 () T@Shadowable)
(declare-fun Trigger_AtomicWrite_st (T@Shadowable) Bool)
(declare-fun inline$AtomicWrite$0$st@1 () T@Shadowable)
(declare-fun inline$AtomicRead$0$ok@2 () Bool)
(declare-fun x@2 () T@Var)
(declare-fun inline$AtomicRead$0$st@2 () T@Shadowable)
(declare-fun shadow.VC@15 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRead$0$sx@2 () T@Shadowable)
(declare-fun shadow.VC@16 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@17 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@18 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@10 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@13 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@14 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@9 () (Array T@Var T@Epoch))
(declare-fun Trigger_AtomicRead_sx (T@Shadowable) Bool)
(declare-fun inline$AtomicRead$0$sx@1 () T@Shadowable)
(declare-fun Trigger_AtomicRead_st (T@Shadowable) Bool)
(declare-fun inline$AtomicRead$0$st@1 () T@Shadowable)
(declare-fun shadow.Lock@14 () (Array T@Shadowable Int))
(declare-fun thread.State@10 () (Array Int Int))
(declare-fun Civl_linear_tid_available@9 () (Array Int Bool))
(declare-fun Trigger_AtomicAcquire_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicAcquire$0$v2@1 () T@Shadowable)
(declare-fun Trigger_AtomicAcquire_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicAcquire$0$v1@1 () T@Shadowable)
(declare-fun inline$AtomicAcquire$0$v1@2 () T@Shadowable)
(declare-fun inline$AtomicAcquire$0$v2@2 () T@Shadowable)
(declare-fun inline$AtomicChooseLockToAcquire$0$l@1 () T@Lock)
(declare-fun shadow.VC@12 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@11 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@12 () (Array T@Shadowable Int))
(declare-fun thread.State@9 () (Array Int Int))
(declare-fun shadow.Lock@11 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@8 () (Array Int Bool))
(declare-fun inline$AtomicChooseLockToRelease$0$l@1 () T@Lock)
(declare-fun shadow.VC@9 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRelease$0$v2@2 () T@Shadowable)
(declare-fun shadow.VC@8 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRelease$0$v1@2 () T@Shadowable)
(declare-fun Trigger_AtomicRelease_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicRelease$0$v2@1 () T@Shadowable)
(declare-fun Trigger_AtomicRelease_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicRelease$0$v1@1 () T@Shadowable)
(declare-fun shadow.Lock@9 () (Array T@Shadowable Int))
(declare-fun thread.State@7 () (Array Int Int))
(declare-fun shadow.Lock@8 () (Array T@Shadowable Int))
(declare-fun thread.State@6 () (Array Int Int))
(declare-fun Civl_linear_tid_available@6 () (Array Int Bool))
(declare-fun inline$AtomicAllocTid$0$uid@1 () Int)
(declare-fun Trigger_AtomicFork_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicFork$0$v2@1 () T@Shadowable)
(declare-fun Trigger_AtomicFork_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicFork$0$v1@1 () T@Shadowable)
(declare-fun inline$AtomicFork$0$v1@2 () T@Shadowable)
(declare-fun inline$AtomicFork$0$v2@2 () T@Shadowable)
(declare-fun shadow.VC@6 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun thread.ForkedBy@4 () (Array Int Int))
(declare-fun thread.ForkedBy@1 () (Array Int Int))
(declare-fun shadow.Lock@5 () (Array T@Shadowable Int))
(declare-fun thread.State@3 () (Array Int Int))
(declare-fun shadow.Lock@4 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@4 () (Array Int Bool))
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@1 () Int)
(declare-fun thread.State@2 () (Array Int Int))
(declare-fun shadow.Lock@3 () (Array T@Shadowable Int))
(declare-fun Civl_linear_tid_available@3 () (Array Int Bool))
(declare-fun Trigger_AtomicJoin_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicJoin$0$v2@1 () T@Shadowable)
(declare-fun Trigger_AtomicJoin_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicJoin$0$v1@1 () T@Shadowable)
(declare-fun inline$AtomicJoin$0$v1@2 () T@Shadowable)
(declare-fun inline$AtomicJoin$0$v2@2 () T@Shadowable)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock@2 () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@2 () (Array Int Int Bool))
(declare-fun thread.HasJoined@1 () (Array Int Int Bool))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun Civl_linear_tid_available@0 () (Array Int Bool))
(declare-fun ok () Bool)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun thread.State () (Array Int Int))
(set-info :boogie-vc-id Civl_Driver_30)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 187) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 174) (- 0 176)) true) (and (=> (= (ControlFlow 0 174) (- 0 175)) (=> false (= ok@0 ok@0))) (=> (=> false (= ok@0 ok@0)) (=> (and (and (= Civl_pc@0  (=> true false)) (= Civl_ok@0  (or true (and (= ok@0 ok@0) false)))) (= (ControlFlow 0 174) (- 0 173))) Civl_ok@0))))))
(let ((anon8_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 25) (- 0 29)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 25) (- 0 28)) (= (select shadow.Lock@15 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@15 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 25) (- 0 27)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 25) (- 0 26)) (= (select thread.State@11 tid) 2)) (=> (= (select thread.State@11 tid) 2) (=> (= (ControlFlow 0 25) (- 0 24)) (forall ((t Int) ) (!  (=> (= (select thread.State@11 t) 0) (= (select shadow.Lock@15 (ShadowableTid t)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)))))))))))))
(let ((Civl_UnchangedChecker_correct  (and (=> (= (ControlFlow 0 19) (- 0 20)) true) (=> (= (ControlFlow 0 19) (- 0 18)) (=> false (= ok@2 ok@0))))))
(let ((anon12_Then$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 135) 19)) Civl_UnchangedChecker_correct)))
(let ((anon13_Then_1$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 105) 19)) Civl_UnchangedChecker_correct)))
(let ((anon13_Then$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 103) 19)) Civl_UnchangedChecker_correct)))
(let ((anon14_Then_1$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 64) 19)) Civl_UnchangedChecker_correct)))
(let ((anon14_Then$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 62) 19)) Civl_UnchangedChecker_correct)))
(let ((anon8_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@1) (= (ControlFlow 0 31) 19)) Civl_UnchangedChecker_correct)))
(let ((anon14_Else_1$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 23) 19)) Civl_UnchangedChecker_correct)))
(let ((anon14_Else$1_@2_Civl_UnchangedChecker_correct  (=> (and (= ok@2 ok@0) (= (ControlFlow 0 21) 19)) Civl_UnchangedChecker_correct)))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@11 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |335|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 0)) (= (select Civl_global_old_shadow.Lock@2 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0)) (and (=> (= (ControlFlow 0 14) (- 0 15)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0 0)) (=> (= (ControlFlow 0 14) (- 0 13)) (= (select shadow.Lock@16 inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$v@0) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$tid@0))))))))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@11 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |336|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 0)) (and (= (select Civl_global_old_thread.State@2 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0) 2) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t Int) ) (!  (=> (= (select Civl_global_old_thread.State@2 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t) 0) (= (select Civl_global_old_shadow.Lock@2 (ShadowableTid inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t)) nil))
 :qid |unknown.0:0|
 :skolemid |36|
)))) (and (=> (= (ControlFlow 0 10) (- 0 12)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0 0)) (and (=> (= (ControlFlow 0 10) (- 0 11)) (= (select thread.State@12 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0) 2)) (=> (= (select thread.State@12 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$tid@0) 2) (=> (= (ControlFlow 0 10) (- 0 9)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t@@0 Int) ) (!  (=> (= (select thread.State@12 inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t@@0) 0) (= (select shadow.Lock@16 (ShadowableTid inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$t@@0)) nil))
 :qid |unknown.0:0|
 :skolemid |36|
)))))))))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct  (=> (exists ((inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$Civl_partition_tid (Array Int Int)) ) (!  (and (= ((_ map =>) (store ((as const (Array Int Bool)) false) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 true) ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$Civl_partition_tid ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)) (= ((_ map =>) Civl_linear_tid_available@11 ((_ map (= (Int Int) Bool)) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$Civl_partition_tid ((as const (Array Int Int)) 1))) ((as const (Array Int Bool)) true)))
 :qid |unknown.0:0|
 :skolemid |337|
)) (=> (and (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 0)) (and (forall ((v@@1 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 v@@1) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0) (= (select Civl_global_old_shadow.Lock@2 v@@1) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t Int) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 (ShadowableTid inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t)) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0) (= (select Civl_global_old_thread.State@2 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t) (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.thread.State@0 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t)))
 :qid |unknown.0:0|
 :skolemid |37|
)))) (and (=> (= (ControlFlow 0 5) (- 0 7)) (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 0))) (=> (and (not (= inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 nil)) (>= inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0 0)) (and (=> (= (ControlFlow 0 5) (- 0 6)) (forall ((v@@2 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0) (= (select shadow.Lock@16 v@@2) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@3 T@Shadowable) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0) (= (select shadow.Lock@16 v@@3) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (=> (= (ControlFlow 0 5) (- 0 4)) (forall ((inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t@@0 Int) ) (!  (=> (= (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.shadow.Lock@0 (ShadowableTid inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t@@0)) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$tid@0) (= (select thread.State@12 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t@@0) (select inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$old.thread.State@0 inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$t@@0)))
 :qid |unknown.0:0|
 :skolemid |37|
)))))))))))
(let ((anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@1) (=> (and (and (= thread.State@12 thread.State@1) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 177) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 177) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 177) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 177) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon9_LoopDone_correct  (=> (not ok@0) (and (=> (= (ControlFlow 0 178) 174) Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 178) 177) anon9_LoopDone_@2_Civl_NoninterferenceChecker_correct)))))
(let ((anon12_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@13) (=> (and (and (= thread.State@12 thread.State@1) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 134) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 134) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 134) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 134) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon13_Then_1$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@10) (=> (and (and (= thread.State@12 thread.State@8) (= Civl_global_old_shadow.Lock@2 shadow.Lock@10)) (and (= Civl_global_old_thread.State@2 thread.State@8) (= Civl_linear_tid_available@11 Civl_linear_tid_available@7))) (and (and (and (=> (= (ControlFlow 0 104) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 104) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 104) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 104) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon13_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@1) (=> (and (and (= thread.State@12 thread.State@1) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 102) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 102) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 102) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 102) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon14_Then_1$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@7) (=> (and (and (= thread.State@12 thread.State@5) (= Civl_global_old_shadow.Lock@2 shadow.Lock@7)) (and (= Civl_global_old_thread.State@2 thread.State@5) (= Civl_linear_tid_available@11 Civl_linear_tid_available@5))) (and (and (and (=> (= (ControlFlow 0 63) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 63) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 63) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 63) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon14_Then$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@6) (=> (and (and (= thread.State@12 thread.State@4) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 61) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 61) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 61) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 61) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon8_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@15) (=> (and (and (= thread.State@12 thread.State@11) (= Civl_global_old_shadow.Lock@2 Civl_global_old_shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 Civl_global_old_thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@10))) (and (and (and (=> (= (ControlFlow 0 30) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 30) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 30) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 30) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((anon10_Then$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@1) (= thread.State@11 thread.State@1)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_thread.State@1 thread.State@1)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@2) (= ok@1 inline$AtomicWrite$0$ok@2))) (and (and (=> (= (ControlFlow 0 162) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 162) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 162) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicWrite$0$SharedWriteRace_correct  (=> (and (and (= (select sx.R@1 x@1) SHARED) (not (forall ((inline$AtomicWrite$0$j Int) ) (!  (=> (and (and (<= 0 inline$AtomicWrite$0$j) (< inline$AtomicWrite$0$j (ite (< (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$sx@2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$sx@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (- 0 1)))))) (f inline$AtomicWrite$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$sx@2) inline$AtomicWrite$0$j)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) inline$AtomicWrite$0$j))) (<= (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$sx@2) inline$AtomicWrite$0$j)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) inline$AtomicWrite$0$j)))))
 :qid |unknown.0:0|
 :skolemid |35|
 :pattern ( (f inline$AtomicWrite$0$j))
)))) (and (= inline$AtomicWrite$0$ok@2 false) (= (ControlFlow 0 168) 162))) anon10_Then$1_correct)))
(let ((inline$AtomicWrite$0$ReadWriteRace_correct  (=> (and (and (not (= (select sx.R@1 x@1) SHARED)) (not (and (= (|tid#epoch| (select sx.R@1 x@1)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.R@1 x@1))))) (<= (|clock#epoch| (select sx.R@1 x@1)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.R@1 x@1)))))))) (and (= inline$AtomicWrite$0$ok@2 false) (= (ControlFlow 0 167) 162))) anon10_Then$1_correct)))
(let ((inline$AtomicWrite$0$WriteWriteRace_correct  (=> (not (and (= (|tid#epoch| (select sx.W@1 x@1)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1))))) (<= (|clock#epoch| (select sx.W@1 x@1)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1))))))) (=> (and (= inline$AtomicWrite$0$ok@2 false) (= (ControlFlow 0 166) 162)) anon10_Then$1_correct))))
(let ((inline$AtomicWrite$0$WritedShared_correct  (=> (and (and (and (= (|tid#epoch| (select sx.W@1 x@1)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1))))) (<= (|clock#epoch| (select sx.W@1 x@1)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1)))))) (= (select sx.R@1 x@1) SHARED)) (and (and (forall ((inline$AtomicWrite$0$j@@0 Int) ) (!  (=> (and (and (<= 0 inline$AtomicWrite$0$j@@0) (< inline$AtomicWrite$0$j@@0 (ite (< (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$sx@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$sx@2) (- 0 1)))))) (f inline$AtomicWrite$0$j@@0)) (and (= (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$sx@2) inline$AtomicWrite$0$j@@0)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) inline$AtomicWrite$0$j@@0))) (<= (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$sx@2) inline$AtomicWrite$0$j@@0)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) inline$AtomicWrite$0$j@@0)))))
 :qid |unknown.0:0|
 :skolemid |34|
 :pattern ( (f inline$AtomicWrite$0$j@@0))
)) (= sx.W@10 (store sx.W@1 x@1 (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) tid)))) (and (= inline$AtomicWrite$0$ok@2 true) (= (ControlFlow 0 165) 162)))) anon10_Then$1_correct)))
(let ((inline$AtomicWrite$0$WriteExclusive_correct  (=> (and (and (= (|tid#epoch| (select sx.W@1 x@1)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1))))) (<= (|clock#epoch| (select sx.W@1 x@1)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.W@1 x@1)))))) (not (= (select sx.R@1 x@1) SHARED))) (=> (and (and (and (= (|tid#epoch| (select sx.R@1 x@1)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.R@1 x@1))))) (<= (|clock#epoch| (select sx.R@1 x@1)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) (|tid#epoch| (select sx.R@1 x@1)))))) (= sx.W@9 (store sx.W@1 x@1 (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) tid)))) (and (= inline$AtomicWrite$0$ok@2 true) (= (ControlFlow 0 164) 162))) anon10_Then$1_correct))))
(let ((inline$AtomicWrite$0$WriteFastPath_correct  (=> (= (select sx.W@1 x@1) (select (select shadow.VC@1 inline$AtomicWrite$0$st@2) tid)) (=> (and (= inline$AtomicWrite$0$ok@2 true) (= (ControlFlow 0 163) 162)) anon10_Then$1_correct))))
(let ((inline$AtomicWrite$0$anon0_correct  (=> (and (and (Trigger_AtomicWrite_sx inline$AtomicWrite$0$sx@1) (Trigger_AtomicWrite_st inline$AtomicWrite$0$st@1)) (and (= inline$AtomicWrite$0$st@2 (ShadowableTid tid)) (= inline$AtomicWrite$0$sx@2 (ShadowableVar x@1)))) (and (and (and (and (and (=> (= (ControlFlow 0 169) 163) inline$AtomicWrite$0$WriteFastPath_correct) (=> (= (ControlFlow 0 169) 164) inline$AtomicWrite$0$WriteExclusive_correct)) (=> (= (ControlFlow 0 169) 165) inline$AtomicWrite$0$WritedShared_correct)) (=> (= (ControlFlow 0 169) 166) inline$AtomicWrite$0$WriteWriteRace_correct)) (=> (= (ControlFlow 0 169) 167) inline$AtomicWrite$0$ReadWriteRace_correct)) (=> (= (ControlFlow 0 169) 168) inline$AtomicWrite$0$SharedWriteRace_correct)))))
(let ((anon10_Then_correct  (and (=> (= (ControlFlow 0 170) (- 0 171)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 170) 169) inline$AtomicWrite$0$anon0_correct)))))
(let ((anon11_Then$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@1) (= thread.State@11 thread.State@1)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@1) (= Civl_global_old_thread.State@1 thread.State@1)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@2) (= ok@1 inline$AtomicRead$0$ok@2))) (and (and (=> (= (ControlFlow 0 151) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 151) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 151) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicRead$0$WriteReadRace_correct  (=> (not (and (= (|tid#epoch| (select sx.W@1 x@2)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2))))) (<= (|clock#epoch| (select sx.W@1 x@2)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2))))))) (=> (and (= inline$AtomicRead$0$ok@2 false) (= (ControlFlow 0 157) 151)) anon11_Then$1_correct))))
(let ((inline$AtomicRead$0$ReadShare_correct  (=> (not (= (select sx.R@1 x@2) SHARED)) (=> (and (and (and (and (= (|tid#epoch| (select sx.W@1 x@2)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2))))) (<= (|clock#epoch| (select sx.W@1 x@2)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2)))))) (= shadow.VC@15 (store shadow.VC@1 inline$AtomicRead$0$sx@2 (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0))))) (and (= shadow.VC@16 (store shadow.VC@15 inline$AtomicRead$0$sx@2 (store (select shadow.VC@15 inline$AtomicRead$0$sx@2) (|tid#epoch| (select sx.R@1 x@2)) (select sx.R@1 x@2)))) (= shadow.VC@17 (store shadow.VC@16 inline$AtomicRead$0$sx@2 (store (select shadow.VC@16 inline$AtomicRead$0$sx@2) tid (select (select shadow.VC@16 inline$AtomicRead$0$st@2) tid)))))) (and (and (= shadow.VC@18 (store shadow.VC@17 inline$AtomicRead$0$sx@2 (store (select shadow.VC@17 inline$AtomicRead$0$sx@2) (- 0 1) (epoch (- 0 1) (ite (< (+ (|tid#epoch| (select sx.R@1 x@2)) 1) (+ tid 1)) (+ tid 1) (+ (|tid#epoch| (select sx.R@1 x@2)) 1)))))) (= sx.R@10 (store sx.R@1 x@2 SHARED))) (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 156) 151)))) anon11_Then$1_correct))))
(let ((inline$AtomicRead$0$ReadShared_correct  (=> (= (select sx.R@1 x@2) SHARED) (=> (and (= (|tid#epoch| (select sx.W@1 x@2)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2))))) (<= (|clock#epoch| (select sx.W@1 x@2)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2)))))) (=> (and (and (= shadow.VC@13 (store shadow.VC@1 inline$AtomicRead$0$sx@2 (store (select shadow.VC@1 inline$AtomicRead$0$sx@2) tid (select (select shadow.VC@1 inline$AtomicRead$0$st@2) tid)))) (= shadow.VC@14 (store shadow.VC@13 inline$AtomicRead$0$sx@2 (store (select shadow.VC@13 inline$AtomicRead$0$sx@2) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@13 inline$AtomicRead$0$sx@2) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@13 inline$AtomicRead$0$sx@2) (- 0 1))))))))) (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 155) 151))) anon11_Then$1_correct)))))
(let ((inline$AtomicRead$0$ReadExclusive_correct  (=> (not (= (select sx.R@1 x@2) SHARED)) (=> (and (= (|tid#epoch| (select sx.W@1 x@2)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2))))) (<= (|clock#epoch| (select sx.W@1 x@2)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.W@1 x@2)))))) (=> (and (and (and (= (|tid#epoch| (select sx.R@1 x@2)) (|tid#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.R@1 x@2))))) (<= (|clock#epoch| (select sx.R@1 x@2)) (|clock#epoch| (select (select shadow.VC@1 inline$AtomicRead$0$st@2) (|tid#epoch| (select sx.R@1 x@2)))))) (= sx.R@9 (store sx.R@1 x@2 (select (select shadow.VC@1 inline$AtomicRead$0$st@2) tid)))) (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 154) 151))) anon11_Then$1_correct)))))
(let ((inline$AtomicRead$0$ReadSharedSameEpoch_correct  (=> (and (and (= (select sx.R@1 x@2) SHARED) (= (select (select shadow.VC@1 inline$AtomicRead$0$sx@2) tid) (select (select shadow.VC@1 inline$AtomicRead$0$st@2) tid))) (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 153) 151))) anon11_Then$1_correct)))
(let ((inline$AtomicRead$0$ReadSameEpoch_correct  (=> (= (select sx.R@1 x@2) (select (select shadow.VC@1 inline$AtomicRead$0$st@2) tid)) (=> (and (= inline$AtomicRead$0$ok@2 true) (= (ControlFlow 0 152) 151)) anon11_Then$1_correct))))
(let ((inline$AtomicRead$0$anon0_correct  (=> (and (and (Trigger_AtomicRead_sx inline$AtomicRead$0$sx@1) (Trigger_AtomicRead_st inline$AtomicRead$0$st@1)) (and (= inline$AtomicRead$0$st@2 (ShadowableTid tid)) (= inline$AtomicRead$0$sx@2 (ShadowableVar x@2)))) (and (and (and (and (and (=> (= (ControlFlow 0 158) 152) inline$AtomicRead$0$ReadSameEpoch_correct) (=> (= (ControlFlow 0 158) 153) inline$AtomicRead$0$ReadSharedSameEpoch_correct)) (=> (= (ControlFlow 0 158) 154) inline$AtomicRead$0$ReadExclusive_correct)) (=> (= (ControlFlow 0 158) 155) inline$AtomicRead$0$ReadShared_correct)) (=> (= (ControlFlow 0 158) 156) inline$AtomicRead$0$ReadShare_correct)) (=> (= (ControlFlow 0 158) 157) inline$AtomicRead$0$WriteReadRace_correct)))))
(let ((anon11_Then_correct  (and (=> (= (ControlFlow 0 159) (- 0 161)) (and (and (not (= tid nil)) (>= tid 0)) (>= tid 0))) (=> (and (and (not (= tid nil)) (>= tid 0)) (>= tid 0)) (and (=> (= (ControlFlow 0 159) (- 0 160)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 159) 158) inline$AtomicRead$0$anon0_correct)))))))
(let ((anon12_Then_0$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@14) (= thread.State@11 thread.State@10)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@14) (= Civl_global_old_thread.State@1 thread.State@10)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@9) (= ok@1 ok@0))) (and (and (=> (= (ControlFlow 0 136) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 136) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 136) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicAcquire$0$anon0_correct  (=> (Trigger_AtomicAcquire_v2 inline$AtomicAcquire$0$v2@1) (=> (and (and (and (Trigger_AtomicAcquire_v1 inline$AtomicAcquire$0$v1@1) (= inline$AtomicAcquire$0$v1@2 (ShadowableTid tid))) (and (= inline$AtomicAcquire$0$v2@2 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) (VCRepOk (select shadow.VC@12 inline$AtomicAcquire$0$v1@2)))) (and (and (= (|clock#epoch| (select (select shadow.VC@12 inline$AtomicAcquire$0$v1@2) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v1@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v2@2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v2@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v1@2) (- 0 1))))) (forall ((inline$AtomicAcquire$0$j Int) ) (!  (=> (<= 0 inline$AtomicAcquire$0$j) (= (select (select shadow.VC@12 inline$AtomicAcquire$0$v1@2) inline$AtomicAcquire$0$j) (epoch (|tid#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v1@2) inline$AtomicAcquire$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v1@2) inline$AtomicAcquire$0$j)) (|clock#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v2@2) inline$AtomicAcquire$0$j))) (|clock#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v2@2) inline$AtomicAcquire$0$j)) (|clock#epoch| (select (select shadow.VC@11 inline$AtomicAcquire$0$v1@2) inline$AtomicAcquire$0$j))))))
 :qid |unknown.0:0|
 :skolemid |31|
))) (and (= shadow.VC@12 (store shadow.VC@11 inline$AtomicAcquire$0$v1@2 (select shadow.VC@12 inline$AtomicAcquire$0$v1@2))) (= (ControlFlow 0 137) 136)))) anon12_Then_0$1_correct))))
(let ((anon12_Then_0_correct  (and (=> (= (ControlFlow 0 138) (- 0 147)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 138) (- 0 146)) (= (select thread.State@1 tid) 2)) (=> (= (select thread.State@1 tid) 2) (and (=> (= (ControlFlow 0 138) (- 0 145)) (forall ((t@@0 Int) ) (!  (=> (= (select thread.State@1 t@@0) 0) (= (select shadow.Lock@13 (ShadowableTid t@@0)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@1 Int) ) (!  (=> (= (select thread.State@1 t@@1) 0) (= (select shadow.Lock@13 (ShadowableTid t@@1)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 138) (- 0 144)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 138) (- 0 143)) (forall ((v@@4 T@Shadowable) ) (!  (=> (= (select shadow.Lock@13 v@@4) tid) (= (select shadow.Lock@13 v@@4) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@5 T@Shadowable) ) (!  (=> (= (select shadow.Lock@13 v@@5) tid) (= (select shadow.Lock@13 v@@5) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 138) (- 0 142)) (forall ((t@@2 Int) ) (!  (=> (= (select shadow.Lock@13 (ShadowableTid t@@2)) tid) (= (select thread.State@1 t@@2) (select thread.State@1 t@@2)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@3 Int) ) (!  (=> (= (select shadow.Lock@13 (ShadowableTid t@@3)) tid) (= (select thread.State@1 t@@3) (select thread.State@1 t@@3)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
)) (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (= (select thread.State@10 tid) 2) (forall ((t@@4 Int) ) (!  (=> (= (select thread.State@10 t@@4) 0) (= (select shadow.Lock@14 (ShadowableTid t@@4)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (and (not (= tid nil)) (>= tid 0))) (and (and (forall ((v@@6 T@Shadowable) ) (!  (=> (= (select shadow.Lock@13 v@@6) tid) (= (select shadow.Lock@14 v@@6) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((t@@5 Int) ) (!  (=> (= (select shadow.Lock@13 (ShadowableTid t@@5)) tid) (= (select thread.State@10 t@@5) (select thread.State@1 t@@5)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@9 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 138) (- 0 141)) (= (select shadow.Lock@14 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@14 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 138) (- 0 140)) (= (select shadow.Lock@14 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) tid)) (=> (= (select shadow.Lock@14 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) tid) (and (=> (= (ControlFlow 0 138) (- 0 139)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 138) 137) inline$AtomicAcquire$0$anon0_correct)))))))))))))))))))))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (and (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1)) nil) (= shadow.Lock@13 (store shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@1) tid))) (and (and (=> (= (ControlFlow 0 148) 138) anon12_Then_0_correct) (=> (= (ControlFlow 0 148) 134) anon12_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 148) 135) anon12_Then$1_@2_Civl_UnchangedChecker_correct)))))
(let ((anon12_Then_correct  (and (=> (= (ControlFlow 0 149) (- 0 150)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 149) 148) inline$AtomicChooseLockToAcquire$0$anon0_correct)))))
(let ((anon13_Then_0$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@12) (= thread.State@11 thread.State@9)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@11) (= Civl_global_old_thread.State@1 thread.State@9)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@8) (= ok@1 ok@0))) (and (and (=> (= (ControlFlow 0 106) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 106) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 106) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@12 (store shadow.Lock@11 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1) nil)) (= (ControlFlow 0 107) 106)) anon13_Then_0$1_correct)))
(let ((anon13_Then_0_correct  (and (=> (= (ControlFlow 0 108) (- 0 116)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 108) (- 0 115)) (= (select thread.State@8 tid) 2)) (=> (= (select thread.State@8 tid) 2) (and (=> (= (ControlFlow 0 108) (- 0 114)) (forall ((t@@6 Int) ) (!  (=> (= (select thread.State@8 t@@6) 0) (= (select shadow.Lock@10 (ShadowableTid t@@6)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@7 Int) ) (!  (=> (= (select thread.State@8 t@@7) 0) (= (select shadow.Lock@10 (ShadowableTid t@@7)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 108) (- 0 113)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 108) (- 0 112)) (forall ((v@@7 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@7) tid) (= (select shadow.Lock@10 v@@7) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@8 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@8) tid) (= (select shadow.Lock@10 v@@8) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 108) (- 0 111)) (forall ((t@@8 Int) ) (!  (=> (= (select shadow.Lock@10 (ShadowableTid t@@8)) tid) (= (select thread.State@8 t@@8) (select thread.State@8 t@@8)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@9 Int) ) (!  (=> (= (select shadow.Lock@10 (ShadowableTid t@@9)) tid) (= (select thread.State@8 t@@9) (select thread.State@8 t@@9)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
)) (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (= (select thread.State@9 tid) 2) (forall ((t@@10 Int) ) (!  (=> (= (select thread.State@9 t@@10) 0) (= (select shadow.Lock@11 (ShadowableTid t@@10)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (and (not (= tid nil)) (>= tid 0))) (and (and (forall ((v@@9 T@Shadowable) ) (!  (=> (= (select shadow.Lock@10 v@@9) tid) (= (select shadow.Lock@11 v@@9) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((t@@11 Int) ) (!  (=> (= (select shadow.Lock@10 (ShadowableTid t@@11)) tid) (= (select thread.State@9 t@@11) (select thread.State@8 t@@11)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@8 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 108) (- 0 110)) (= (select shadow.Lock@11 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid)) (=> (= (select shadow.Lock@11 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid) (and (=> (= (ControlFlow 0 108) (- 0 109)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 108) 107) inline$AtomicReleaseChosenLock$0$anon0_correct)))))))))))))))))))))
(let ((inline$AtomicRelease$0$anon3_correct  (=> (VCRepOk (select shadow.VC@9 inline$AtomicRelease$0$v2@2)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@9 inline$AtomicRelease$0$v2@2) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@9 inline$AtomicRelease$0$v2@2) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@9 inline$AtomicRelease$0$v2@2) (- 0 1))))) (forall ((inline$AtomicRelease$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicRelease$0$j) (not (= inline$AtomicRelease$0$j tid))) (= (select (select shadow.VC@9 inline$AtomicRelease$0$v2@2) inline$AtomicRelease$0$j) (select (select shadow.VC@8 inline$AtomicRelease$0$v2@2) inline$AtomicRelease$0$j)))
 :qid |unknown.0:0|
 :skolemid |33|
))) (and (= (select (select shadow.VC@9 inline$AtomicRelease$0$v2@2) tid) (epoch (|tid#epoch| (select (select shadow.VC@8 inline$AtomicRelease$0$v2@2) tid)) (+ (|clock#epoch| (select (select shadow.VC@8 inline$AtomicRelease$0$v2@2) tid)) 1))) (= shadow.VC@9 (store (store shadow.VC@8 inline$AtomicRelease$0$v1@2 (select shadow.VC@9 inline$AtomicRelease$0$v1@2)) inline$AtomicRelease$0$v2@2 (select shadow.VC@9 inline$AtomicRelease$0$v2@2))))) (and (and (=> (= (ControlFlow 0 117) 108) anon13_Then_0_correct) (=> (= (ControlFlow 0 117) 104) anon13_Then_1$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 117) 105) anon13_Then_1$1_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicRelease$0$anon4_Else_correct  (=> (and (= (select shadow.VC@9 inline$AtomicRelease$0$v1@2) (select shadow.VC@8 inline$AtomicRelease$0$v2@2)) (= (ControlFlow 0 119) 117)) inline$AtomicRelease$0$anon3_correct)))
(let ((inline$AtomicRelease$0$anon4_Then_correct  (=> (and (and (VCRepOk (select shadow.VC@9 inline$AtomicRelease$0$v1@2)) (= (|clock#epoch| (select (select shadow.VC@9 inline$AtomicRelease$0$v1@2) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@8 inline$AtomicRelease$0$v1@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@8 inline$AtomicRelease$0$v2@2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@8 inline$AtomicRelease$0$v2@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@8 inline$AtomicRelease$0$v1@2) (- 0 1)))))) (and (forall ((inline$AtomicRelease$0$j@@0 Int) ) (!  (=> (<= 0 inline$AtomicRelease$0$j@@0) (= (select (select shadow.VC@9 inline$AtomicRelease$0$v1@2) inline$AtomicRelease$0$j@@0) (select (select shadow.VC@8 inline$AtomicRelease$0$v2@2) inline$AtomicRelease$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |32|
)) (= (ControlFlow 0 118) 117))) inline$AtomicRelease$0$anon3_correct)))
(let ((inline$AtomicRelease$0$anon0_correct  (=> (and (and (Trigger_AtomicRelease_v2 inline$AtomicRelease$0$v2@1) (Trigger_AtomicRelease_v1 inline$AtomicRelease$0$v1@1)) (and (= inline$AtomicRelease$0$v1@2 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) (= inline$AtomicRelease$0$v2@2 (ShadowableTid tid)))) (and (=> (= (ControlFlow 0 120) 118) inline$AtomicRelease$0$anon4_Then_correct) (=> (= (ControlFlow 0 120) 119) inline$AtomicRelease$0$anon4_Else_correct)))))
(let ((anon13_Then_1_correct  (and (=> (= (ControlFlow 0 121) (- 0 130)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 121) (- 0 129)) (= (select thread.State@1 tid) 2)) (=> (= (select thread.State@1 tid) 2) (and (=> (= (ControlFlow 0 121) (- 0 128)) (forall ((t@@12 Int) ) (!  (=> (= (select thread.State@1 t@@12) 0) (= (select shadow.Lock@1 (ShadowableTid t@@12)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@13 Int) ) (!  (=> (= (select thread.State@1 t@@13) 0) (= (select shadow.Lock@1 (ShadowableTid t@@13)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 121) (- 0 127)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 121) (- 0 126)) (forall ((v@@10 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@10) tid) (= (select shadow.Lock@1 v@@10) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@11 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@11) tid) (= (select shadow.Lock@1 v@@11) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 121) (- 0 125)) (forall ((t@@14 Int) ) (!  (=> (= (select shadow.Lock@1 (ShadowableTid t@@14)) tid) (= (select thread.State@1 t@@14) (select thread.State@1 t@@14)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@15 Int) ) (!  (=> (= (select shadow.Lock@1 (ShadowableTid t@@15)) tid) (= (select thread.State@1 t@@15) (select thread.State@1 t@@15)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
)) (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (= (select thread.State@8 tid) 2) (forall ((t@@16 Int) ) (!  (=> (= (select thread.State@8 t@@16) 0) (= (select shadow.Lock@10 (ShadowableTid t@@16)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (and (not (= tid nil)) (>= tid 0))) (and (and (forall ((v@@12 T@Shadowable) ) (!  (=> (= (select shadow.Lock@1 v@@12) tid) (= (select shadow.Lock@10 v@@12) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((t@@17 Int) ) (!  (=> (= (select shadow.Lock@1 (ShadowableTid t@@17)) tid) (= (select thread.State@8 t@@17) (select thread.State@1 t@@17)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@7 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 121) (- 0 124)) (= (select shadow.Lock@10 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid)) (=> (= (select shadow.Lock@10 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid) (and (=> (= (ControlFlow 0 121) (- 0 123)) (= (select shadow.Lock@10 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@10 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 121) (- 0 122)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 121) 120) inline$AtomicRelease$0$anon0_correct)))))))))))))))))))))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (= (select shadow.Lock@1 (ShadowableLock inline$AtomicChooseLockToRelease$0$l@1)) tid) (and (and (=> (= (ControlFlow 0 131) 121) anon13_Then_1_correct) (=> (= (ControlFlow 0 131) 102) anon13_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 131) 103) anon13_Then$1_@2_Civl_UnchangedChecker_correct)))))
(let ((anon13_Then_correct  (and (=> (= (ControlFlow 0 132) (- 0 133)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 132) 131) inline$AtomicChooseLockToRelease$0$anon0_correct)))))
(let ((anon14_Then_0$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@9) (= thread.State@11 thread.State@7)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@8) (= Civl_global_old_thread.State@1 thread.State@6)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@6) (= ok@1 ok@0))) (and (and (=> (= (ControlFlow 0 65) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 65) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 65) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@7 (store thread.State@6 inline$AtomicAllocTid$0$uid@1 2)) (=> (and (= shadow.Lock@9 (store shadow.Lock@8 (ShadowableTid inline$AtomicAllocTid$0$uid@1) inline$AtomicAllocTid$0$uid@1)) (= (ControlFlow 0 66) 65)) anon14_Then_0$1_correct))))
(let ((anon14_Then_0_correct  (and (=> (= (ControlFlow 0 67) (- 0 78)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 67) (- 0 77)) (= (select thread.State@5 tid) 2)) (=> (= (select thread.State@5 tid) 2) (and (=> (= (ControlFlow 0 67) (- 0 76)) (forall ((t@@18 Int) ) (!  (=> (= (select thread.State@5 t@@18) 0) (= (select shadow.Lock@7 (ShadowableTid t@@18)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@19 Int) ) (!  (=> (= (select thread.State@5 t@@19) 0) (= (select shadow.Lock@7 (ShadowableTid t@@19)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 67) (- 0 75)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 67) (- 0 74)) (forall ((v@@13 T@Shadowable) ) (!  (=> (= (select shadow.Lock@7 v@@13) tid) (= (select shadow.Lock@7 v@@13) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@14 T@Shadowable) ) (!  (=> (= (select shadow.Lock@7 v@@14) tid) (= (select shadow.Lock@7 v@@14) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 67) (- 0 73)) (forall ((t@@20 Int) ) (!  (=> (= (select shadow.Lock@7 (ShadowableTid t@@20)) tid) (= (select thread.State@5 t@@20) (select thread.State@5 t@@20)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@21 Int) ) (!  (=> (= (select shadow.Lock@7 (ShadowableTid t@@21)) tid) (= (select thread.State@5 t@@21) (select thread.State@5 t@@21)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
)) (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (= (select thread.State@6 tid) 2) (forall ((t@@22 Int) ) (!  (=> (= (select thread.State@6 t@@22) 0) (= (select shadow.Lock@8 (ShadowableTid t@@22)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (and (not (= tid nil)) (>= tid 0))) (and (and (forall ((v@@15 T@Shadowable) ) (!  (=> (= (select shadow.Lock@7 v@@15) tid) (= (select shadow.Lock@8 v@@15) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((t@@23 Int) ) (!  (=> (= (select shadow.Lock@7 (ShadowableTid t@@23)) tid) (= (select thread.State@6 t@@23) (select thread.State@5 t@@23)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@6 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 67) (- 0 72)) (= (select thread.State@6 inline$AtomicAllocTid$0$uid@1) 1)) (=> (= (select thread.State@6 inline$AtomicAllocTid$0$uid@1) 1) (and (=> (= (ControlFlow 0 67) (- 0 71)) (= (select shadow.Lock@8 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid)) (=> (= (select shadow.Lock@8 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid) (and (=> (= (ControlFlow 0 67) (- 0 70)) (not (= tid inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 67) (- 0 69)) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (=> (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0)) (and (=> (= (ControlFlow 0 67) (- 0 68)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 67) 66) inline$AtomicStartThread$0$anon0_correct)))))))))))))))))))))))))))
(let ((inline$AtomicFork$0$anon0_correct  (=> (and (and (Trigger_AtomicFork_v2 inline$AtomicFork$0$v2@1) (Trigger_AtomicFork_v1 inline$AtomicFork$0$v1@1)) (and (= inline$AtomicFork$0$v1@2 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) (= inline$AtomicFork$0$v2@2 (ShadowableTid tid)))) (=> (and (and (and (= (|clock#epoch| (select (select shadow.VC@6 inline$AtomicFork$0$v1@2) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v1@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v2@2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v2@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v1@2) (- 0 1))))) (VCRepOk (select shadow.VC@6 inline$AtomicFork$0$v1@2))) (and (forall ((inline$AtomicFork$0$j Int) ) (!  (=> (<= 0 inline$AtomicFork$0$j) (= (select (select shadow.VC@6 inline$AtomicFork$0$v1@2) inline$AtomicFork$0$j) (epoch (|tid#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v1@2) inline$AtomicFork$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v1@2) inline$AtomicFork$0$j)) (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v2@2) inline$AtomicFork$0$j))) (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v2@2) inline$AtomicFork$0$j)) (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v1@2) inline$AtomicFork$0$j))))))
 :qid |unknown.0:0|
 :skolemid |28|
)) (VCRepOk (select shadow.VC@6 inline$AtomicFork$0$v2@2)))) (and (and (= (|clock#epoch| (select (select shadow.VC@6 inline$AtomicFork$0$v2@2) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@6 inline$AtomicFork$0$v2@2) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@6 inline$AtomicFork$0$v2@2) (- 0 1))))) (forall ((inline$AtomicFork$0$j@@0 Int) ) (!  (=> (and (<= 0 inline$AtomicFork$0$j@@0) (not (= inline$AtomicFork$0$j@@0 tid))) (= (select (select shadow.VC@6 inline$AtomicFork$0$v2@2) inline$AtomicFork$0$j@@0) (select (select shadow.VC@5 inline$AtomicFork$0$v2@2) inline$AtomicFork$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |29|
))) (and (= (select (select shadow.VC@6 inline$AtomicFork$0$v2@2) tid) (epoch (|tid#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v2@2) tid)) (+ (|clock#epoch| (select (select shadow.VC@5 inline$AtomicFork$0$v2@2) tid)) 1))) (= shadow.VC@6 (store (store shadow.VC@5 inline$AtomicFork$0$v1@2 (select shadow.VC@6 inline$AtomicFork$0$v1@2)) inline$AtomicFork$0$v2@2 (select shadow.VC@6 inline$AtomicFork$0$v2@2)))))) (and (and (=> (= (ControlFlow 0 79) 67) anon14_Then_0_correct) (=> (= (ControlFlow 0 79) 63) anon14_Then_1$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 79) 64) anon14_Then_1$1_@2_Civl_UnchangedChecker_correct))))))
(let ((anon14_Then_1_correct  (and (=> (= (ControlFlow 0 80) (- 0 93)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 80) (- 0 92)) (= (select thread.State@4 tid) 2)) (=> (= (select thread.State@4 tid) 2) (and (=> (= (ControlFlow 0 80) (- 0 91)) (forall ((t@@24 Int) ) (!  (=> (= (select thread.State@4 t@@24) 0) (= (select shadow.Lock@6 (ShadowableTid t@@24)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@25 Int) ) (!  (=> (= (select thread.State@4 t@@25) 0) (= (select shadow.Lock@6 (ShadowableTid t@@25)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 80) (- 0 90)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 80) (- 0 89)) (forall ((v@@16 T@Shadowable) ) (!  (=> (= (select shadow.Lock@6 v@@16) tid) (= (select shadow.Lock@6 v@@16) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@17 T@Shadowable) ) (!  (=> (= (select shadow.Lock@6 v@@17) tid) (= (select shadow.Lock@6 v@@17) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 80) (- 0 88)) (forall ((t@@26 Int) ) (!  (=> (= (select shadow.Lock@6 (ShadowableTid t@@26)) tid) (= (select thread.State@4 t@@26) (select thread.State@4 t@@26)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@27 Int) ) (!  (=> (= (select shadow.Lock@6 (ShadowableTid t@@27)) tid) (= (select thread.State@4 t@@27) (select thread.State@4 t@@27)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
)) (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (= (select thread.State@5 tid) 2) (forall ((t@@28 Int) ) (!  (=> (= (select thread.State@5 t@@28) 0) (= (select shadow.Lock@7 (ShadowableTid t@@28)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (and (not (= tid nil)) (>= tid 0))) (and (and (forall ((v@@18 T@Shadowable) ) (!  (=> (= (select shadow.Lock@6 v@@18) tid) (= (select shadow.Lock@7 v@@18) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((t@@29 Int) ) (!  (=> (= (select shadow.Lock@6 (ShadowableTid t@@29)) tid) (= (select thread.State@5 t@@29) (select thread.State@4 t@@29)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@5 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 80) (- 0 87)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 80) (- 0 86)) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (=> (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0)) (and (=> (= (ControlFlow 0 80) (- 0 85)) (not (= tid inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 80) (- 0 84)) (= (select shadow.Lock@7 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid)) (=> (= (select shadow.Lock@7 (ShadowableTid inline$AtomicAllocTid$0$uid@1)) tid) (and (=> (= (ControlFlow 0 80) (- 0 83)) (= (select shadow.Lock@7 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@7 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 80) (- 0 82)) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (=> (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0)) (and (=> (= (ControlFlow 0 80) (- 0 81)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 80) 79) inline$AtomicFork$0$anon0_correct)))))))))))))))))))))))))))))))
(let ((anon14_Then$1_correct  (and (=> (= (ControlFlow 0 94) (- 0 97)) (not (= tid inline$AtomicAllocTid$0$uid@1))) (=> (not (= tid inline$AtomicAllocTid$0$uid@1)) (and (=> (= (ControlFlow 0 94) (- 0 96)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 94) (- 0 95)) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (=> (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0)) (and (and (=> (= (ControlFlow 0 94) 80) anon14_Then_1_correct) (=> (= (ControlFlow 0 94) 61) anon14_Then$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 94) 62) anon14_Then$1_@2_Civl_UnchangedChecker_correct))))))))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= tid inline$AtomicAllocTid$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicAllocTid$0$uid@1) 0) (and (not (= inline$AtomicAllocTid$0$uid@1 nil)) (>= inline$AtomicAllocTid$0$uid@1 0))) (= thread.State@4 (store thread.State@1 inline$AtomicAllocTid$0$uid@1 1))) (and (and (= thread.ForkedBy@4 (store thread.ForkedBy@1 inline$AtomicAllocTid$0$uid@1 tid)) (= shadow.Lock@6 (store shadow.Lock@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1) tid))) (and (VCRepOk (select shadow.VC@1 (ShadowableTid inline$AtomicAllocTid$0$uid@1))) (= (ControlFlow 0 98) 94)))) anon14_Then$1_correct))))
(let ((anon14_Then_correct  (and (=> (= (ControlFlow 0 99) (- 0 101)) (forall ((t@@30 Int) ) (!  (=> (= (select thread.State@1 t@@30) 0) (= (select shadow.Lock@1 (ShadowableTid t@@30)) nil))
 :qid |verifiedftbpl.1025:20|
 :skolemid |39|
))) (=> (forall ((t@@31 Int) ) (!  (=> (= (select thread.State@1 t@@31) 0) (= (select shadow.Lock@1 (ShadowableTid t@@31)) nil))
 :qid |verifiedftbpl.1025:20|
 :skolemid |39|
)) (and (=> (= (ControlFlow 0 99) (- 0 100)) (and (= (select thread.State@1 tid) 2) (and (not (= tid nil)) (>= tid 0)))) (=> (and (= (select thread.State@1 tid) 2) (and (not (= tid nil)) (>= tid 0))) (=> (= (ControlFlow 0 99) 98) inline$AtomicAllocTid$0$anon0_correct)))))))
(let ((anon14_Else_0$1_correct  (=> (and (= shadow.Lock@15 shadow.Lock@5) (= thread.State@11 thread.State@3)) (=> (and (and (= Civl_global_old_shadow.Lock@1 shadow.Lock@4) (= Civl_global_old_thread.State@1 thread.State@3)) (and (= Civl_linear_tid_available@10 Civl_linear_tid_available@4) (= ok@1 ok@0))) (and (and (=> (= (ControlFlow 0 32) 25) anon8_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 32) 30) anon8_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 32) 31) anon8_@2_Civl_UnchangedChecker_correct))))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@5 (store shadow.Lock@4 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) nil)) (= (ControlFlow 0 33) 32)) anon14_Else_0$1_correct)))
(let ((anon14_Else_0_correct  (and (=> (= (ControlFlow 0 34) (- 0 44)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 34) (- 0 43)) (= (select thread.State@2 tid) 2)) (=> (= (select thread.State@2 tid) 2) (and (=> (= (ControlFlow 0 34) (- 0 42)) (forall ((t@@32 Int) ) (!  (=> (= (select thread.State@2 t@@32) 0) (= (select shadow.Lock@3 (ShadowableTid t@@32)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@33 Int) ) (!  (=> (= (select thread.State@2 t@@33) 0) (= (select shadow.Lock@3 (ShadowableTid t@@33)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 34) (- 0 41)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 34) (- 0 40)) (forall ((v@@19 T@Shadowable) ) (!  (=> (= (select shadow.Lock@3 v@@19) tid) (= (select shadow.Lock@3 v@@19) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@20 T@Shadowable) ) (!  (=> (= (select shadow.Lock@3 v@@20) tid) (= (select shadow.Lock@3 v@@20) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 34) (- 0 39)) (forall ((t@@34 Int) ) (!  (=> (= (select shadow.Lock@3 (ShadowableTid t@@34)) tid) (= (select thread.State@2 t@@34) (select thread.State@2 t@@34)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@35 Int) ) (!  (=> (= (select shadow.Lock@3 (ShadowableTid t@@35)) tid) (= (select thread.State@2 t@@35) (select thread.State@2 t@@35)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
)) (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (= (select thread.State@3 tid) 2) (forall ((t@@36 Int) ) (!  (=> (= (select thread.State@3 t@@36) 0) (= (select shadow.Lock@4 (ShadowableTid t@@36)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (and (not (= tid nil)) (>= tid 0))) (and (and (forall ((v@@21 T@Shadowable) ) (!  (=> (= (select shadow.Lock@3 v@@21) tid) (= (select shadow.Lock@4 v@@21) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((t@@37 Int) ) (!  (=> (= (select shadow.Lock@3 (ShadowableTid t@@37)) tid) (= (select thread.State@3 t@@37) (select thread.State@2 t@@37)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@4 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 34) (- 0 38)) (= (select shadow.Lock@4 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid)) (=> (= (select shadow.Lock@4 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid) (and (=> (= (ControlFlow 0 34) (- 0 37)) (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1))) (=> (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1)) (and (=> (= (ControlFlow 0 34) (- 0 36)) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0))) (=> (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0)) (and (=> (= (ControlFlow 0 34) (- 0 35)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 34) 33) inline$AtomicReleaseJoinLock$0$anon0_correct)))))))))))))))))))))))))
(let ((anon14_Else_1$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@3) (=> (and (and (= thread.State@12 thread.State@2) (= Civl_global_old_shadow.Lock@2 shadow.Lock@3)) (and (= Civl_global_old_thread.State@2 thread.State@2) (= Civl_linear_tid_available@11 Civl_linear_tid_available@3))) (and (and (and (=> (= (ControlFlow 0 22) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 22) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 22) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 22) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((inline$AtomicJoin$0$anon0_correct  (=> (and (and (and (Trigger_AtomicJoin_v2 inline$AtomicJoin$0$v2@1) (Trigger_AtomicJoin_v1 inline$AtomicJoin$0$v1@1)) (and (= inline$AtomicJoin$0$v1@2 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) (= inline$AtomicJoin$0$v2@2 (ShadowableTid tid)))) (and (and (= (|clock#epoch| (select (select shadow.VC@3 inline$AtomicJoin$0$v2@2) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v1@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v2@2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v2@2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v1@2) (- 0 1))))) (VCRepOk (select shadow.VC@3 inline$AtomicJoin$0$v2@2))) (and (forall ((inline$AtomicJoin$0$j Int) ) (!  (=> (<= 0 inline$AtomicJoin$0$j) (= (select (select shadow.VC@3 inline$AtomicJoin$0$v2@2) inline$AtomicJoin$0$j) (epoch (|tid#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v2@2) inline$AtomicJoin$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v2@2) inline$AtomicJoin$0$j)) (|clock#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v1@2) inline$AtomicJoin$0$j))) (|clock#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v1@2) inline$AtomicJoin$0$j)) (|clock#epoch| (select (select shadow.VC@2 inline$AtomicJoin$0$v2@2) inline$AtomicJoin$0$j))))))
 :qid |unknown.0:0|
 :skolemid |30|
)) (= shadow.VC@3 (store shadow.VC@2 inline$AtomicJoin$0$v2@2 (select shadow.VC@3 inline$AtomicJoin$0$v2@2)))))) (and (and (=> (= (ControlFlow 0 45) 34) anon14_Else_0_correct) (=> (= (ControlFlow 0 45) 22) anon14_Else_1$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 45) 23) anon14_Else_1$1_@2_Civl_UnchangedChecker_correct)))))
(let ((anon14_Else_1_correct  (and (=> (= (ControlFlow 0 46) (- 0 57)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 46) (- 0 56)) (= (select thread.State@1 tid) 2)) (=> (= (select thread.State@1 tid) 2) (and (=> (= (ControlFlow 0 46) (- 0 55)) (forall ((t@@38 Int) ) (!  (=> (= (select thread.State@1 t@@38) 0) (= (select shadow.Lock@2 (ShadowableTid t@@38)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@39 Int) ) (!  (=> (= (select thread.State@1 t@@39) 0) (= (select shadow.Lock@2 (ShadowableTid t@@39)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (and (=> (= (ControlFlow 0 46) (- 0 54)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 46) (- 0 53)) (forall ((v@@22 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@22) tid) (= (select shadow.Lock@2 v@@22) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
))) (=> (forall ((v@@23 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@23) tid) (= (select shadow.Lock@2 v@@23) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (and (=> (= (ControlFlow 0 46) (- 0 52)) (forall ((t@@40 Int) ) (!  (=> (= (select shadow.Lock@2 (ShadowableTid t@@40)) tid) (= (select thread.State@1 t@@40) (select thread.State@1 t@@40)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (=> (forall ((t@@41 Int) ) (!  (=> (= (select shadow.Lock@2 (ShadowableTid t@@41)) tid) (= (select thread.State@1 t@@41) (select thread.State@1 t@@41)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
)) (=> (and (not (= tid nil)) (>= tid 0)) (=> (and (and (and (= (select thread.State@2 tid) 2) (forall ((t@@42 Int) ) (!  (=> (= (select thread.State@2 t@@42) 0) (= (select shadow.Lock@3 (ShadowableTid t@@42)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (and (not (= tid nil)) (>= tid 0))) (and (and (forall ((v@@24 T@Shadowable) ) (!  (=> (= (select shadow.Lock@2 v@@24) tid) (= (select shadow.Lock@3 v@@24) tid))
 :qid |verifiedftbpl.173:11|
 :skolemid |9|
)) (forall ((t@@43 Int) ) (!  (=> (= (select shadow.Lock@2 (ShadowableTid t@@43)) tid) (= (select thread.State@2 t@@43) (select thread.State@1 t@@43)))
 :qid |verifiedftbpl.929:20|
 :skolemid |37|
))) (and (or false true) (= Civl_linear_tid_available@3 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false)))))) (and (=> (= (ControlFlow 0 46) (- 0 51)) (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1))) (=> (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1)) (and (=> (= (ControlFlow 0 46) (- 0 50)) (= (select shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid)) (=> (= (select shadow.Lock@3 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) tid) (and (=> (= (ControlFlow 0 46) (- 0 49)) (= (select shadow.Lock@3 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@3 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 46) (- 0 48)) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0))) (=> (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0)) (and (=> (= (ControlFlow 0 46) (- 0 47)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (=> (= (ControlFlow 0 46) 45) inline$AtomicJoin$0$anon0_correct)))))))))))))))))))))))))))
(let ((anon14_Else$1_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@2) (=> (and (and (= thread.State@12 thread.State@1) (= Civl_global_old_shadow.Lock@2 shadow.Lock@1)) (and (= Civl_global_old_thread.State@2 thread.State@1) (= Civl_linear_tid_available@11 Civl_linear_tid_available@2))) (and (and (and (=> (= (ControlFlow 0 17) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 17) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 17) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 17) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= tid inline$AtomicChooseThreadToJoin$0$uid@1)) (=> (and (and (and (= (select thread.State@1 inline$AtomicChooseThreadToJoin$0$uid@1) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@1 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@1 0))) (= (select shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1)) nil)) (and (= shadow.Lock@2 (store shadow.Lock@1 (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@1) tid)) (= thread.HasJoined@2 (store thread.HasJoined@1 tid inline$AtomicChooseThreadToJoin$0$uid@1 true)))) (and (and (=> (= (ControlFlow 0 58) 46) anon14_Else_1_correct) (=> (= (ControlFlow 0 58) 17) anon14_Else$1_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 58) 21) anon14_Else$1_@2_Civl_UnchangedChecker_correct))))))
(let ((anon14_Else_correct  (and (=> (= (ControlFlow 0 59) (- 0 60)) (and (= (select thread.State@1 tid) 2) (and (not (= tid nil)) (>= tid 0)))) (=> (and (= (select thread.State@1 tid) 2) (and (not (= tid nil)) (>= tid 0))) (=> (= (ControlFlow 0 59) 58) inline$AtomicChooseThreadToJoin$0$anon0_correct)))))
(let ((anon9_LoopBody_correct  (=> ok@0 (and (and (and (and (and (=> (= (ControlFlow 0 172) 170) anon10_Then_correct) (=> (= (ControlFlow 0 172) 159) anon11_Then_correct)) (=> (= (ControlFlow 0 172) 149) anon12_Then_correct)) (=> (= (ControlFlow 0 172) 132) anon13_Then_correct)) (=> (= (ControlFlow 0 172) 99) anon14_Then_correct)) (=> (= (ControlFlow 0 172) 59) anon14_Else_correct)))))
(let ((anon9_LoopHead_correct  (=> (or false true) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock@1 (ShadowableTid tid)) tid)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select thread.State@1 tid) 2)) (and (forall ((t@@44 Int) ) (!  (=> (= (select thread.State@1 t@@44) 0) (= (select shadow.Lock@1 (ShadowableTid t@@44)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (= Civl_linear_tid_available@2 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (=> (= (ControlFlow 0 179) 178) anon9_LoopDone_correct) (=> (= (ControlFlow 0 179) 172) anon9_LoopBody_correct)))))))
(let ((anon0_@2_anon9_LoopHead_correct  (and (=> (= (ControlFlow 0 180) (- 0 185)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 180) (- 0 184)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (= (select shadow.Lock@0 (ShadowableTid tid)) tid) (and (=> (= (ControlFlow 0 180) (- 0 183)) (and (not (= tid nil)) (>= tid 0))) (=> (and (not (= tid nil)) (>= tid 0)) (and (=> (= (ControlFlow 0 180) (- 0 182)) (= (select thread.State@0 tid) 2)) (=> (= (select thread.State@0 tid) 2) (and (=> (= (ControlFlow 0 180) (- 0 181)) (forall ((t@@45 Int) ) (!  (=> (= (select thread.State@0 t@@45) 0) (= (select shadow.Lock@0 (ShadowableTid t@@45)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
))) (=> (forall ((t@@46 Int) ) (!  (=> (= (select thread.State@0 t@@46) 0) (= (select shadow.Lock@0 (ShadowableTid t@@46)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (=> (= (ControlFlow 0 180) 179) anon9_LoopHead_correct)))))))))))))
(let ((anon0_@2_Civl_NoninterferenceChecker_correct  (=> (= shadow.Lock@16 shadow.Lock@0) (=> (and (and (= thread.State@12 thread.State@0) (= Civl_global_old_shadow.Lock@2 shadow.Lock@0)) (and (= Civl_global_old_thread.State@2 thread.State@0) (= Civl_linear_tid_available@11 Civl_linear_tid_available@0))) (and (and (and (=> (= (ControlFlow 0 16) 5) inline$Civl_NoninterferenceChecker_yield_Yield_Preserved_30$0$L0_correct) (=> (= (ControlFlow 0 16) 8) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 16) 10) inline$Civl_NoninterferenceChecker_yield_Yield_ThreadState_30$0$L0_correct)) (=> (= (ControlFlow 0 16) 14) inline$Civl_NoninterferenceChecker_yield_Yield_Lock_30$0$L0_correct))))))
(let ((Civl_RefinementChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) true) (=> (= (ControlFlow 0 2) (- 0 1)) (=> false (= true ok))))))
(let ((anon0_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock@0 (ShadowableTid tid)) tid)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select thread.State@0 tid) 2)) (and (forall ((t@@47 Int) ) (!  (=> (= (select thread.State@0 t@@47) 0) (= (select shadow.Lock@0 (ShadowableTid t@@47)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (= Civl_linear_tid_available@0 ((_ map or) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Bool)) false))))) (and (and (=> (= (ControlFlow 0 186) 180) anon0_@2_anon9_LoopHead_correct) (=> (= (ControlFlow 0 186) 16) anon0_@2_Civl_NoninterferenceChecker_correct)) (=> (= (ControlFlow 0 186) 2) Civl_RefinementChecker_correct))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (select shadow.Lock (ShadowableTid tid)) tid)) (=> (and (and (and (not (= tid nil)) (>= tid 0)) (= (select thread.State tid) 2)) (and (forall ((t@@48 Int) ) (!  (=> (= (select thread.State t@@48) 0) (= (select shadow.Lock (ShadowableTid t@@48)) nil))
 :qid |verifiedftbpl.924:20|
 :skolemid |36|
)) (= (ControlFlow 0 187) 186))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun x@@0 () T@Var)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicAcquireVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicAcquireVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicAcquireVarLock$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableVar x@@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar x@@0) tid)) (= (ControlFlow 0 3) 2)) inline$AtomicAcquireVarLock$0$Return_correct))))
(let ((inline$AtomicAcquireVarLock$0$Entry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicAcquireVarLock$0$anon0_correct)))
inline$AtomicAcquireVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun x@@0 () T@Var)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicReleaseVarLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseVarLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicReleaseVarLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableVar x@@0) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseVarLock$0$Return_correct)))
(let ((inline$AtomicReleaseVarLock$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseVarLock$0$anon0_correct))))
inline$AtomicReleaseVarLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicThreadStateGetE$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicThreadStateGetE)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicThreadStateGetE$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicThreadStateGetE$0$anon0_correct  (=> (and (= inline$AtomicThreadStateGetE$0$e@1 (select (select shadow.VC@@0 (ShadowableTid tid)) tid)) (= (ControlFlow 0 3) 2)) inline$AtomicThreadStateGetE$0$Return_correct)))
(let ((inline$AtomicThreadStateGetE$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableTid tid)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicThreadStateGetE$0$anon0_correct))))
inline$AtomicThreadStateGetE$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(declare-fun e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateSetW)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateSetW$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateSetW$0$anon0_correct  (=> (and (= sx.W@0 (store sx.W x@@0 e)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetW$0$Return_correct)))
(let ((inline$AtomicVarStateSetW$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetW$0$anon0_correct))))
inline$AtomicVarStateSetW$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicVarStateGetW$0$e@1 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetW)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetW$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetW$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetW$0$e@1 (select sx.W x@@0)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetW$0$Return_correct)))
(let ((inline$AtomicVarStateGetW$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetW$0$anon0_correct))))
inline$AtomicVarStateGetW$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicVarStateGetWNoLock$0$e@1 () T@Epoch)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetWNoLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetWNoLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetWNoLock$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetWNoLock$0$e@1 (select sx.W x@@0)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetWNoLock$0$Return_correct)))
(let ((inline$AtomicVarStateGetWNoLock$0$Entry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetWNoLock$0$anon0_correct)))
inline$AtomicVarStateGetWNoLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(declare-fun e () T@Epoch)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateSetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateSetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateSetR$0$anon0_correct  (=> (and (= sx.R@0 (store sx.R x@@0 e)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateSetR$0$Return_correct)))
(let ((inline$AtomicVarStateSetR$0$Entry_correct  (=> (and (not (= (select sx.R x@@0) SHARED)) (= (select shadow.Lock (ShadowableVar x@@0)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateSetR$0$anon0_correct))))
inline$AtomicVarStateSetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicVarStateGetRNoLock$0$e@1 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetRNoLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetRNoLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetRNoLock$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetRNoLock$0$e@1 (select sx.R x@@0)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetRNoLock$0$Return_correct)))
(let ((inline$AtomicVarStateGetRNoLock$0$Entry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetRNoLock$0$anon0_correct)))
inline$AtomicVarStateGetRNoLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicVarStateGetR$0$e@1 () T@Epoch)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetR)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetR$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetR$0$anon0_correct  (=> (and (= inline$AtomicVarStateGetR$0$e@1 (select sx.R x@@0)) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetR$0$Return_correct)))
(let ((inline$AtomicVarStateGetR$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetR$0$anon0_correct))))
inline$AtomicVarStateGetR$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVarStateGetRShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVarStateGetRShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVarStateGetRShared$0$anon0_correct  (=> (and (= (select sx.R x@@0) SHARED) (= (ControlFlow 0 3) 2)) inline$AtomicVarStateGetRShared$0$Return_correct)))
(let ((inline$AtomicVarStateGetRShared$0$Entry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVarStateGetRShared$0$anon0_correct)))
inline$AtomicVarStateGetRShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicVCGetSize$0$i@1 () Int)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun r@@0 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCGetSize)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCGetSize$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCGetSize$0$anon0_correct  (=> (and (= inline$AtomicVCGetSize$0$i@1 (|clock#epoch| (select (select shadow.VC@@0 r@@0) (- 0 1)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetSize$0$Return_correct)))
(let ((inline$AtomicVCGetSize$0$Entry_correct  (=> (= (select shadow.Lock r@@0) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetSize$0$anon0_correct))))
inline$AtomicVCGetSize$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicVCGetElem$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun r@@0 () T@Shadowable)
(declare-fun i@@1 () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCGetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCGetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCGetElem$0$anon0_correct  (=> (and (= inline$AtomicVCGetElem$0$e@1 (select (select shadow.VC@@0 r@@0) i@@1)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElem$0$Return_correct)))
(let ((inline$AtomicVCGetElem$0$Entry_correct  (=> (= (select shadow.Lock r@@0) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVCGetElem$0$anon0_correct))))
inline$AtomicVCGetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicVCGetElemShared$0$e@1 () T@Epoch)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun x@@0 () T@Var)
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCGetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCGetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCGetElemShared$0$anon0_correct  (=> (and (= inline$AtomicVCGetElemShared$0$e@1 (select (select shadow.VC@@0 (ShadowableVar x@@0)) tid)) (= (ControlFlow 0 3) 2)) inline$AtomicVCGetElemShared$0$Return_correct)))
(let ((inline$AtomicVCGetElemShared$0$Entry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (and (= (select sx.R x@@0) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCGetElemShared$0$anon0_correct)))
inline$AtomicVCGetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun x@@0 () T@Var)
(declare-fun e () T@Epoch)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCSetElemShared)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElemShared$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCSetElemShared$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 (ShadowableVar x@@0) (store (select shadow.VC@@0 (ShadowableVar x@@0)) tid e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 (ShadowableVar x@@0) (store (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@0 (ShadowableVar x@@0)) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElemShared$0$Return_correct))))
(let ((inline$AtomicVCSetElemShared$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableVar x@@0)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (= (select sx.R x@@0) SHARED) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElemShared$0$anon0_correct))))
inline$AtomicVCSetElemShared$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun r@@0 () T@Shadowable)
(declare-fun i@@1 () Int)
(declare-fun e () T@Epoch)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCSetElem)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCSetElem$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCSetElem$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 r@@0 (store (select shadow.VC@@0 r@@0) i@@1 e))) (=> (and (= shadow.VC@1 (store shadow.VC@0 r@@0 (store (select shadow.VC@0 r@@0) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 r@@0) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@0 r@@0) (- 0 1)))))))) (= (ControlFlow 0 3) 2)) inline$AtomicVCSetElem$0$Return_correct))))
(let ((inline$AtomicVCSetElem$0$Entry_correct  (=> (= (select shadow.Lock r@@0) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (and (=> (is-ShadowableVar r@@0) (not (= (select sx.R (|x#ShadowableVar| r@@0)) SHARED))) (= (ControlFlow 0 4) 3))) inline$AtomicVCSetElem$0$anon0_correct))))
inline$AtomicVCSetElem$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun r@@0 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun sx.R () (Array T@Var T@Epoch))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVCInit)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVCInit$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVCInit$0$anon0_correct  (=> (and (= shadow.VC@0 (store shadow.VC@@0 r@@0 (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= (ControlFlow 0 3) 2)) inline$AtomicVCInit$0$Return_correct)))
(let ((inline$AtomicVCInit$0$Entry_correct  (=> (and (= (select shadow.Lock r@@0) tid) (=> (is-ShadowableVar r@@0) (not (= (select sx.R (|x#ShadowableVar| r@@0)) SHARED)))) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicVCInit$0$anon0_correct))))
inline$AtomicVCInit$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicVC.Leq$0$res@1 () Bool)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v1 () T@Shadowable)
(declare-fun v2 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVC.Leq)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Leq$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVC.Leq$0$anon0_correct  (=> (and (= inline$AtomicVC.Leq$0$res@1 (forall ((inline$AtomicVC.Leq$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicVC.Leq$0$j) (f inline$AtomicVC.Leq$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 v1) inline$AtomicVC.Leq$0$j)) (|tid#epoch| (select (select shadow.VC@@0 v2) inline$AtomicVC.Leq$0$j))) (<= (|clock#epoch| (select (select shadow.VC@@0 v1) inline$AtomicVC.Leq$0$j)) (|clock#epoch| (select (select shadow.VC@@0 v2) inline$AtomicVC.Leq$0$j)))))
 :qid |unknown.0:0|
 :skolemid |15|
 :pattern ( (f inline$AtomicVC.Leq$0$j))
))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Leq$0$Return_correct)))
(let ((inline$AtomicVC.Leq$0$Entry_correct  (=> (not (is-ShadowableVar v2)) (=> (and (and (and (=> (is-ShadowableVar v1) (= (select sx.R (|x#ShadowableVar| v1)) SHARED)) (= (select shadow.Lock (ShadowableTid tid)) tid)) (and (= (select shadow.Lock v2) tid) (= (select shadow.Lock v1) tid))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Leq$0$anon0_correct))))
inline$AtomicVC.Leq$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v1 () T@Shadowable)
(declare-fun v2 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVC.Copy)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 5) (let ((inline$AtomicVC.Copy$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVC.Copy$0$anon3_Else_correct  (=> (and (= shadow.VC@1 (store shadow.VC@@0 v1 (select shadow.VC@@0 v2))) (= (ControlFlow 0 4) 2)) inline$AtomicVC.Copy$0$Return_correct)))
(let ((inline$AtomicVC.Copy$0$anon3_Then_correct  (=> (VCRepOk (select shadow.VC@0 v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 v1) (- 0 1))))) (forall ((inline$AtomicVC.Copy$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Copy$0$j) (= (select (select shadow.VC@0 v1) inline$AtomicVC.Copy$0$j) (select (select shadow.VC@@0 v2) inline$AtomicVC.Copy$0$j)))
 :qid |unknown.0:0|
 :skolemid |17|
))) (and (= shadow.VC@0 (store shadow.VC@@0 v1 (select shadow.VC@0 v1))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Copy$0$Return_correct))))
(let ((inline$AtomicVC.Copy$0$Entry_correct  (=> (and (VCRepOk (select shadow.VC@@0 v1)) (VCRepOk (select shadow.VC@@0 v2))) (=> (and (and (and (not (is-ShadowableVar v2)) (not (is-ShadowableVar v1))) (and (= (select shadow.Lock v2) tid) (= (select shadow.Lock v1) tid))) (and (and (= (select shadow.Lock (ShadowableTid tid)) tid) (not (= v1 v2))) (and (not (= tid nil)) (>= tid 0)))) (and (=> (= (ControlFlow 0 5) 3) inline$AtomicVC.Copy$0$anon3_Then_correct) (=> (= (ControlFlow 0 5) 4) inline$AtomicVC.Copy$0$anon3_Else_correct))))))
inline$AtomicVC.Copy$0$Entry_correct)))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v2 () T@Shadowable)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVC.Join)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Join$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVC.Join$0$anon0_correct  (=> (VCRepOk (select shadow.VC@0 v1)) (=> (and (and (= (|clock#epoch| (select (select shadow.VC@0 v1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 v1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 v2) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 v2) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 v1) (- 0 1))))) (forall ((inline$AtomicVC.Join$0$j Int) ) (!  (=> (<= 0 inline$AtomicVC.Join$0$j) (= (select (select shadow.VC@0 v1) inline$AtomicVC.Join$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 v1) inline$AtomicVC.Join$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 v1) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 v2) inline$AtomicVC.Join$0$j))) (|clock#epoch| (select (select shadow.VC@@0 v2) inline$AtomicVC.Join$0$j)) (|clock#epoch| (select (select shadow.VC@@0 v1) inline$AtomicVC.Join$0$j))))))
 :qid |unknown.0:0|
 :skolemid |22|
))) (and (= shadow.VC@0 (store shadow.VC@@0 v1 (select shadow.VC@0 v1))) (= (ControlFlow 0 3) 2))) inline$AtomicVC.Join$0$Return_correct))))
(let ((inline$AtomicVC.Join$0$Entry_correct  (=> (VCRepOk (select shadow.VC@@0 v2)) (=> (and (not (is-ShadowableVar v2)) (not (is-ShadowableVar v1))) (=> (and (and (and (= (select shadow.Lock v2) tid) (= (select shadow.Lock v1) tid)) (and (= (select shadow.Lock (ShadowableTid tid)) tid) (not (= v1 v2)))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Join$0$anon0_correct)))))
inline$AtomicVC.Join$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun v@@1 () T@Shadowable)
(declare-fun i@@1 () Int)
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicVC.Inc)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicVC.Inc$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicVC.Inc$0$anon0_correct  (=> (= shadow.VC@0 (store shadow.VC@@0 v@@1 (store (select shadow.VC@@0 v@@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@@0 v@@1) (- 0 1))) (+ i@@1 1)) (+ i@@1 1) (|clock#epoch| (select (select shadow.VC@@0 v@@1) (- 0 1)))))))) (=> (and (= shadow.VC@1 (store shadow.VC@0 v@@1 (store (select shadow.VC@0 v@@1) i@@1 (epoch (|tid#epoch| (select (select shadow.VC@0 v@@1) i@@1)) (+ (|clock#epoch| (select (select shadow.VC@0 v@@1) i@@1)) 1))))) (= (ControlFlow 0 3) 2)) inline$AtomicVC.Inc$0$Return_correct))))
(let ((inline$AtomicVC.Inc$0$Entry_correct  (=> (VCRepOk (select shadow.VC@@0 v@@1)) (=> (and (and (and (>= i@@1 0) (not (is-ShadowableVar v@@1))) (and (= (select shadow.Lock v@@1) tid) (= (select shadow.Lock (ShadowableTid tid)) tid))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicVC.Inc$0$anon0_correct))))
inline$AtomicVC.Inc$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun Trigger_AtomicFork_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicFork$0$v2@0 () T@Shadowable)
(declare-fun Trigger_AtomicFork_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicFork$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicFork$0$v1@1 () T@Shadowable)
(declare-fun uid () Int)
(declare-fun inline$AtomicFork$0$v2@1 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicFork)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicFork$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicFork$0$anon0_correct  (=> (Trigger_AtomicFork_v2 inline$AtomicFork$0$v2@0) (=> (and (and (Trigger_AtomicFork_v1 inline$AtomicFork$0$v1@0) (= inline$AtomicFork$0$v1@1 (ShadowableTid uid))) (and (= inline$AtomicFork$0$v2@1 (ShadowableTid tid)) (= (|clock#epoch| (select (select shadow.VC@0 inline$AtomicFork$0$v1@1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v1@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v2@1) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v2@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v1@1) (- 0 1))))))) (=> (and (and (and (VCRepOk (select shadow.VC@0 inline$AtomicFork$0$v1@1)) (forall ((inline$AtomicFork$0$j Int) ) (!  (=> (<= 0 inline$AtomicFork$0$j) (= (select (select shadow.VC@0 inline$AtomicFork$0$v1@1) inline$AtomicFork$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v1@1) inline$AtomicFork$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v1@1) inline$AtomicFork$0$j)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v2@1) inline$AtomicFork$0$j))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v2@1) inline$AtomicFork$0$j)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v1@1) inline$AtomicFork$0$j))))))
 :qid |unknown.0:0|
 :skolemid |28|
))) (and (VCRepOk (select shadow.VC@0 inline$AtomicFork$0$v2@1)) (= (|clock#epoch| (select (select shadow.VC@0 inline$AtomicFork$0$v2@1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicFork$0$v2@1) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicFork$0$v2@1) (- 0 1))))))) (and (and (forall ((inline$AtomicFork$0$j@@0 Int) ) (!  (=> (and (<= 0 inline$AtomicFork$0$j@@0) (not (= inline$AtomicFork$0$j@@0 tid))) (= (select (select shadow.VC@0 inline$AtomicFork$0$v2@1) inline$AtomicFork$0$j@@0) (select (select shadow.VC@@0 inline$AtomicFork$0$v2@1) inline$AtomicFork$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |29|
)) (= (select (select shadow.VC@0 inline$AtomicFork$0$v2@1) tid) (epoch (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v2@1) tid)) (+ (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicFork$0$v2@1) tid)) 1)))) (and (= shadow.VC@0 (store (store shadow.VC@@0 inline$AtomicFork$0$v1@1 (select shadow.VC@0 inline$AtomicFork$0$v1@1)) inline$AtomicFork$0$v2@1 (select shadow.VC@0 inline$AtomicFork$0$v2@1))) (= (ControlFlow 0 3) 2)))) inline$AtomicFork$0$Return_correct)))))
(let ((inline$AtomicFork$0$Entry_correct  (=> (not (= tid uid)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid uid)) tid) (= (select shadow.Lock (ShadowableTid tid)) tid)) (and (not (= uid nil)) (>= uid 0))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicFork$0$anon0_correct))))
inline$AtomicFork$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun Trigger_AtomicJoin_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicJoin$0$v2@0 () T@Shadowable)
(declare-fun Trigger_AtomicJoin_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicJoin$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicJoin$0$v1@1 () T@Shadowable)
(declare-fun uid () Int)
(declare-fun inline$AtomicJoin$0$v2@1 () T@Shadowable)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicJoin$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicJoin$0$anon0_correct  (=> (Trigger_AtomicJoin_v2 inline$AtomicJoin$0$v2@0) (=> (and (and (and (Trigger_AtomicJoin_v1 inline$AtomicJoin$0$v1@0) (= inline$AtomicJoin$0$v1@1 (ShadowableTid uid))) (and (= inline$AtomicJoin$0$v2@1 (ShadowableTid tid)) (= (|clock#epoch| (select (select shadow.VC@0 inline$AtomicJoin$0$v2@1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v1@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v2@1) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v2@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v1@1) (- 0 1))))))) (and (and (VCRepOk (select shadow.VC@0 inline$AtomicJoin$0$v2@1)) (forall ((inline$AtomicJoin$0$j Int) ) (!  (=> (<= 0 inline$AtomicJoin$0$j) (= (select (select shadow.VC@0 inline$AtomicJoin$0$v2@1) inline$AtomicJoin$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v2@1) inline$AtomicJoin$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v2@1) inline$AtomicJoin$0$j)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v1@1) inline$AtomicJoin$0$j))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v1@1) inline$AtomicJoin$0$j)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicJoin$0$v2@1) inline$AtomicJoin$0$j))))))
 :qid |unknown.0:0|
 :skolemid |30|
))) (and (= shadow.VC@0 (store shadow.VC@@0 inline$AtomicJoin$0$v2@1 (select shadow.VC@0 inline$AtomicJoin$0$v2@1))) (= (ControlFlow 0 3) 2)))) inline$AtomicJoin$0$Return_correct))))
(let ((inline$AtomicJoin$0$Entry_correct  (=> (not (= tid uid)) (=> (and (and (and (= (select shadow.Lock (ShadowableTid uid)) tid) (= (select shadow.Lock (ShadowableTid tid)) tid)) (and (not (= uid nil)) (>= uid 0))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicJoin$0$anon0_correct))))
inline$AtomicJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun Trigger_AtomicAcquire_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicAcquire$0$v2@0 () T@Shadowable)
(declare-fun Trigger_AtomicAcquire_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicAcquire$0$v1@0 () T@Shadowable)
(declare-fun inline$AtomicAcquire$0$v1@1 () T@Shadowable)
(declare-fun inline$AtomicAcquire$0$v2@1 () T@Shadowable)
(declare-fun l () T@Lock)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicAcquire$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicAcquire$0$anon0_correct  (=> (Trigger_AtomicAcquire_v2 inline$AtomicAcquire$0$v2@0) (=> (and (and (and (Trigger_AtomicAcquire_v1 inline$AtomicAcquire$0$v1@0) (= inline$AtomicAcquire$0$v1@1 (ShadowableTid tid))) (and (= inline$AtomicAcquire$0$v2@1 (ShadowableLock l)) (VCRepOk (select shadow.VC@0 inline$AtomicAcquire$0$v1@1)))) (and (and (= (|clock#epoch| (select (select shadow.VC@0 inline$AtomicAcquire$0$v1@1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v1@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v2@1) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v2@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v1@1) (- 0 1))))) (forall ((inline$AtomicAcquire$0$j Int) ) (!  (=> (<= 0 inline$AtomicAcquire$0$j) (= (select (select shadow.VC@0 inline$AtomicAcquire$0$v1@1) inline$AtomicAcquire$0$j) (epoch (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v1@1) inline$AtomicAcquire$0$j)) (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v1@1) inline$AtomicAcquire$0$j)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v2@1) inline$AtomicAcquire$0$j))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v2@1) inline$AtomicAcquire$0$j)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicAcquire$0$v1@1) inline$AtomicAcquire$0$j))))))
 :qid |unknown.0:0|
 :skolemid |31|
))) (and (= shadow.VC@0 (store shadow.VC@@0 inline$AtomicAcquire$0$v1@1 (select shadow.VC@0 inline$AtomicAcquire$0$v1@1))) (= (ControlFlow 0 3) 2)))) inline$AtomicAcquire$0$Return_correct))))
(let ((inline$AtomicAcquire$0$Entry_correct  (=> (and (= (select shadow.Lock (ShadowableTid tid)) tid) (= (select shadow.Lock (ShadowableLock l)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicAcquire$0$anon0_correct))))
inline$AtomicAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRelease$0$v2@1 () T@Shadowable)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRelease$0$v1@1 () T@Shadowable)
(declare-fun Trigger_AtomicRelease_v2 (T@Shadowable) Bool)
(declare-fun inline$AtomicRelease$0$v2@0 () T@Shadowable)
(declare-fun Trigger_AtomicRelease_v1 (T@Shadowable) Bool)
(declare-fun inline$AtomicRelease$0$v1@0 () T@Shadowable)
(declare-fun l () T@Lock)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicRelease)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 7) (let ((inline$AtomicRelease$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicRelease$0$anon3_correct  (=> (and (VCRepOk (select shadow.VC@0 inline$AtomicRelease$0$v2@1)) (= (|clock#epoch| (select (select shadow.VC@0 inline$AtomicRelease$0$v2@1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicRelease$0$v2@1) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicRelease$0$v2@1) (- 0 1)))))) (=> (and (and (forall ((inline$AtomicRelease$0$j Int) ) (!  (=> (and (<= 0 inline$AtomicRelease$0$j) (not (= inline$AtomicRelease$0$j tid))) (= (select (select shadow.VC@0 inline$AtomicRelease$0$v2@1) inline$AtomicRelease$0$j) (select (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) inline$AtomicRelease$0$j)))
 :qid |unknown.0:0|
 :skolemid |33|
)) (= (select (select shadow.VC@0 inline$AtomicRelease$0$v2@1) tid) (epoch (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) tid)) (+ (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) tid)) 1)))) (and (= shadow.VC@0 (store (store shadow.VC@@0 inline$AtomicRelease$0$v1@1 (select shadow.VC@0 inline$AtomicRelease$0$v1@1)) inline$AtomicRelease$0$v2@1 (select shadow.VC@0 inline$AtomicRelease$0$v2@1))) (= (ControlFlow 0 3) 2))) inline$AtomicRelease$0$Return_correct))))
(let ((inline$AtomicRelease$0$anon4_Else_correct  (=> (and (= (select shadow.VC@0 inline$AtomicRelease$0$v1@1) (select shadow.VC@@0 inline$AtomicRelease$0$v2@1)) (= (ControlFlow 0 5) 3)) inline$AtomicRelease$0$anon3_correct)))
(let ((inline$AtomicRelease$0$anon4_Then_correct  (=> (and (and (VCRepOk (select shadow.VC@0 inline$AtomicRelease$0$v1@1)) (= (|clock#epoch| (select (select shadow.VC@0 inline$AtomicRelease$0$v1@1) (- 0 1))) (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRelease$0$v1@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRelease$0$v1@1) (- 0 1)))))) (and (forall ((inline$AtomicRelease$0$j@@0 Int) ) (!  (=> (<= 0 inline$AtomicRelease$0$j@@0) (= (select (select shadow.VC@0 inline$AtomicRelease$0$v1@1) inline$AtomicRelease$0$j@@0) (select (select shadow.VC@@0 inline$AtomicRelease$0$v2@1) inline$AtomicRelease$0$j@@0)))
 :qid |unknown.0:0|
 :skolemid |32|
)) (= (ControlFlow 0 4) 3))) inline$AtomicRelease$0$anon3_correct)))
(let ((inline$AtomicRelease$0$anon0_correct  (=> (and (and (Trigger_AtomicRelease_v2 inline$AtomicRelease$0$v2@0) (Trigger_AtomicRelease_v1 inline$AtomicRelease$0$v1@0)) (and (= inline$AtomicRelease$0$v1@1 (ShadowableLock l)) (= inline$AtomicRelease$0$v2@1 (ShadowableTid tid)))) (and (=> (= (ControlFlow 0 6) 4) inline$AtomicRelease$0$anon4_Then_correct) (=> (= (ControlFlow 0 6) 5) inline$AtomicRelease$0$anon4_Else_correct)))))
(let ((inline$AtomicRelease$0$Entry_correct  (=> (and (= (select shadow.Lock (ShadowableLock l)) tid) (= (select shadow.Lock (ShadowableTid tid)) tid)) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 7) 6)) inline$AtomicRelease$0$anon0_correct))))
inline$AtomicRelease$0$Entry_correct)))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicWrite$0$st@1 () T@Shadowable)
(declare-fun inline$AtomicWrite$0$sx@1 () T@Shadowable)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun sx.W@1 () (Array T@Var T@Epoch))
(declare-fun sx.W@0 () (Array T@Var T@Epoch))
(declare-fun Trigger_AtomicWrite_sx (T@Shadowable) Bool)
(declare-fun inline$AtomicWrite$0$sx@0 () T@Shadowable)
(declare-fun Trigger_AtomicWrite_st (T@Shadowable) Bool)
(declare-fun inline$AtomicWrite$0$st@0 () T@Shadowable)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicWrite)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 10) (let ((inline$AtomicWrite$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicWrite$0$SharedWriteRace_correct  (=> (= (select sx.R x@@0) SHARED) (=> (and (not (forall ((inline$AtomicWrite$0$j Int) ) (!  (=> (and (and (<= 0 inline$AtomicWrite$0$j) (< inline$AtomicWrite$0$j (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (- 0 1)))))) (f inline$AtomicWrite$0$j)) (and (= (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) inline$AtomicWrite$0$j)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) inline$AtomicWrite$0$j))) (<= (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) inline$AtomicWrite$0$j)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) inline$AtomicWrite$0$j)))))
 :qid |unknown.0:0|
 :skolemid |35|
 :pattern ( (f inline$AtomicWrite$0$j))
))) (= (ControlFlow 0 8) 2)) inline$AtomicWrite$0$Return_correct))))
(let ((inline$AtomicWrite$0$ReadWriteRace_correct  (=> (not (= (select sx.R x@@0) SHARED)) (=> (and (not (and (= (|tid#epoch| (select sx.R x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.R x@@0))))) (<= (|clock#epoch| (select sx.R x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.R x@@0))))))) (= (ControlFlow 0 7) 2)) inline$AtomicWrite$0$Return_correct))))
(let ((inline$AtomicWrite$0$WriteWriteRace_correct  (=> (and (not (and (= (|tid#epoch| (select sx.W x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@0))))) (<= (|clock#epoch| (select sx.W x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@0))))))) (= (ControlFlow 0 6) 2)) inline$AtomicWrite$0$Return_correct)))
(let ((inline$AtomicWrite$0$WritedShared_correct  (=> (and (= (|tid#epoch| (select sx.W x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@0))))) (<= (|clock#epoch| (select sx.W x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@0)))))) (=> (and (and (= (select sx.R x@@0) SHARED) (forall ((inline$AtomicWrite$0$j@@0 Int) ) (!  (=> (and (and (<= 0 inline$AtomicWrite$0$j@@0) (< inline$AtomicWrite$0$j@@0 (ite (< (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (- 0 1)))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (- 0 1))) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) (- 0 1)))))) (f inline$AtomicWrite$0$j@@0)) (and (= (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) inline$AtomicWrite$0$j@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) inline$AtomicWrite$0$j@@0))) (<= (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$sx@1) inline$AtomicWrite$0$j@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) inline$AtomicWrite$0$j@@0)))))
 :qid |unknown.0:0|
 :skolemid |34|
 :pattern ( (f inline$AtomicWrite$0$j@@0))
))) (and (= sx.W@1 (store sx.W x@@0 (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) tid))) (= (ControlFlow 0 5) 2))) inline$AtomicWrite$0$Return_correct))))
(let ((inline$AtomicWrite$0$WriteExclusive_correct  (=> (and (and (and (= (|tid#epoch| (select sx.W x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@0))))) (<= (|clock#epoch| (select sx.W x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.W x@@0)))))) (not (= (select sx.R x@@0) SHARED))) (and (and (= (|tid#epoch| (select sx.R x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.R x@@0))))) (<= (|clock#epoch| (select sx.R x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) (|tid#epoch| (select sx.R x@@0)))))) (and (= sx.W@0 (store sx.W x@@0 (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) tid))) (= (ControlFlow 0 4) 2)))) inline$AtomicWrite$0$Return_correct)))
(let ((inline$AtomicWrite$0$WriteFastPath_correct  (=> (and (= (select sx.W x@@0) (select (select shadow.VC@@0 inline$AtomicWrite$0$st@1) tid)) (= (ControlFlow 0 3) 2)) inline$AtomicWrite$0$Return_correct)))
(let ((inline$AtomicWrite$0$anon0_correct  (=> (and (and (Trigger_AtomicWrite_sx inline$AtomicWrite$0$sx@0) (Trigger_AtomicWrite_st inline$AtomicWrite$0$st@0)) (and (= inline$AtomicWrite$0$st@1 (ShadowableTid tid)) (= inline$AtomicWrite$0$sx@1 (ShadowableVar x@@0)))) (and (and (and (and (and (=> (= (ControlFlow 0 9) 3) inline$AtomicWrite$0$WriteFastPath_correct) (=> (= (ControlFlow 0 9) 4) inline$AtomicWrite$0$WriteExclusive_correct)) (=> (= (ControlFlow 0 9) 5) inline$AtomicWrite$0$WritedShared_correct)) (=> (= (ControlFlow 0 9) 6) inline$AtomicWrite$0$WriteWriteRace_correct)) (=> (= (ControlFlow 0 9) 7) inline$AtomicWrite$0$ReadWriteRace_correct)) (=> (= (ControlFlow 0 9) 8) inline$AtomicWrite$0$SharedWriteRace_correct)))))
(let ((inline$AtomicWrite$0$Entry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 10) 9)) inline$AtomicWrite$0$anon0_correct)))
inline$AtomicWrite$0$Entry_correct))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun sx.W () (Array T@Var T@Epoch))
(declare-fun x@@0 () T@Var)
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRead$0$st@1 () T@Shadowable)
(declare-fun sx.R () (Array T@Var T@Epoch))
(declare-fun shadow.VC@2 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun inline$AtomicRead$0$sx@1 () T@Shadowable)
(declare-fun shadow.VC@3 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@4 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@5 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@1 () (Array T@Var T@Epoch))
(declare-fun shadow.VC@0 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun shadow.VC@1 () (Array T@Shadowable (Array Int T@Epoch)))
(declare-fun sx.R@0 () (Array T@Var T@Epoch))
(declare-fun Trigger_AtomicRead_sx (T@Shadowable) Bool)
(declare-fun inline$AtomicRead$0$sx@0 () T@Shadowable)
(declare-fun Trigger_AtomicRead_st (T@Shadowable) Bool)
(declare-fun inline$AtomicRead$0$st@0 () T@Shadowable)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicRead)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 10) (let ((inline$AtomicRead$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicRead$0$WriteReadRace_correct  (=> (and (not (and (= (|tid#epoch| (select sx.W x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@0))))) (<= (|clock#epoch| (select sx.W x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@0))))))) (= (ControlFlow 0 8) 2)) inline$AtomicRead$0$Return_correct)))
(let ((inline$AtomicRead$0$ReadShare_correct  (=> (not (= (select sx.R x@@0) SHARED)) (=> (and (and (and (= (|tid#epoch| (select sx.W x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@0))))) (<= (|clock#epoch| (select sx.W x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@0)))))) (and (= shadow.VC@2 (store shadow.VC@@0 inline$AtomicRead$0$sx@1 (store EMPTY_MAP (- 0 1) (epoch (- 0 1) 0)))) (= shadow.VC@3 (store shadow.VC@2 inline$AtomicRead$0$sx@1 (store (select shadow.VC@2 inline$AtomicRead$0$sx@1) (|tid#epoch| (select sx.R x@@0)) (select sx.R x@@0)))))) (and (and (= shadow.VC@4 (store shadow.VC@3 inline$AtomicRead$0$sx@1 (store (select shadow.VC@3 inline$AtomicRead$0$sx@1) tid (select (select shadow.VC@3 inline$AtomicRead$0$st@1) tid)))) (= shadow.VC@5 (store shadow.VC@4 inline$AtomicRead$0$sx@1 (store (select shadow.VC@4 inline$AtomicRead$0$sx@1) (- 0 1) (epoch (- 0 1) (ite (< (+ (|tid#epoch| (select sx.R x@@0)) 1) (+ tid 1)) (+ tid 1) (+ (|tid#epoch| (select sx.R x@@0)) 1))))))) (and (= sx.R@1 (store sx.R x@@0 SHARED)) (= (ControlFlow 0 7) 2)))) inline$AtomicRead$0$Return_correct))))
(let ((inline$AtomicRead$0$ReadShared_correct  (=> (= (select sx.R x@@0) SHARED) (=> (and (and (and (= (|tid#epoch| (select sx.W x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@0))))) (<= (|clock#epoch| (select sx.W x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@0)))))) (= shadow.VC@0 (store shadow.VC@@0 inline$AtomicRead$0$sx@1 (store (select shadow.VC@@0 inline$AtomicRead$0$sx@1) tid (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) tid))))) (and (= shadow.VC@1 (store shadow.VC@0 inline$AtomicRead$0$sx@1 (store (select shadow.VC@0 inline$AtomicRead$0$sx@1) (- 0 1) (epoch (- 0 1) (ite (< (|clock#epoch| (select (select shadow.VC@0 inline$AtomicRead$0$sx@1) (- 0 1))) (+ tid 1)) (+ tid 1) (|clock#epoch| (select (select shadow.VC@0 inline$AtomicRead$0$sx@1) (- 0 1)))))))) (= (ControlFlow 0 6) 2))) inline$AtomicRead$0$Return_correct))))
(let ((inline$AtomicRead$0$ReadExclusive_correct  (=> (not (= (select sx.R x@@0) SHARED)) (=> (and (= (|tid#epoch| (select sx.W x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@0))))) (<= (|clock#epoch| (select sx.W x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.W x@@0)))))) (=> (and (and (= (|tid#epoch| (select sx.R x@@0)) (|tid#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.R x@@0))))) (<= (|clock#epoch| (select sx.R x@@0)) (|clock#epoch| (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) (|tid#epoch| (select sx.R x@@0)))))) (and (= sx.R@0 (store sx.R x@@0 (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) tid))) (= (ControlFlow 0 5) 2))) inline$AtomicRead$0$Return_correct)))))
(let ((inline$AtomicRead$0$ReadSharedSameEpoch_correct  (=> (= (select sx.R x@@0) SHARED) (=> (and (= (select (select shadow.VC@@0 inline$AtomicRead$0$sx@1) tid) (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) tid)) (= (ControlFlow 0 4) 2)) inline$AtomicRead$0$Return_correct))))
(let ((inline$AtomicRead$0$ReadSameEpoch_correct  (=> (and (= (select sx.R x@@0) (select (select shadow.VC@@0 inline$AtomicRead$0$st@1) tid)) (= (ControlFlow 0 3) 2)) inline$AtomicRead$0$Return_correct)))
(let ((inline$AtomicRead$0$anon0_correct  (=> (and (and (Trigger_AtomicRead_sx inline$AtomicRead$0$sx@0) (Trigger_AtomicRead_st inline$AtomicRead$0$st@0)) (and (= inline$AtomicRead$0$st@1 (ShadowableTid tid)) (= inline$AtomicRead$0$sx@1 (ShadowableVar x@@0)))) (and (and (and (and (and (=> (= (ControlFlow 0 9) 3) inline$AtomicRead$0$ReadSameEpoch_correct) (=> (= (ControlFlow 0 9) 4) inline$AtomicRead$0$ReadSharedSameEpoch_correct)) (=> (= (ControlFlow 0 9) 5) inline$AtomicRead$0$ReadExclusive_correct)) (=> (= (ControlFlow 0 9) 6) inline$AtomicRead$0$ReadShared_correct)) (=> (= (ControlFlow 0 9) 7) inline$AtomicRead$0$ReadShare_correct)) (=> (= (ControlFlow 0 9) 8) inline$AtomicRead$0$WriteReadRace_correct)))))
(let ((inline$AtomicRead$0$Entry_correct  (=> (and (and (and (not (= tid nil)) (>= tid 0)) (>= tid 0)) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 10) 9))) inline$AtomicRead$0$anon0_correct)))
inline$AtomicRead$0$Entry_correct))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun uid () Int)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicReleaseJoinLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseJoinLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicReleaseJoinLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid uid) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseJoinLock$0$Return_correct)))
(let ((inline$AtomicReleaseJoinLock$0$Entry_correct  (=> (and (and (and (= (select shadow.Lock (ShadowableTid uid)) tid) (not (= tid uid))) (and (not (= uid nil)) (>= uid 0))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicReleaseJoinLock$0$anon0_correct)))
inline$AtomicReleaseJoinLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicChooseThreadToJoin$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun thread.HasJoined@0 () (Array Int Int Bool))
(declare-fun thread.HasJoined () (Array Int Int Bool))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicChooseThreadToJoin)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicChooseThreadToJoin$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicChooseThreadToJoin$0$anon0_correct  (=> (not (= tid inline$AtomicChooseThreadToJoin$0$uid@0)) (=> (and (= (select thread.State inline$AtomicChooseThreadToJoin$0$uid@0) 3) (and (not (= inline$AtomicChooseThreadToJoin$0$uid@0 nil)) (>= inline$AtomicChooseThreadToJoin$0$uid@0 0))) (=> (and (and (= (select shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0)) nil) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicChooseThreadToJoin$0$uid@0) tid))) (and (= thread.HasJoined@0 (store thread.HasJoined tid inline$AtomicChooseThreadToJoin$0$uid@0 true)) (= (ControlFlow 0 3) 2))) inline$AtomicChooseThreadToJoin$0$Return_correct)))))
(let ((inline$AtomicChooseThreadToJoin$0$Entry_correct  (=> (and (and (= (select thread.State tid) 2) (and (not (= tid nil)) (>= tid 0))) (= (ControlFlow 0 4) 3)) inline$AtomicChooseThreadToJoin$0$anon0_correct)))
inline$AtomicChooseThreadToJoin$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun inline$AtomicAllocTid$0$uid@0 () Int)
(declare-fun thread.State () (Array Int Int))
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.ForkedBy@0 () (Array Int Int))
(declare-fun thread.ForkedBy () (Array Int Int))
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun shadow.VC@@0 () (Array T@Shadowable (Array Int T@Epoch)))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicAllocTid)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicAllocTid$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicAllocTid$0$anon0_correct  (=> (not (= tid inline$AtomicAllocTid$0$uid@0)) (=> (and (and (and (= (select thread.State inline$AtomicAllocTid$0$uid@0) 0) (and (not (= inline$AtomicAllocTid$0$uid@0 nil)) (>= inline$AtomicAllocTid$0$uid@0 0))) (= thread.State@0 (store thread.State inline$AtomicAllocTid$0$uid@0 1))) (and (and (= thread.ForkedBy@0 (store thread.ForkedBy inline$AtomicAllocTid$0$uid@0 tid)) (= shadow.Lock@0 (store shadow.Lock (ShadowableTid inline$AtomicAllocTid$0$uid@0) tid))) (and (VCRepOk (select shadow.VC@@0 (ShadowableTid inline$AtomicAllocTid$0$uid@0))) (= (ControlFlow 0 3) 2)))) inline$AtomicAllocTid$0$Return_correct))))
(let ((inline$AtomicAllocTid$0$Entry_correct  (=> (forall ((t Int) ) (!  (=> (= (select thread.State t) 0) (= (select shadow.Lock (ShadowableTid t)) nil))
 :qid |verifiedftbpl.1025:20|
 :skolemid |39|
)) (=> (and (and (= (select thread.State tid) 2) (and (not (= tid nil)) (>= tid 0))) (= (ControlFlow 0 4) 3)) inline$AtomicAllocTid$0$anon0_correct))))
inline$AtomicAllocTid$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun thread.State@0 () (Array Int Int))
(declare-fun thread.State () (Array Int Int))
(declare-fun uid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicStartThread)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicStartThread$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicStartThread$0$anon0_correct  (=> (= thread.State@0 (store thread.State uid 2)) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableTid uid) uid)) (= (ControlFlow 0 3) 2)) inline$AtomicStartThread$0$Return_correct))))
(let ((inline$AtomicStartThread$0$Entry_correct  (=> (= (select thread.State uid) 1) (=> (and (and (and (= (select shadow.Lock (ShadowableTid uid)) tid) (not (= tid uid))) (and (not (= uid nil)) (>= uid 0))) (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3))) inline$AtomicStartThread$0$anon0_correct))))
inline$AtomicStartThread$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToAcquire$0$l@0 () T@Lock)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicChooseLockToAcquire)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicChooseLockToAcquire$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicChooseLockToAcquire$0$anon0_correct  (=> (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0)) nil) (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock inline$AtomicChooseLockToAcquire$0$l@0) tid)) (= (ControlFlow 0 3) 2)) inline$AtomicChooseLockToAcquire$0$Return_correct))))
(let ((inline$AtomicChooseLockToAcquire$0$Entry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseLockToAcquire$0$anon0_correct)))
inline$AtomicChooseLockToAcquire$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun inline$AtomicChooseLockToRelease$0$l@0 () T@Lock)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicChooseLockToRelease)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicChooseLockToRelease$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicChooseLockToRelease$0$anon0_correct  (=> (and (= (select shadow.Lock (ShadowableLock inline$AtomicChooseLockToRelease$0$l@0)) tid) (= (ControlFlow 0 3) 2)) inline$AtomicChooseLockToRelease$0$Return_correct)))
(let ((inline$AtomicChooseLockToRelease$0$Entry_correct  (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicChooseLockToRelease$0$anon0_correct)))
inline$AtomicChooseLockToRelease$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-sort T@Lock 0)
(declare-sort T@Var 0)
(declare-datatypes ((T@Shadowable 0)) (((ShadowableTid (|tid#ShadowableTid| Int) ) (ShadowableLock (|l#ShadowableLock| T@Lock) ) (ShadowableVar (|x#ShadowableVar| T@Var) ) ) ))
(declare-datatypes ((T@Epoch 0)) (((epoch (|tid#epoch| Int) (|clock#epoch| Int) ) ) ))
(declare-fun nil () Int)
(declare-fun SHARED () T@Epoch)
(declare-fun EMPTY_MAP () (Array Int T@Epoch))
(declare-fun VarsRepOk ((Array T@Var T@Epoch) (Array T@Var T@Epoch)) Bool)
(declare-fun VCRepOk ((Array Int T@Epoch)) Bool)
(declare-fun Identity () (Array Int Int))
(declare-fun f (Int) Bool)
(declare-fun witness ((Array T@Shadowable (Array Int T@Epoch)) (Array T@Shadowable (Array Int T@Epoch)) T@Shadowable) (Array T@Shadowable (Array Int T@Epoch)))
(assert (forall ((w (Array T@Var T@Epoch)) (r (Array T@Var T@Epoch)) ) (! (= (VarsRepOk w r)  (and (forall ((v T@Var) ) (!  (and (not (= (|tid#epoch| (select w v)) nil)) (>= (|tid#epoch| (select w v)) 0))
 :qid |verifiedftbpl.148:11|
 :skolemid |1|
)) (forall ((v@@0 T@Var) ) (!  (or (= (select r v@@0) SHARED) (and (>= (|tid#epoch| (select r v@@0)) 0) (not (= (|tid#epoch| (select r v@@0)) nil))))
 :qid |verifiedftbpl.149:11|
 :skolemid |2|
))))
 :qid |verifiedftbpl.147:36|
 :skolemid |3|
 :pattern ( (VarsRepOk w r))
)))
(assert (forall ((vc (Array Int T@Epoch)) ) (! (= (VCRepOk vc)  (and (and (and (>= (|clock#epoch| (select vc (- 0 1))) 0) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|clock#epoch| (select vc (- 0 1))))) (>= (|clock#epoch| (select vc j)) 0))
 :qid |verifiedftbpl.154:11|
 :skolemid |4|
 :pattern ( (select vc j))
))) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 (|clock#epoch| (select vc (- 0 1))))) (= (|tid#epoch| (select vc j@@0)) j@@0))
 :qid |verifiedftbpl.155:11|
 :skolemid |5|
 :pattern ( (select vc j@@0))
))) (forall ((j@@1 Int) ) (!  (=> (<= (|clock#epoch| (select vc (- 0 1))) j@@1) (= (select vc j@@1) (epoch j@@1 0)))
 :qid |verifiedftbpl.156:11|
 :skolemid |6|
))))
 :qid |verifiedftbpl.152:34|
 :skolemid |7|
 :pattern ( (VCRepOk vc))
)))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |42|
)))
(assert (forall ((i Int) ) (! (= (f i) true)
 :qid |verifiedftbpl.1073:28|
 :skolemid |40|
 :pattern ( (f i))
)))
(assert (forall ((i@@0 Int) ) (! (= (select EMPTY_MAP i@@0) (epoch i@@0 0))
 :qid |verifiedftbpl.139:15|
 :skolemid |0|
)))
(assert (forall ((shadow.VC (Array T@Shadowable (Array Int T@Epoch))) (|shadow.VC'| (Array T@Shadowable (Array Int T@Epoch))) (second_v1 T@Shadowable) ) (! (= (witness shadow.VC |shadow.VC'| second_v1) (store shadow.VC second_v1 (select |shadow.VC'| second_v1)))
 :qid |verifiedftbpl.1089:10|
 :skolemid |41|
 :pattern ( (witness shadow.VC |shadow.VC'| second_v1))
)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun tid () Int)
(declare-fun shadow.Lock@0 () (Array T@Shadowable Int))
(declare-fun shadow.Lock () (Array T@Shadowable Int))
(declare-fun l () T@Lock)
(set-info :boogie-vc-id Civl_LinearityChecker_AtomicReleaseChosenLock)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((inline$AtomicReleaseChosenLock$0$Return_correct  (=> (= (ControlFlow 0 2) (- 0 1)) (= ((_ map (<= (Int Int) Int)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0)) ((_ map (ite (Bool Int Int) Int)) (store ((as const (Array Int Bool)) false) tid true) ((as const (Array Int Int)) 1) ((as const (Array Int Int)) 0))) ((as const (Array Int Bool)) true)))))
(let ((inline$AtomicReleaseChosenLock$0$anon0_correct  (=> (and (= shadow.Lock@0 (store shadow.Lock (ShadowableLock l) nil)) (= (ControlFlow 0 3) 2)) inline$AtomicReleaseChosenLock$0$Return_correct)))
(let ((inline$AtomicReleaseChosenLock$0$Entry_correct  (=> (= (select shadow.Lock (ShadowableLock l)) tid) (=> (and (and (not (= tid nil)) (>= tid 0)) (= (ControlFlow 0 4) 3)) inline$AtomicReleaseChosenLock$0$anon0_correct))))
inline$AtomicReleaseChosenLock$0$Entry_correct))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
