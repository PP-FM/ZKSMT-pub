(set-logic ALIA)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Identity () (Array Int Int))
(assert (forall ((x Int) ) (! (= (select Identity x) x)
 :qid |LibraryDefinitionsbpl.43:15|
 :skolemid |0|
)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun count@5 () Int)
(declare-fun Civl_global_old_count@2 () Int)
(declare-fun Civl_pc@0 () Bool)
(declare-fun Civl_ok@0 () Bool)
(declare-fun count@1 () Int)
(declare-fun count@3 () Int)
(declare-fun count@2 () Int)
(declare-fun count@4 () Int)
(declare-fun Civl_global_old_count@1 () Int)
(declare-fun inline$AtomicCAS$0$status@2 () Bool)
(declare-fun inline$AtomicCAS$0$next@1 () Int)
(declare-fun count@0 () Int)
(set-info :boogie-vc-id Civl_Inc_1)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 26) (let ((Civl_ReturnChecker_correct  (and (=> (= (ControlFlow 0 13) (- 0 15)) (or false (or (= count@5 Civl_global_old_count@2) (= count@5 (+ Civl_global_old_count@2 1))))) (=> (or false (or (= count@5 Civl_global_old_count@2) (= count@5 (+ Civl_global_old_count@2 1)))) (and (=> (= (ControlFlow 0 13) (- 0 14)) (=> false (= count@5 Civl_global_old_count@2))) (=> (=> false (= count@5 Civl_global_old_count@2)) (=> (and (and (= Civl_pc@0  (=> (= count@5 Civl_global_old_count@2) false)) (= Civl_ok@0  (or (= count@5 (+ Civl_global_old_count@2 1)) false))) (= (ControlFlow 0 13) (- 0 12))) Civl_ok@0)))))))
(let ((anon3_LoopDone_@2_Civl_ReturnChecker_correct  (=> (= count@5 count@1) (=> (and (= Civl_global_old_count@2 count@1) (= (ControlFlow 0 22) 13)) Civl_ReturnChecker_correct))))
(let ((anon4_Then_@2_Civl_ReturnChecker_correct  (=> (= count@5 count@3) (=> (and (= Civl_global_old_count@2 count@2) (= (ControlFlow 0 16) 13)) Civl_ReturnChecker_correct))))
(let ((anon4_Else_@2_anon3_LoopHead_correct true))
(let ((Civl_UnchangedChecker_correct  (and (=> (= (ControlFlow 0 6) (- 0 7)) (= count@4 Civl_global_old_count@1)) (=> (= count@4 Civl_global_old_count@1) (=> (= (ControlFlow 0 6) (- 0 5)) (=> false true))))))
(let ((anon4_Else_@2_Civl_UnchangedChecker_correct  (=> (= Civl_global_old_count@1 count@2) (=> (and (= count@4 count@3) (= (ControlFlow 0 10) 6)) Civl_UnchangedChecker_correct))))
(let ((anon3_LoopBody$1_@2_Civl_UnchangedChecker_correct  (=> (= Civl_global_old_count@1 count@1) (=> (and (= count@4 count@1) (= (ControlFlow 0 8) 6)) Civl_UnchangedChecker_correct))))
(let ((Civl_NoninterferenceChecker$1_correct true))
(let ((anon3_LoopDone_correct  (=> (not true) (and (=> (= (ControlFlow 0 23) 22) anon3_LoopDone_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 23) 4) Civl_NoninterferenceChecker$1_correct)))))
(let ((anon4_Then_correct  (=> inline$AtomicCAS$0$status@2 (and (=> (= (ControlFlow 0 17) 16) anon4_Then_@2_Civl_ReturnChecker_correct) (=> (= (ControlFlow 0 17) 4) Civl_NoninterferenceChecker$1_correct)))))
(let ((anon4_Else_correct  (=> (not inline$AtomicCAS$0$status@2) (and (and (=> (= (ControlFlow 0 11) 9) anon4_Else_@2_anon3_LoopHead_correct) (=> (= (ControlFlow 0 11) 10) anon4_Else_@2_Civl_UnchangedChecker_correct)) (=> (= (ControlFlow 0 11) 4) Civl_NoninterferenceChecker$1_correct)))))
(let ((inline$AtomicCAS$0$anon3_Else_correct  (=> (not (= count@2 count@1)) (=> (and (= count@3 count@2) (= inline$AtomicCAS$0$status@2 false)) (and (=> (= (ControlFlow 0 19) 17) anon4_Then_correct) (=> (= (ControlFlow 0 19) 11) anon4_Else_correct))))))
(let ((inline$AtomicCAS$0$anon3_Then_correct  (=> (= count@2 count@1) (=> (and (= count@3 inline$AtomicCAS$0$next@1) (= inline$AtomicCAS$0$status@2 true)) (and (=> (= (ControlFlow 0 18) 17) anon4_Then_correct) (=> (= (ControlFlow 0 18) 11) anon4_Else_correct))))))
(let ((inline$AtomicCAS$0$Entry_correct  (=> (= inline$AtomicCAS$0$next@1 (+ count@1 1)) (and (=> (= (ControlFlow 0 20) 18) inline$AtomicCAS$0$anon3_Then_correct) (=> (= (ControlFlow 0 20) 19) inline$AtomicCAS$0$anon3_Else_correct)))))
(let ((anon3_LoopBody_0_correct  (=> (and (or false true) (= (ControlFlow 0 21) 20)) inline$AtomicCAS$0$Entry_correct)))
(let ((anon3_LoopHead_correct  (=> (or false true) (and (and (and (=> (= (ControlFlow 0 24) 23) anon3_LoopDone_correct) (=> (= (ControlFlow 0 24) 21) anon3_LoopBody_0_correct)) (=> (= (ControlFlow 0 24) 8) anon3_LoopBody$1_@2_Civl_UnchangedChecker_correct)) (=> (= (ControlFlow 0 24) 4) Civl_NoninterferenceChecker$1_correct)))))
(let ((Civl_RefinementChecker_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (or false (or (= count@0 count@0) (= count@0 (+ count@0 1))))) (=> (or false (or (= count@0 count@0) (= count@0 (+ count@0 1)))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> false (= count@0 count@0)))))))
(let ((anon0_correct  (and (and (=> (= (ControlFlow 0 25) 2) Civl_RefinementChecker_correct) (=> (= (ControlFlow 0 25) 4) Civl_NoninterferenceChecker$1_correct)) (=> (= (ControlFlow 0 25) 24) anon3_LoopHead_correct))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 26) 25) anon0_correct)))
PreconditionGeneratedEntry_correct))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
