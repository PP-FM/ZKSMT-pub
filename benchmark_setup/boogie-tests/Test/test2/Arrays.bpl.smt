(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun k@0 () Int)
(declare-sort T@ref 0)
(declare-sort |T@[ref]Int| 0)
(declare-fun |Select__T@[ref]Int_| (|T@[ref]Int| T@ref) Int)
(declare-fun A () |T@[ref]Int|)
(declare-fun q () T@ref)
(declare-fun A@0 () |T@[ref]Int|)
(declare-fun |Store__T@[ref]Int_| (|T@[ref]Int| T@ref Int) |T@[ref]Int|)
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?x2 Int)) (! (= (|Select__T@[ref]Int_| (|Store__T@[ref]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 Int)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[ref]Int_| (|Store__T@[ref]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[ref]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun o () T@ref)
(declare-fun y () Int)
(declare-fun A@1 () |T@[ref]Int|)
(set-info :boogie-vc-id P0)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((start_correct  (=> (= k@0 (|Select__T@[ref]Int_| A q)) (=> (and (= A@0 (|Store__T@[ref]Int_| A o (+ y (|Select__T@[ref]Int_| A o)))) (= A@1 (|Store__T@[ref]Int_| A@0 q k@0))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (= (|Select__T@[ref]Int_| A@1 o) (+ (|Select__T@[ref]Int_| A o) y))) (=> (= (|Select__T@[ref]Int_| A@1 o) (+ (|Select__T@[ref]Int_| A o) y)) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((p T@ref) ) (!  (or (= (|Select__T@[ref]Int_| A@1 p) (|Select__T@[ref]Int_| A p)) (= p o))
 :qid |Arraysbpl.13:19|
 :skolemid |0|
)))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= o q)) (= (ControlFlow 0 4) 2)) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun k@0 () Int)
(declare-sort T@ref 0)
(declare-sort |T@[ref]Int| 0)
(declare-fun |Select__T@[ref]Int_| (|T@[ref]Int| T@ref) Int)
(declare-fun A () |T@[ref]Int|)
(declare-fun q () T@ref)
(declare-fun A@0 () |T@[ref]Int|)
(declare-fun |Store__T@[ref]Int_| (|T@[ref]Int| T@ref Int) |T@[ref]Int|)
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?x2 Int)) (! (= (|Select__T@[ref]Int_| (|Store__T@[ref]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 Int)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[ref]Int_| (|Store__T@[ref]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[ref]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun o () T@ref)
(declare-fun y () Int)
(declare-fun A@1 () |T@[ref]Int|)
(set-info :boogie-vc-id P1)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((start_correct  (=> (and (and (= k@0 (|Select__T@[ref]Int_| A q)) (= A@0 (|Store__T@[ref]Int_| A o (+ y (|Select__T@[ref]Int_| A o))))) (and (= A@1 (|Store__T@[ref]Int_| A@0 q k@0)) (= (ControlFlow 0 2) (- 0 1)))) (forall ((p T@ref) ) (!  (or (= (|Select__T@[ref]Int_| A@1 p) (|Select__T@[ref]Int_| A p)) (= p o))
 :qid |Arraysbpl.28:19|
 :skolemid |1|
)))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 3) 2) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun k@0 () Int)
(declare-sort T@ref 0)
(declare-sort |T@[ref]Int| 0)
(declare-fun |Select__T@[ref]Int_| (|T@[ref]Int| T@ref) Int)
(declare-fun A () |T@[ref]Int|)
(declare-fun q () T@ref)
(declare-fun A@0 () |T@[ref]Int|)
(declare-fun |Store__T@[ref]Int_| (|T@[ref]Int| T@ref Int) |T@[ref]Int|)
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?x2 Int)) (! (= (|Select__T@[ref]Int_| (|Store__T@[ref]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 Int)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[ref]Int_| (|Store__T@[ref]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[ref]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun o () T@ref)
(declare-fun y () Int)
(declare-fun A@1 () |T@[ref]Int|)
(set-info :boogie-vc-id P2)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((start_correct  (=> (and (and (= k@0 (|Select__T@[ref]Int_| A q)) (= A@0 (|Store__T@[ref]Int_| A o (+ y (|Select__T@[ref]Int_| A o))))) (and (= A@1 (|Store__T@[ref]Int_| A@0 q k@0)) (= (ControlFlow 0 2) (- 0 1)))) (= (|Select__T@[ref]Int_| A@1 o) (+ (|Select__T@[ref]Int_| A o) y)))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 3) 2) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(get-info :reason-unknown)
(assert (not (= (ControlFlow 0 2) (- 1))))
(check-sat)
(pop 1)
; Invalid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Invalid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun k@0 () Int)
(declare-sort T@ref 0)
(declare-sort T@name 0)
(declare-sort |T@[ref,name]Int| 0)
(declare-fun |Select__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name) Int)
(declare-fun B () |T@[ref,name]Int|)
(declare-fun q () T@ref)
(declare-fun G () T@name)
(declare-fun B@0 () |T@[ref,name]Int|)
(declare-fun |Store__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name Int) |T@[ref,name]Int|)
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?x2 T@name) ( ?x3 Int)) (! (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?x1 ?x2)  ?x3) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 T@name) ( ?y2 T@name) ( ?x3 Int)) (! (=> (or  (not (= ?x1 ?y1)) (not (= ?x2 ?y2))) (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?y1 ?y2) (|Select__T@[ref,name]Int_| ?x0 ?y1 ?y2))) :weight 0)))
(declare-fun o () T@ref)
(declare-fun F () T@name)
(declare-fun y () Int)
(declare-fun B@1 () |T@[ref,name]Int|)
(set-info :boogie-vc-id Q0)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((start_correct  (=> (= k@0 (|Select__T@[ref,name]Int_| B q G)) (=> (and (= B@0 (|Store__T@[ref,name]Int_| B o F (+ y (|Select__T@[ref,name]Int_| B o F)))) (= B@1 (|Store__T@[ref,name]Int_| B@0 q G k@0))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (= (|Select__T@[ref,name]Int_| B@1 o F) (+ (|Select__T@[ref,name]Int_| B o F) y))) (=> (= (|Select__T@[ref,name]Int_| B@1 o F) (+ (|Select__T@[ref,name]Int_| B o F) y)) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((p T@ref) (f T@name) ) (!  (or (= (|Select__T@[ref,name]Int_| B@1 p f) (|Select__T@[ref,name]Int_| B p f)) (and (= p o) (= f F)))
 :qid |Arraysbpl.62:19|
 :skolemid |2|
)))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (not (= o q)) (not (= F G))) (= (ControlFlow 0 4) 2)) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun k@0 () Int)
(declare-sort T@ref 0)
(declare-sort T@name 0)
(declare-sort |T@[ref,name]Int| 0)
(declare-fun |Select__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name) Int)
(declare-fun B () |T@[ref,name]Int|)
(declare-fun q () T@ref)
(declare-fun G () T@name)
(declare-fun B@0 () |T@[ref,name]Int|)
(declare-fun |Store__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name Int) |T@[ref,name]Int|)
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?x2 T@name) ( ?x3 Int)) (! (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?x1 ?x2)  ?x3) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 T@name) ( ?y2 T@name) ( ?x3 Int)) (! (=> (or  (not (= ?x1 ?y1)) (not (= ?x2 ?y2))) (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?y1 ?y2) (|Select__T@[ref,name]Int_| ?x0 ?y1 ?y2))) :weight 0)))
(declare-fun o () T@ref)
(declare-fun F () T@name)
(declare-fun y () Int)
(declare-fun B@1 () |T@[ref,name]Int|)
(set-info :boogie-vc-id Q1)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((start_correct  (=> (and (and (= k@0 (|Select__T@[ref,name]Int_| B q G)) (= B@0 (|Store__T@[ref,name]Int_| B o F (+ y (|Select__T@[ref,name]Int_| B o F))))) (and (= B@1 (|Store__T@[ref,name]Int_| B@0 q G k@0)) (= (ControlFlow 0 2) (- 0 1)))) (forall ((p T@ref) (f T@name) ) (!  (or (= (|Select__T@[ref,name]Int_| B@1 p f) (|Select__T@[ref,name]Int_| B p f)) (and (= p o) (= f F)))
 :qid |Arraysbpl.78:19|
 :skolemid |3|
)))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 3) 2) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun k@0 () Int)
(declare-sort T@ref 0)
(declare-sort T@name 0)
(declare-sort |T@[ref,name]Int| 0)
(declare-fun |Select__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name) Int)
(declare-fun B () |T@[ref,name]Int|)
(declare-fun q () T@ref)
(declare-fun G () T@name)
(declare-fun B@0 () |T@[ref,name]Int|)
(declare-fun |Store__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name Int) |T@[ref,name]Int|)
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?x2 T@name) ( ?x3 Int)) (! (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?x1 ?x2)  ?x3) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 T@name) ( ?y2 T@name) ( ?x3 Int)) (! (=> (or  (not (= ?x1 ?y1)) (not (= ?x2 ?y2))) (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?y1 ?y2) (|Select__T@[ref,name]Int_| ?x0 ?y1 ?y2))) :weight 0)))
(declare-fun o () T@ref)
(declare-fun F () T@name)
(declare-fun y () Int)
(declare-fun B@1 () |T@[ref,name]Int|)
(set-info :boogie-vc-id Q2)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((start_correct  (=> (and (and (= k@0 (|Select__T@[ref,name]Int_| B q G)) (= B@0 (|Store__T@[ref,name]Int_| B o F (+ y (|Select__T@[ref,name]Int_| B o F))))) (and (= B@1 (|Store__T@[ref,name]Int_| B@0 q G k@0)) (= (ControlFlow 0 2) (- 0 1)))) (= (|Select__T@[ref,name]Int_| B@1 o F) (+ (|Select__T@[ref,name]Int_| B o F) y)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= F G)) (= (ControlFlow 0 3) 2)) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun k@0 () Int)
(declare-sort T@ref 0)
(declare-sort T@name 0)
(declare-sort |T@[ref,name]Int| 0)
(declare-fun |Select__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name) Int)
(declare-fun B () |T@[ref,name]Int|)
(declare-fun q () T@ref)
(declare-fun G () T@name)
(declare-fun B@0 () |T@[ref,name]Int|)
(declare-fun |Store__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name Int) |T@[ref,name]Int|)
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?x2 T@name) ( ?x3 Int)) (! (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?x1 ?x2)  ?x3) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 T@name) ( ?y2 T@name) ( ?x3 Int)) (! (=> (or  (not (= ?x1 ?y1)) (not (= ?x2 ?y2))) (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?y1 ?y2) (|Select__T@[ref,name]Int_| ?x0 ?y1 ?y2))) :weight 0)))
(declare-fun o () T@ref)
(declare-fun F () T@name)
(declare-fun y () Int)
(declare-fun B@1 () |T@[ref,name]Int|)
(set-info :boogie-vc-id Q3)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((start_correct  (=> (and (and (= k@0 (|Select__T@[ref,name]Int_| B q G)) (= B@0 (|Store__T@[ref,name]Int_| B o F (+ y (|Select__T@[ref,name]Int_| B o F))))) (and (= B@1 (|Store__T@[ref,name]Int_| B@0 q G k@0)) (= (ControlFlow 0 2) (- 0 1)))) (= (|Select__T@[ref,name]Int_| B@1 o F) (+ (|Select__T@[ref,name]Int_| B o F) y)))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (not (= o q)) (= (ControlFlow 0 3) 2)) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun k@0 () Int)
(declare-sort T@ref 0)
(declare-sort T@name 0)
(declare-sort |T@[ref,name]Int| 0)
(declare-fun |Select__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name) Int)
(declare-fun B () |T@[ref,name]Int|)
(declare-fun q () T@ref)
(declare-fun G () T@name)
(declare-fun B@0 () |T@[ref,name]Int|)
(declare-fun |Store__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name Int) |T@[ref,name]Int|)
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?x2 T@name) ( ?x3 Int)) (! (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?x1 ?x2)  ?x3) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 T@name) ( ?y2 T@name) ( ?x3 Int)) (! (=> (or  (not (= ?x1 ?y1)) (not (= ?x2 ?y2))) (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?y1 ?y2) (|Select__T@[ref,name]Int_| ?x0 ?y1 ?y2))) :weight 0)))
(declare-fun o () T@ref)
(declare-fun F () T@name)
(declare-fun y () Int)
(declare-fun B@1 () |T@[ref,name]Int|)
(set-info :boogie-vc-id Q4)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 3) (let ((start_correct  (=> (and (and (= k@0 (|Select__T@[ref,name]Int_| B q G)) (= B@0 (|Store__T@[ref,name]Int_| B o F (+ y (|Select__T@[ref,name]Int_| B o F))))) (and (= B@1 (|Store__T@[ref,name]Int_| B@0 q G k@0)) (= (ControlFlow 0 2) (- 0 1)))) (= (|Select__T@[ref,name]Int_| B@1 o F) (+ (|Select__T@[ref,name]Int_| B o F) y)))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 3) 2) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(get-info :reason-unknown)
(assert (not (= (ControlFlow 0 2) (- 1))))
(check-sat)
(pop 1)
; Invalid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Invalid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-sort T@ref 0)
(declare-sort |T@[ref]Int| 0)
(declare-fun |Select__T@[ref]Int_| (|T@[ref]Int| T@ref) Int)
(declare-fun A () |T@[ref]Int|)
(declare-sort T@name 0)
(declare-sort |T@[ref,name]Int| 0)
(declare-fun |Select__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name) Int)
(declare-fun B () |T@[ref,name]Int|)
(set-info :boogie-vc-id Skip0)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 4) (let ((start_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (forall ((p T@ref) ) (! (= (|Select__T@[ref]Int_| A p) (|Select__T@[ref]Int_| A p))
 :qid |Arraysbpl.138:19|
 :skolemid |4|
))) (=> (forall ((p@@0 T@ref) ) (! (= (|Select__T@[ref]Int_| A p@@0) (|Select__T@[ref]Int_| A p@@0))
 :qid |Arraysbpl.138:19|
 :skolemid |4|
)) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((p@@1 T@ref) (g T@name) ) (! (= (|Select__T@[ref,name]Int_| B p@@1 g) (|Select__T@[ref,name]Int_| B p@@1 g))
 :qid |Arraysbpl.139:19|
 :skolemid |5|
)))))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 4) 2) start_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
; Valid

(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-sort T@ref 0)
(declare-sort |T@[ref]Int| 0)
(declare-fun |Select__T@[ref]Int_| (|T@[ref]Int| T@ref) Int)
(declare-fun A@4 () |T@[ref]Int|)
(declare-fun A () |T@[ref]Int|)
(declare-sort T@name 0)
(declare-sort |T@[ref,name]Int| 0)
(declare-fun |Select__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name) Int)
(declare-fun B@4 () |T@[ref,name]Int|)
(declare-fun B () |T@[ref,name]Int|)
(declare-fun B@2 () |T@[ref,name]Int|)
(declare-fun |Store__T@[ref,name]Int_| (|T@[ref,name]Int| T@ref T@name Int) |T@[ref,name]Int|)
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?x2 T@name) ( ?x3 Int)) (! (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?x1 ?x2)  ?x3) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref,name]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 T@name) ( ?y2 T@name) ( ?x3 Int)) (! (=> (or  (not (= ?x1 ?y1)) (not (= ?x2 ?y2))) (= (|Select__T@[ref,name]Int_| (|Store__T@[ref,name]Int_| ?x0 ?x1 ?x2 ?x3) ?y1 ?y2) (|Select__T@[ref,name]Int_| ?x0 ?y1 ?y2))) :weight 0)))
(declare-fun q () T@ref)
(declare-fun H () T@name)
(declare-fun l@1 () Int)
(declare-fun B@3 () |T@[ref,name]Int|)
(declare-fun o () T@ref)
(declare-fun G () T@name)
(declare-fun k@1 () Int)
(declare-fun B@0 () |T@[ref,name]Int|)
(declare-fun B@1 () |T@[ref,name]Int|)
(declare-fun A@2 () |T@[ref]Int|)
(declare-fun |Store__T@[ref]Int_| (|T@[ref]Int| T@ref Int) |T@[ref]Int|)
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?x2 Int)) (! (= (|Select__T@[ref]Int_| (|Store__T@[ref]Int_| ?x0 ?x1 ?x2) ?x1)  ?x2) :weight 0)))
(assert (forall ( ( ?x0 |T@[ref]Int|) ( ?x1 T@ref) ( ?y1 T@ref) ( ?x2 Int)) (! (=>  (not (= ?x1 ?y1)) (= (|Select__T@[ref]Int_| (|Store__T@[ref]Int_| ?x0 ?x1 ?x2) ?y1) (|Select__T@[ref]Int_| ?x0 ?y1))) :weight 0)))
(declare-fun l@0 () Int)
(declare-fun A@3 () |T@[ref]Int|)
(declare-fun k@0 () Int)
(declare-fun A@0 () |T@[ref]Int|)
(declare-fun A@1 () |T@[ref]Int|)
(set-info :boogie-vc-id Skip1)
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 10) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 2) (- 0 3)) (forall ((p T@ref) ) (! (= (|Select__T@[ref]Int_| A@4 p) (|Select__T@[ref]Int_| A p))
 :qid |Arraysbpl.147:19|
 :skolemid |6|
))) (=> (forall ((p@@0 T@ref) ) (! (= (|Select__T@[ref]Int_| A@4 p@@0) (|Select__T@[ref]Int_| A p@@0))
 :qid |Arraysbpl.147:19|
 :skolemid |6|
)) (=> (= (ControlFlow 0 2) (- 0 1)) (forall ((p@@1 T@ref) (g T@name) ) (! (= (|Select__T@[ref,name]Int_| B@4 p@@1 g) (|Select__T@[ref,name]Int_| B p@@1 g))
 :qid |Arraysbpl.148:19|
 :skolemid |7|
)))))))
(let ((Ly_correct  (=> (and (and (= B@2 (|Store__T@[ref,name]Int_| B q H l@1)) (= B@3 (|Store__T@[ref,name]Int_| B@2 o G k@1))) (and (= B@4 B@3) (= (ControlFlow 0 5) 2))) GeneratedUnifiedExit_correct)))
(let ((Lx_correct  (=> (and (and (= B@0 (|Store__T@[ref,name]Int_| B o G k@1)) (= B@1 (|Store__T@[ref,name]Int_| B@0 q H l@1))) (and (= B@4 B@1) (= (ControlFlow 0 4) 2))) GeneratedUnifiedExit_correct)))
(let ((next_correct  (=> (and (= k@1 (|Select__T@[ref,name]Int_| B o G)) (= l@1 (|Select__T@[ref,name]Int_| B q H))) (and (=> (= (ControlFlow 0 6) 4) Lx_correct) (=> (= (ControlFlow 0 6) 5) Ly_correct)))))
(let ((theOtherWay_correct  (=> (and (and (= A@2 (|Store__T@[ref]Int_| A q l@0)) (= A@3 (|Store__T@[ref]Int_| A@2 o k@0))) (and (= A@4 A@3) (= (ControlFlow 0 8) 6))) next_correct)))
(let ((oneWay_correct  (=> (and (and (= A@0 (|Store__T@[ref]Int_| A o k@0)) (= A@1 (|Store__T@[ref]Int_| A@0 q l@0))) (and (= A@4 A@1) (= (ControlFlow 0 7) 6))) next_correct)))
(let ((start_correct  (=> (and (= k@0 (|Select__T@[ref]Int_| A o)) (= l@0 (|Select__T@[ref]Int_| A q))) (and (=> (= (ControlFlow 0 9) 7) oneWay_correct) (=> (= (ControlFlow 0 9) 8) theOtherWay_correct)))))
(let ((PreconditionGeneratedEntry_correct  (=> (= (ControlFlow 0 10) 9) start_correct)))
PreconditionGeneratedEntry_correct)))))))))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
