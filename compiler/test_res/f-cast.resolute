unsat
(! (let ((.cse6 (+ SHRT_MIN 32768))) (let ((.cse0 (= .cse6 0))) (res .cse0 (! (let ((.cse1 (= SHRT_MIN (- 32768)))) (res .cse1 (assume .cse1) (let ((.cse2 (= .cse1 .cse0))) (res .cse2 (res .cse0 (res .cse1 (=+1 .cse2) (let ((.cse3 (= (- 32768) SHRT_MIN))) (res .cse3 (symm (- 32768) SHRT_MIN) (let ((.cse4 (< .cse6 0))) (res .cse4 (let ((.cse5 (< 0 .cse6))) (res .cse5 (trichotomy .cse6 0) (farkas 1 .cse1 1 .cse5))) (farkas 1 .cse3 1 .cse4)))))) (res .cse1 (let ((.cse7 (= 0 .cse6))) (res .cse7 (symm 0 .cse6) (let ((.cse8 (< SHRT_MIN (- 32768)))) (res .cse8 (let ((.cse9 (< (- 32768) SHRT_MIN))) (res .cse9 (trichotomy SHRT_MIN (- 32768)) (farkas 1 .cse0 1 .cse9))) (farkas 1 .cse7 1 .cse8))))) (=+2 .cse2))) (=-2 .cse2))))) :proves (+ .cse0) :input) (let ((.cse36 (f a))) (let ((.cse35 (* (- 1) .cse36))) (let ((.cse49 (+ SHRT_MIN .cse35))) (let ((.cse10 (<= .cse49 0))) (res .cse10 (let ((.cse40 (f b))) (let ((.cse77 (* (- 1) .cse40))) (let ((.cse78 (+ SHRT_MAX .cse77 1))) (let ((.cse46 (<= 1 .cse78)) (.cse11 (<= .cse78 0))) (let-proof ((.cse47 (total-int .cse78 0))) (res .cse11 (let ((.cse18 (+ SHRT_MAX (- 32767)))) (let ((.cse12 (= .cse18 0))) (res .cse12 (! (let ((.cse13 (= SHRT_MAX 32767))) (res .cse13 (assume .cse13) (let ((.cse14 (= .cse13 .cse12))) (res .cse14 (res .cse12 (res .cse13 (=+1 .cse14) (let ((.cse15 (= 32767 SHRT_MAX))) (res .cse15 (symm 32767 SHRT_MAX) (let ((.cse16 (< .cse18 0))) (res .cse16 (let ((.cse17 (< 0 .cse18))) (res .cse17 (trichotomy .cse18 0) (farkas 1 .cse13 1 .cse17))) (farkas 1 .cse15 1 .cse16)))))) (res .cse13 (let ((.cse19 (= 0 .cse18))) (res .cse19 (symm 0 .cse18) (let ((.cse20 (< SHRT_MAX 32767))) (res .cse20 (let ((.cse21 (< 32767 SHRT_MAX))) (res .cse21 (trichotomy SHRT_MAX 32767) (farkas 1 .cse12 1 .cse21))) (farkas 1 .cse19 1 .cse20))))) (=+2 .cse14))) (=-2 .cse14))))) :proves (+ .cse12) :input) (let ((.cse44 (+ .cse36 .cse40))) (let ((.cse22 (= .cse44 0))) (res .cse22 (! (let ((.cse23 (= .cse40 .cse35))) (res .cse23 (! (let ((.cse29 (- a)) (.cse30 (* (- 1) a))) (let ((.cse27 (= .cse29 .cse30)) (.cse24 (= b .cse30))) (let-proof ((.cse28 (-def a))) (res .cse24 (! (let ((.cse25 (= b .cse29))) (res .cse25 (assume .cse25) (let ((.cse26 (= .cse25 .cse24))) (res .cse26 (res .cse27 .cse28 (res (= b b) (refl b) (cong (= b .cse29) (= b .cse30)))) (=-2 .cse26))))) :proves (+ .cse24) :input) (let ((.cse38 (f .cse30))) (let ((.cse31 (= .cse38 .cse35))) (res .cse31 (! (let ((.cse37 (f .cse29)) (.cse34 (- .cse36))) (let ((.cse32 (= .cse37 .cse34))) (res .cse32 (assume .cse32) (let ((.cse33 (= .cse32 .cse31))) (res .cse33 (res (= .cse34 .cse35) (-def .cse36) (res (= .cse37 .cse38) (res .cse27 .cse28 (cong (f .cse29) (f .cse30))) (cong (= .cse37 .cse34) (= .cse38 .cse35)))) (=-2 .cse33)))))) :proves (+ .cse31) :input) (let ((.cse39 (= .cse40 .cse38))) (res .cse39 (! (cong (f b) (f .cse30)) :proves (+ .cse39 - .cse24) :cong (.cse40 .cse38)) (! (trans .cse40 .cse38 .cse35) :proves (+ .cse23 - .cse39 - .cse31) :trans (.cse40 .cse38 .cse35))))))))))) :proves (+ .cse23) :rup) (! (let ((.cse41 (= .cse35 .cse40))) (res .cse41 (symm .cse35 .cse40) (let ((.cse42 (< .cse44 0))) (res .cse42 (let ((.cse43 (< 0 .cse44))) (res .cse43 (trichotomy .cse44 0) (farkas 1 .cse23 1 .cse43))) (farkas 1 .cse41 1 .cse42))))) :proves (- .cse23 + .cse22) :EQ))) :proves (+ .cse22) :rup) (! (let ((.cse45 (= 0 .cse44))) (res .cse45 (symm 0 .cse44) (res .cse46 .cse47 (let ((.cse48 (<= 1 .cse49))) (res .cse48 (total-int .cse49 0) (farkas 1 .cse0 1 .cse48 1 .cse46 1 .cse45 1 .cse12)))))) :proves (- .cse0 + .cse10 + .cse11 - .cse22 - .cse12) :LA (1 (- 1) (- 1) (- 1) 1)))))))) (! (let ((.cse74 (+ SHRT_MIN .cse77)) (.cse76 (+ .cse40 (* (- 1) SHRT_MAX)))) (let ((.cse51 (<= .cse76 0)) (.cse71 (<= .cse74 0))) (let ((.cse69 (not .cse71)) (.cse52 (not .cse51))) (let ((.cse56 (< 0 .cse76)) (.cse50 (or .cse69 .cse52))) (let-proof ((.cse53 (not+ .cse52)) (.cse57 (total .cse76 0))) (res .cse50 (! (res .cse51 (res .cse52 .cse53 (or+ 1 .cse50)) (let ((.cse54 (not .cse11))) (let-proof ((.cse58 (not- .cse54))) (res .cse54 (let ((.cse55 (= .cse51 .cse54))) (res .cse55 (res .cse54 (res .cse51 (=+1 .cse55) (res .cse11 (not+ .cse54) (farkas 1 .cse51 1 .cse11))) (res .cse51 (res .cse56 .cse57 (res .cse11 (res .cse46 .cse47 (farkas 1 .cse56 1 .cse46)) .cse58)) (=+2 .cse55))) (=-2 .cse55))) .cse58)))) :proves (+ .cse50 - .cse11) :input) (! (res err (! (let ((.cse63 (not .cse50))) (let ((.cse59 (or .cse63 err))) (res .cse59 (let ((.cse70 (< .cse40 SHRT_MIN)) (.cse66 (< SHRT_MAX .cse40))) (let ((.cse64 (or .cse70 .cse66))) (let ((.cse62 (not .cse64))) (let ((.cse60 (or .cse62 err))) (res .cse60 (assume .cse60) (let ((.cse61 (= .cse60 .cse59))) (res .cse61 (res (= err err) (refl err) (res (= .cse62 .cse63) (res (= .cse64 .cse50) (let ((.cse65 (= .cse66 .cse52))) (res .cse65 (res .cse52 (res .cse66 (=+1 .cse65) (res .cse51 .cse53 (farkas 1 .cse66 1 .cse51))) (res .cse66 (let ((.cse67 (<= .cse40 SHRT_MAX))) (res .cse67 (total .cse40 SHRT_MAX) (res .cse51 (res .cse56 .cse57 (farkas 1 .cse67 1 .cse56)) (not- .cse52)))) (=+2 .cse65))) (let ((.cse68 (= .cse70 .cse69))) (res .cse68 (res .cse69 (res .cse70 (=+1 .cse68) (res .cse71 (not+ .cse69) (farkas 1 .cse70 1 .cse71))) (res .cse70 (let ((.cse72 (<= SHRT_MIN .cse40))) (res .cse72 (total SHRT_MIN .cse40) (res .cse71 (let ((.cse73 (< 0 .cse74))) (res .cse73 (total .cse74 0) (farkas 1 .cse72 1 .cse73))) (not- .cse69)))) (=+2 .cse68))) (cong (or .cse70 .cse66) (or .cse69 .cse52)))))) (cong (not .cse64) (not .cse50))) (cong (or .cse62 err) (or .cse63 err)))) (=-2 .cse61)))))))) (res .cse63 (or- .cse59) (not- .cse63))))) :proves (- .cse50 + err) :input) (! (let ((.cse75 (not err))) (res .cse75 (assume .cse75) (not- .cse75))) :proves (- err) :input)) :proves (- .cse50) :rup))))))) :proves (- .cse11) :rup))))))) (! (let ((.cse79 (< .cse36 SHRT_MIN))) (res .cse79 (assume .cse79) (let ((.cse80 (not .cse10))) (let-proof ((.cse84 (not- .cse80))) (res .cse80 (let ((.cse81 (= .cse79 .cse80))) (res .cse81 (res .cse80 (res .cse79 (=+1 .cse81) (res .cse10 (not+ .cse80) (farkas 1 .cse79 1 .cse10))) (res .cse79 (let ((.cse82 (<= SHRT_MIN .cse36))) (res .cse82 (total SHRT_MIN .cse36) (res .cse10 (let ((.cse83 (< 0 .cse49))) (res .cse83 (total .cse49 0) (farkas 1 .cse82 1 .cse83))) .cse84))) (=+2 .cse81))) (=-2 .cse81))) .cse84))))) :proves (- .cse10) :input))))))))) :proves () :rup)