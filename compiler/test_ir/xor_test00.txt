vars: cvc.a cvc.b
premises:
  a0: (xor cvc.a cvc.b)
  a1: (= cvc.a cvc.b)
steps:
  derived clause number: 0
  rule: refl
  expr args: [cvc.b]
  clause args: []
  backptr: nil
  conclusion: (= cvc.b cvc.b)

  derived clause number: 1
  rule: xor_est
  expr args: []
  clause args: [premise a1, derived 0]
  backptr: nil
  conclusion: (= (xor cvc.a cvc.b) (xor cvc.b cvc.b))

  derived clause number: 2
  rule: xor_eq_eq
  expr args: [(= (xor cvc.b cvc.b) false)]
  clause args: []
  backptr: nil
  conclusion: (= (xor cvc.b cvc.b) false)

  derived clause number: 3
  rule: trans
  expr args: []
  clause args: [derived 1, derived 2]
  backptr: nil
  conclusion: (= (xor cvc.a cvc.b) false)

  derived clause number: 4
  rule: eq_resolve
  expr args: []
  clause args: [premise a0, derived 3]
  backptr: nil
  conclusion: false

