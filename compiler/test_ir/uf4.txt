vars: cvc.f cvc.z cvc.x cvc.y
premises:
  a0: (and (not (= (cvc.f cvc.x) (cvc.f cvc.y))) (and (= cvc.y cvc.z) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))))
steps:
  derived clause number: 0
  rule: refl
  expr args: [(and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))]
  clause args: []
  backptr: nil
  conclusion: (= (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))

  derived clause number: 1
  rule: and_flatten
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (and (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))

  derived clause number: 2
  rule: trans
  expr args: []
  clause args: [derived 1, derived 0]
  backptr: nil
  conclusion: (= (and (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))

  derived clause number: 3
  rule: and_cons_equiv
  expr args: [(= cvc.y cvc.z)]
  clause args: [derived 2]
  backptr: nil
  conclusion: (= (and (= cvc.y cvc.z) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))) (and (= cvc.y cvc.z) (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))

  derived clause number: 4
  rule: and_flatten
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (and (and (= cvc.y cvc.z) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))) (and (= cvc.y cvc.z) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))))

  derived clause number: 5
  rule: trans
  expr args: []
  clause args: [derived 4, derived 3]
  backptr: nil
  conclusion: (= (and (and (= cvc.y cvc.z) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))) (and (= cvc.y cvc.z) (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))

  derived clause number: 6
  rule: and_cons_equiv
  expr args: [(not (= (cvc.f cvc.x) (cvc.f cvc.y)))]
  clause args: [derived 5]
  backptr: nil
  conclusion: (= (and (not (= (cvc.f cvc.x) (cvc.f cvc.y))) (and (= cvc.y cvc.z) (and (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))) (and (not (= (cvc.f cvc.x) (cvc.f cvc.y))) (= cvc.y cvc.z) (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y)))

  derived clause number: 7
  rule: eq_resolve
  expr args: []
  clause args: [premise a0, derived 6]
  backptr: nil
  conclusion: (and (not (= (cvc.f cvc.x) (cvc.f cvc.y))) (= cvc.y cvc.z) (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))

  derived clause number: 8
  rule: eq_resolve
  expr args: []
  clause args: [premise a0, derived 6]
  backptr: nil
  conclusion: (and (not (= (cvc.f cvc.x) (cvc.f cvc.y))) (= cvc.y cvc.z) (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))

  derived clause number: 9
  rule: and_elim
  expr args: [3]
  clause args: [derived 8]
  backptr: nil
  conclusion: (= cvc.x cvc.y)

  derived clause number: 10
  rule: refl
  expr args: [cvc.x]
  clause args: []
  backptr: nil
  conclusion: (= cvc.x cvc.x)

  derived clause number: 11
  rule: and_elim
  expr args: [1]
  clause args: [derived 7]
  backptr: nil
  conclusion: (= cvc.y cvc.z)

  derived clause number: 12
  rule: =_est
  expr args: []
  clause args: [derived 10, derived 11]
  backptr: nil
  conclusion: (= (= cvc.x cvc.y) (= cvc.x cvc.z))

  derived clause number: 13
  rule: eq_resolve
  expr args: []
  clause args: [derived 9, derived 12]
  backptr: nil
  conclusion: (= cvc.x cvc.z)

  derived clause number: 14
  rule: and_elim
  expr args: [1]
  clause args: [derived 7]
  backptr: nil
  conclusion: (= cvc.y cvc.z)

  derived clause number: 15
  rule: and_intro1
  expr args: []
  clause args: [derived 14]
  backptr: nil
  conclusion: (and (= cvc.y cvc.z))

  derived clause number: 16
  rule: and_intro2
  expr args: []
  clause args: [derived 13, derived 15]
  backptr: nil
  conclusion: (and (= cvc.x cvc.z) (= cvc.y cvc.z))

  derived clause number: 17
  rule: eq_resolve
  expr args: []
  clause args: [premise a0, derived 6]
  backptr: nil
  conclusion: (and (not (= (cvc.f cvc.x) (cvc.f cvc.y))) (= cvc.y cvc.z) (= (cvc.f cvc.x) (cvc.f (cvc.f cvc.z))) (= cvc.x cvc.y))

  derived clause number: 18
  rule: and_elim
  expr args: [0]
  clause args: [derived 17]
  backptr: nil
  conclusion: (not (= (cvc.f cvc.x) (cvc.f cvc.y)))

  derived clause number: 19
  rule: refl
  expr args: [cvc.f]
  clause args: []
  backptr: nil
  conclusion: (= cvc.f cvc.f)

  derived clause number: 20
  rule: and_elim
  expr args: [0]
  clause args: [derived 16]
  backptr: nil
  conclusion: (= cvc.x cvc.z)

  derived clause number: 21
  rule: cong
  expr args: []
  clause args: [derived 19, derived 20]
  backptr: nil
  conclusion: (= (cvc.f cvc.x) (cvc.f cvc.z))

  derived clause number: 22
  rule: refl
  expr args: [cvc.f]
  clause args: []
  backptr: nil
  conclusion: (= cvc.f cvc.f)

  derived clause number: 23
  rule: and_elim
  expr args: [1]
  clause args: [derived 16]
  backptr: nil
  conclusion: (= cvc.y cvc.z)

  derived clause number: 24
  rule: cong
  expr args: []
  clause args: [derived 22, derived 23]
  backptr: nil
  conclusion: (= (cvc.f cvc.y) (cvc.f cvc.z))

  derived clause number: 25
  rule: =_est
  expr args: []
  clause args: [derived 21, derived 24]
  backptr: nil
  conclusion: (= (= (cvc.f cvc.x) (cvc.f cvc.y)) (= (cvc.f cvc.z) (cvc.f cvc.z)))

  derived clause number: 26
  rule: not_est
  expr args: []
  clause args: [derived 25]
  backptr: nil
  conclusion: (= (not (= (cvc.f cvc.x) (cvc.f cvc.y))) (not (= (cvc.f cvc.z) (cvc.f cvc.z))))

  derived clause number: 27
  rule: refl_equiv
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (= (cvc.f cvc.z) (cvc.f cvc.z)) true)

  derived clause number: 28
  rule: not_est
  expr args: []
  clause args: [derived 27]
  backptr: nil
  conclusion: (= (not (= (cvc.f cvc.z) (cvc.f cvc.z))) (not true))

  derived clause number: 29
  rule: eval_true
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (not true) false)

  derived clause number: 30
  rule: trans
  expr args: []
  clause args: [derived 28, derived 29]
  backptr: nil
  conclusion: (= (not (= (cvc.f cvc.z) (cvc.f cvc.z))) false)

  derived clause number: 31
  rule: trans
  expr args: []
  clause args: [derived 26, derived 30]
  backptr: nil
  conclusion: (= (not (= (cvc.f cvc.x) (cvc.f cvc.y))) false)

  derived clause number: 32
  rule: eq_resolve
  expr args: []
  clause args: [derived 18, derived 31]
  backptr: nil
  conclusion: false

