vars: cvc.c cvc.b cvc.a
premises:
  a0: (not (= ((cvc.b true) true) cvc.a))
  a1: (= cvc.c true)
  a2: (= ((cvc.b true) cvc.c) cvc.a)
steps:
  derived clause number: 0
  rule: eq_equiv
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (= cvc.c true) cvc.c)

  derived clause number: 1
  rule: eq_equiv
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (= cvc.c true) cvc.c)

  derived clause number: 2
  rule: eq_resolve
  expr args: []
  clause args: [premise a1, derived 1]
  backptr: nil
  conclusion: cvc.c

  derived clause number: 3
  rule: neg_symm
  expr args: []
  clause args: [premise a0]
  backptr: nil
  conclusion: (not (= cvc.a ((cvc.b true) true)))

  derived clause number: 4
  rule: symm
  expr args: []
  clause args: [premise a2]
  backptr: nil
  conclusion: (= cvc.a ((cvc.b true) cvc.c))

  derived clause number: 5
  rule: refl
  expr args: [cvc.a]
  clause args: []
  backptr: nil
  conclusion: (= cvc.a cvc.a)

  derived clause number: 6
  rule: refl
  expr args: [cvc.b]
  clause args: []
  backptr: nil
  conclusion: (= cvc.b cvc.b)

  derived clause number: 7
  rule: refl
  expr args: [true]
  clause args: []
  backptr: nil
  conclusion: (= true true)

  derived clause number: 8
  rule: cong
  expr args: []
  clause args: [derived 6, derived 7]
  backptr: nil
  conclusion: (= (cvc.b true) (cvc.b true))

  derived clause number: 9
  rule: symm
  expr args: []
  clause args: [derived 0]
  backptr: nil
  conclusion: (= cvc.c (= cvc.c true))

  derived clause number: 10
  rule: eq_resolve
  expr args: []
  clause args: [derived 2, derived 9]
  backptr: nil
  conclusion: (= cvc.c true)

  derived clause number: 11
  rule: cong
  expr args: []
  clause args: [derived 8, derived 10]
  backptr: nil
  conclusion: (= ((cvc.b true) cvc.c) ((cvc.b true) true))

  derived clause number: 12
  rule: =_est
  expr args: []
  clause args: [derived 5, derived 11]
  backptr: nil
  conclusion: (= (= cvc.a ((cvc.b true) cvc.c)) (= cvc.a ((cvc.b true) true)))

  derived clause number: 13
  rule: eq_resolve
  expr args: []
  clause args: [derived 4, derived 12]
  backptr: nil
  conclusion: (= cvc.a ((cvc.b true) true))

  derived clause number: 14
  rule: symm
  expr args: []
  clause args: [derived 0]
  backptr: nil
  conclusion: (= cvc.c (= cvc.c true))

  derived clause number: 15
  rule: eq_resolve
  expr args: []
  clause args: [derived 2, derived 14]
  backptr: nil
  conclusion: (= cvc.c true)

  derived clause number: 16
  rule: and_intro1
  expr args: []
  clause args: [derived 15]
  backptr: nil
  conclusion: (and (= cvc.c true))

  derived clause number: 17
  rule: and_intro2
  expr args: []
  clause args: [derived 13, derived 16]
  backptr: nil
  conclusion: (and (= cvc.a ((cvc.b true) true)) (= cvc.c true))

  derived clause number: 18
  rule: and_elim
  expr args: [0]
  clause args: [derived 17]
  backptr: nil
  conclusion: (= cvc.a ((cvc.b true) true))

  derived clause number: 19
  rule: refl
  expr args: [((cvc.b true) true)]
  clause args: []
  backptr: nil
  conclusion: (= ((cvc.b true) true) ((cvc.b true) true))

  derived clause number: 20
  rule: =_est
  expr args: []
  clause args: [derived 18, derived 19]
  backptr: nil
  conclusion: (= (= cvc.a ((cvc.b true) true)) (= ((cvc.b true) true) ((cvc.b true) true)))

  derived clause number: 21
  rule: not_est
  expr args: []
  clause args: [derived 20]
  backptr: nil
  conclusion: (= (not (= cvc.a ((cvc.b true) true))) (not (= ((cvc.b true) true) ((cvc.b true) true))))

  derived clause number: 22
  rule: refl_equiv
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (= ((cvc.b true) true) ((cvc.b true) true)) true)

  derived clause number: 23
  rule: not_est
  expr args: []
  clause args: [derived 22]
  backptr: nil
  conclusion: (= (not (= ((cvc.b true) true) ((cvc.b true) true))) (not true))

  derived clause number: 24
  rule: eval_true
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (not true) false)

  derived clause number: 25
  rule: trans
  expr args: []
  clause args: [derived 23, derived 24]
  backptr: nil
  conclusion: (= (not (= ((cvc.b true) true) ((cvc.b true) true))) false)

  derived clause number: 26
  rule: trans
  expr args: []
  clause args: [derived 21, derived 25]
  backptr: nil
  conclusion: (= (not (= cvc.a ((cvc.b true) true))) false)

  derived clause number: 27
  rule: eq_resolve
  expr args: []
  clause args: [derived 3, derived 26]
  backptr: nil
  conclusion: false

