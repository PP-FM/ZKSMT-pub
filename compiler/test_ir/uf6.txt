vars: cvc.f cvc.z cvc.x cvc.y
premises:
  a0: (= cvc.x cvc.y)
  a1: (not (= ((cvc.f cvc.z) cvc.x) ((cvc.f cvc.z) cvc.y)))
steps:
  derived clause number: 0
  rule: refl
  expr args: [cvc.f]
  clause args: []
  backptr: nil
  conclusion: (= cvc.f cvc.f)

  derived clause number: 1
  rule: refl
  expr args: [cvc.z]
  clause args: []
  backptr: nil
  conclusion: (= cvc.z cvc.z)

  derived clause number: 2
  rule: cong
  expr args: []
  clause args: [derived 0, derived 1]
  backptr: nil
  conclusion: (= (cvc.f cvc.z) (cvc.f cvc.z))

  derived clause number: 3
  rule: cong
  expr args: []
  clause args: [derived 2, premise a0]
  backptr: nil
  conclusion: (= ((cvc.f cvc.z) cvc.x) ((cvc.f cvc.z) cvc.y))

  derived clause number: 4
  rule: refl
  expr args: [((cvc.f cvc.z) cvc.y)]
  clause args: []
  backptr: nil
  conclusion: (= ((cvc.f cvc.z) cvc.y) ((cvc.f cvc.z) cvc.y))

  derived clause number: 5
  rule: =_est
  expr args: []
  clause args: [derived 3, derived 4]
  backptr: nil
  conclusion: (= (= ((cvc.f cvc.z) cvc.x) ((cvc.f cvc.z) cvc.y)) (= ((cvc.f cvc.z) cvc.y) ((cvc.f cvc.z) cvc.y)))

  derived clause number: 6
  rule: not_est
  expr args: []
  clause args: [derived 5]
  backptr: nil
  conclusion: (= (not (= ((cvc.f cvc.z) cvc.x) ((cvc.f cvc.z) cvc.y))) (not (= ((cvc.f cvc.z) cvc.y) ((cvc.f cvc.z) cvc.y))))

  derived clause number: 7
  rule: refl_equiv
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (= ((cvc.f cvc.z) cvc.y) ((cvc.f cvc.z) cvc.y)) true)

  derived clause number: 8
  rule: not_est
  expr args: []
  clause args: [derived 7]
  backptr: nil
  conclusion: (= (not (= ((cvc.f cvc.z) cvc.y) ((cvc.f cvc.z) cvc.y))) (not true))

  derived clause number: 9
  rule: eval_true
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (= (not true) false)

  derived clause number: 10
  rule: trans
  expr args: []
  clause args: [derived 8, derived 9]
  backptr: nil
  conclusion: (= (not (= ((cvc.f cvc.z) cvc.y) ((cvc.f cvc.z) cvc.y))) false)

  derived clause number: 11
  rule: trans
  expr args: []
  clause args: [derived 6, derived 10]
  backptr: nil
  conclusion: (= (not (= ((cvc.f cvc.z) cvc.x) ((cvc.f cvc.z) cvc.y))) false)

  derived clause number: 12
  rule: eq_resolve
  expr args: []
  clause args: [premise a1, derived 11]
  backptr: nil
  conclusion: false

