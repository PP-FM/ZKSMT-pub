vars: cvc.P cvc.z cvc.x cvc.y
premises:
  a0: (= cvc.x cvc.y)
  a1: ((cvc.P cvc.z) cvc.x)
  a2: (not ((cvc.P cvc.z) cvc.y))
steps:
  derived clause number: 0
  rule: refl
  expr args: [cvc.P]
  clause args: []
  backptr: nil
  conclusion: (= cvc.P cvc.P)

  derived clause number: 1
  rule: refl
  expr args: [cvc.z]
  clause args: []
  backptr: nil
  conclusion: (= cvc.z cvc.z)

  derived clause number: 2
  rule: cong
  expr args: []
  clause args: [derived 0, derived 1]
  backptr: nil
  conclusion: (= (cvc.P cvc.z) (cvc.P cvc.z))

  derived clause number: 3
  rule: cong
  expr args: []
  clause args: [derived 2, premise a0]
  backptr: nil
  conclusion: (= ((cvc.P cvc.z) cvc.x) ((cvc.P cvc.z) cvc.y))

  derived clause number: 4
  rule: eq_resolve
  expr args: []
  clause args: [premise a1, derived 3]
  backptr: nil
  conclusion: ((cvc.P cvc.z) cvc.y)

  derived clause number: 5
  rule: resolution
  expr args: [ff, ((cvc.P cvc.z) cvc.y)]
  clause args: [premise a2, derived 4]
  backptr: nil
  conclusion: false

