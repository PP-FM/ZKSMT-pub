vars: P x y z
premises:
  a0: (P z x)
  a1: (= x y)
  a2: (not (P z y))
steps:
  derived clause number: 0
  rule: or_single
  expr args: []
  clause args: [premise a0]
  backptr: nil
  conclusion: (or (P z x))

  derived clause number: 1
  rule: or_single
  expr args: []
  clause args: [premise a1]
  backptr: nil
  conclusion: (or (= x y))

  derived clause number: 2
  rule: or_single
  expr args: []
  clause args: [premise a2]
  backptr: nil
  conclusion: (or (not (P z y)))

  derived clause number: 3
  rule: true+
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or true)

  derived clause number: 4
  rule: =+1
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (P z x) (= (P z x) true)) (P z x) (= (P z x) true))

  derived clause number: 5
  rule: =+2
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (P z x) true) (not (P z x)) (not true))

  derived clause number: 6
  rule: resolution
  expr args: [(not (P z x)), (or (= (P z x) true) (not true)), (or (= (P z x) (= (P z x) true)) (= (P z x) true))]
  clause args: [derived 4, derived 5]
  backptr: nil
  conclusion: (or (= (P z x) (= (P z x) true)) (= (P z x) true) (= (P z x) true) (not true))

  derived clause number: 7
  rule: =-1
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (= (P z x) true)) (P z x) (not true))

  derived clause number: 8
  rule: =+2
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (P z x) (= (P z x) true)) (not (P z x)) (not (= (P z x) true)))

  derived clause number: 9
  rule: resolution
  expr args: [(not (P z x)), (or (= (P z x) (= (P z x) true)) (not (= (P z x) true))), (or (not true) (not (= (P z x) true)))]
  clause args: [derived 7, derived 8]
  backptr: nil
  conclusion: (or (not (= (P z x) true)) (not true) (= (P z x) (= (P z x) true)) (not (= (P z x) true)))

  derived clause number: 10
  rule: factoring
  expr args: []
  clause args: [derived 6]
  backptr: nil
  conclusion: (or (= (P z x) (= (P z x) true)) (= (P z x) true) (not true))

  derived clause number: 11
  rule: factoring
  expr args: []
  clause args: [derived 9]
  backptr: nil
  conclusion: (or (not (= (P z x) true)) (not true) (= (P z x) (= (P z x) true)))

  derived clause number: 12
  rule: resolution
  expr args: [(not (= (P z x) true)), (or (not true) (= (P z x) (= (P z x) true))), (or (not true) (= (P z x) (= (P z x) true)))]
  clause args: [derived 10, derived 11]
  backptr: nil
  conclusion: (or (= (P z x) (= (P z x) true)) (not true) (not true) (= (P z x) (= (P z x) true)))

  derived clause number: 13
  rule: factoring
  expr args: []
  clause args: [derived 12]
  backptr: nil
  conclusion: (or (= (P z x) (= (P z x) true)) (not true))

  derived clause number: 14
  rule: resolution
  expr args: [(not true), (or (= (P z x) (= (P z x) true))), (or )]
  clause args: [derived 3, derived 13]
  backptr: nil
  conclusion: (or (= (P z x) (= (P z x) true)))

  derived clause number: 15
  rule: =-2
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (= (P z x) (= (P z x) true))) (not (P z x)) (= (P z x) true))

  derived clause number: 16
  rule: resolution
  expr args: [(not (= (P z x) (= (P z x) true))), (or (not (P z x)) (= (P z x) true)), (or )]
  clause args: [derived 14, derived 15]
  backptr: nil
  conclusion: (or (not (P z x)) (= (P z x) true))

  derived clause number: 17
  rule: resolution
  expr args: [(not (P z x)), (or (= (P z x) true)), (or )]
  clause args: [derived 0, derived 16]
  backptr: nil
  conclusion: (or (= (P z x) true))

  derived clause number: 18
  rule: symm
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= y x) (not (= x y)))

  derived clause number: 19
  rule: refl
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= z z))

  derived clause number: 20
  rule: cong
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (P z y) (P z x)) (not (= z z)) (not (= y x)))

  derived clause number: 21
  rule: resolution
  expr args: [(not (= z z)), (or (= (P z y) (P z x)) (not (= y x))), (or )]
  clause args: [derived 19, derived 20]
  backptr: nil
  conclusion: (or (= (P z y) (P z x)) (not (= y x)))

  derived clause number: 22
  rule: resolution
  expr args: [(not (= y x)), (or (= (P z y) (P z x))), (or (not (= x y)))]
  clause args: [derived 18, derived 21]
  backptr: nil
  conclusion: (or (not (= x y)) (= (P z y) (P z x)))

  derived clause number: 23
  rule: trans
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (P z y) true) (not (= (P z y) (P z x))) (not (= (P z x) true)))

  derived clause number: 24
  rule: resolution
  expr args: [(not (= (P z y) (P z x))), (or (= (P z y) true) (not (= (P z x) true))), (or (not (= x y)))]
  clause args: [derived 22, derived 23]
  backptr: nil
  conclusion: (or (not (= x y)) (= (P z y) true) (not (= (P z x) true)))

  derived clause number: 25
  rule: resolution
  expr args: [(not (= x y)), (or (= (P z y) true) (not (= (P z x) true))), (or )]
  clause args: [derived 1, derived 24]
  backptr: nil
  conclusion: (or (= (P z y) true) (not (= (P z x) true)))

  derived clause number: 26
  rule: resolution
  expr args: [(not (= (P z x) true)), (or (= (P z y) true)), (or )]
  clause args: [derived 17, derived 25]
  backptr: nil
  conclusion: (or (= (P z y) true))

  derived clause number: 27
  rule: not+
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (P z y)) (P z y))

  derived clause number: 28
  rule: =+1
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (P z y) (= (P z y) true)) (P z y) (= (P z y) true))

  derived clause number: 29
  rule: =+2
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (P z y) true) (not (P z y)) (not true))

  derived clause number: 30
  rule: resolution
  expr args: [(not (P z y)), (or (= (P z y) true) (not true)), (or (= (P z y) (= (P z y) true)) (= (P z y) true))]
  clause args: [derived 28, derived 29]
  backptr: nil
  conclusion: (or (= (P z y) (= (P z y) true)) (= (P z y) true) (= (P z y) true) (not true))

  derived clause number: 31
  rule: =-1
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (= (P z y) true)) (P z y) (not true))

  derived clause number: 32
  rule: =+2
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (P z y) (= (P z y) true)) (not (P z y)) (not (= (P z y) true)))

  derived clause number: 33
  rule: resolution
  expr args: [(not (P z y)), (or (= (P z y) (= (P z y) true)) (not (= (P z y) true))), (or (not true) (not (= (P z y) true)))]
  clause args: [derived 31, derived 32]
  backptr: nil
  conclusion: (or (not (= (P z y) true)) (not true) (= (P z y) (= (P z y) true)) (not (= (P z y) true)))

  derived clause number: 34
  rule: factoring
  expr args: []
  clause args: [derived 30]
  backptr: nil
  conclusion: (or (= (P z y) (= (P z y) true)) (= (P z y) true) (not true))

  derived clause number: 35
  rule: factoring
  expr args: []
  clause args: [derived 33]
  backptr: nil
  conclusion: (or (not (= (P z y) true)) (not true) (= (P z y) (= (P z y) true)))

  derived clause number: 36
  rule: resolution
  expr args: [(not (= (P z y) true)), (or (not true) (= (P z y) (= (P z y) true))), (or (not true) (= (P z y) (= (P z y) true)))]
  clause args: [derived 34, derived 35]
  backptr: nil
  conclusion: (or (= (P z y) (= (P z y) true)) (not true) (not true) (= (P z y) (= (P z y) true)))

  derived clause number: 37
  rule: factoring
  expr args: []
  clause args: [derived 36]
  backptr: nil
  conclusion: (or (= (P z y) (= (P z y) true)) (not true))

  derived clause number: 38
  rule: resolution
  expr args: [(not true), (or (= (P z y) (= (P z y) true))), (or )]
  clause args: [derived 3, derived 37]
  backptr: nil
  conclusion: (or (= (P z y) (= (P z y) true)))

  derived clause number: 39
  rule: not_cong
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (not (P z y)) (not (= (P z y) true))) (not (= (P z y) (= (P z y) true))))

  derived clause number: 40
  rule: resolution
  expr args: [(not (= (P z y) (= (P z y) true))), (or (= (not (P z y)) (not (= (P z y) true)))), (or )]
  clause args: [derived 38, derived 39]
  backptr: nil
  conclusion: (or (= (not (P z y)) (not (= (P z y) true))))

  derived clause number: 41
  rule: =-2
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (= (not (P z y)) (not (= (P z y) true)))) (not (not (P z y))) (not (= (P z y) true)))

  derived clause number: 42
  rule: resolution
  expr args: [(not (= (not (P z y)) (not (= (P z y) true)))), (or (not (not (P z y))) (not (= (P z y) true))), (or )]
  clause args: [derived 40, derived 41]
  backptr: nil
  conclusion: (or (not (not (P z y))) (not (= (P z y) true)))

  derived clause number: 43
  rule: resolution
  expr args: [(not (not (P z y))), (or (not (= (P z y) true))), (or (P z y))]
  clause args: [derived 27, derived 42]
  backptr: nil
  conclusion: (or (P z y) (not (= (P z y) true)))

  derived clause number: 44
  rule: resolution
  expr args: [(not (P z y)), (or ), (or (not (= (P z y) true)))]
  clause args: [derived 43, derived 2]
  backptr: nil
  conclusion: (or (not (= (P z y) true)))

  derived clause number: 45
  rule: resolution
  expr args: [(not (= (P z y) true)), (or ), (or )]
  clause args: [derived 26, derived 44]
  backptr: nil
  conclusion: (or )

  derived clause number: 46
  rule: or_nil
  expr args: []
  clause args: [derived 45]
  backptr: nil
  conclusion: false

