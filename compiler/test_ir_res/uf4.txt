vars: f x y z
premises:
  a0: (and (not (= (f x) (f y))) (and (= y z) (and (= (f x) (f (f z))) (= x y))))
steps:
  derived clause number: 0
  rule: or_single
  expr args: []
  clause args: [premise a0]
  backptr: nil
  conclusion: (or (and (not (= (f x) (f y))) (and (= y z) (and (= (f x) (f (f z))) (= x y)))))

  derived clause number: 1
  rule: and-
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (and (not (= (f x) (f y))) (and (= y z) (and (= (f x) (f (f z))) (= x y))))) (and (= y z) (and (= (f x) (f (f z))) (= x y))))

  derived clause number: 2
  rule: resolution
  expr args: [(not (and (not (= (f x) (f y))) (and (= y z) (and (= (f x) (f (f z))) (= x y))))), (or (and (= y z) (and (= (f x) (f (f z))) (= x y)))), (or )]
  clause args: [derived 0, derived 1]
  backptr: nil
  conclusion: (or (and (= y z) (and (= (f x) (f (f z))) (= x y))))

  derived clause number: 3
  rule: and-
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (and (= y z) (and (= (f x) (f (f z))) (= x y)))) (and (= (f x) (f (f z))) (= x y)))

  derived clause number: 4
  rule: resolution
  expr args: [(not (and (= y z) (and (= (f x) (f (f z))) (= x y)))), (or (and (= (f x) (f (f z))) (= x y))), (or )]
  clause args: [derived 2, derived 3]
  backptr: nil
  conclusion: (or (and (= (f x) (f (f z))) (= x y)))

  derived clause number: 5
  rule: and-
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (and (= (f x) (f (f z))) (= x y))) (= x y))

  derived clause number: 6
  rule: resolution
  expr args: [(not (and (= (f x) (f (f z))) (= x y))), (or (= x y)), (or )]
  clause args: [derived 4, derived 5]
  backptr: nil
  conclusion: (or (= x y))

  derived clause number: 7
  rule: cong
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (= (f x) (f y)) (not (= x y)))

  derived clause number: 8
  rule: and-
  expr args: []
  clause args: []
  backptr: nil
  conclusion: (or (not (and (not (= (f x) (f y))) (and (= y z) (and (= (f x) (f (f z))) (= x y))))) (not (= (f x) (f y))))

  derived clause number: 9
  rule: resolution
  expr args: [(not (and (not (= (f x) (f y))) (and (= y z) (and (= (f x) (f (f z))) (= x y))))), (or (not (= (f x) (f y)))), (or )]
  clause args: [derived 0, derived 8]
  backptr: nil
  conclusion: (or (not (= (f x) (f y))))

  derived clause number: 10
  rule: resolution
  expr args: [(not (= (f x) (f y))), (or ), (or (not (= x y)))]
  clause args: [derived 7, derived 9]
  backptr: nil
  conclusion: (or (not (= x y)))

  derived clause number: 11
  rule: resolution
  expr args: [(not (= x y)), (or ), (or )]
  clause args: [derived 6, derived 10]
  backptr: nil
  conclusion: (or )

  derived clause number: 12
  rule: or_nil
  expr args: []
  clause args: [derived 11]
  backptr: nil
  conclusion: false

